// Generated by dts-bundle-generator v9.5.1

export type WebComponentDetail = {
	index: number;
	name: string;
	data?: any;
};
export type WebComponentInitParams<S> = {
	detail: WebComponentDetail;
	state: S;
	refs: Refs;
	self: Bored;
	on: (eventName: string, eventHandler: (options: {
		state: S | undefined;
		e: CustomEvent["detail"];
		detail: WebComponentDetail;
	}) => void | Promise<void>) => void;
};
export type WebComponentRenderParams<S> = {
	detail: WebComponentDetail;
	state: S;
	refs: Refs;
	slots: Slots;
	self: Bored;
	makeComponent: (tag: string, options?: {
		detail?: WebComponentDetail;
	}) => Bored;
	/** Proxy-wrapped helpers - undefined functions are intercepted for inside-out development */
	helpers: Record<string, Function>;
};
/** The function returned by `webComponent`, used to create subscribers and call the initialize function */
export type LoadedFunction = ReturnType<typeof webComponent>;
/** The function passed as parameter to `webComponent`, used to initialize the component and create the render function */
export type InitFunction<S> = (options: WebComponentInitParams<S>) => RenderFunction<S>;
/** The function used to render function and update it visually */
export type RenderFunction<S> = (renderOpts: WebComponentRenderParams<S>) => void;
export type AppState<S> = {
	app: S | undefined;
	internal: {
		customTags: string[];
		components: Map<string, LoadedFunction | null>;
		updates: {
			path: string[];
			value: object[];
			raf: number | undefined;
			subscribers: Map<string, ((s?: S) => void)[]>;
		};
	};
};
export type Letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z";
export type Refs = {
	[key: `${Letter}${string}`]: HTMLElement;
};
export type Slots = {
	[key: `${Letter}${string}`]: HTMLElement;
};
/**
 * Debug configuration options for granular control over debug features.
 */
export type DebugOptions = {
	/** Log errors to console with full context (default: true) */
	console?: boolean;
	/** Expose $state, $refs, $slots, $self, $error, $rerender to window (default: true) */
	globals?: boolean;
	/** Catch render errors and prevent cascade (default: true, always recommended) */
	errorBoundary?: boolean;
	/** Add data-boredom-error attribute to errored components (default: true) */
	visualIndicators?: boolean;
	/** Store errors in boreDOM.errors map (default: true) */
	errorHistory?: boolean;
	/** Log version on init (default: true) */
	versionLog?: boolean;
	/** Enable console API (define, operate) (default: true) */
	api?: boolean;
	/** Enable method-missing interception via helpers proxy (default: true) */
	methodMissing?: boolean;
	/** Auto-generate skeleton templates for undefined components (default: true) */
	templateInference?: boolean;
	/** Strict mode: throw instead of inferring (default: false) */
	strict?: boolean;
	/** Output format: "human" for formatted console, "llm" for JSON (default: "human") */
	outputFormat?: "human" | "llm";
	/** Enable LLM integration API (context, focus, copy) (default: true) */
	llm?: boolean;
};
/**
 * Configuration options for inflictBoreDOM.
 */
export type BoreDOMConfig = {
	/** Debug mode: true for full debug, false to disable, or granular DebugOptions */
	debug?: boolean | DebugOptions;
};
/**
 * Context exposed when a component render throws an error.
 * Available via $state, $refs, etc. globals and boreDOM.errors map.
 */
export type ErrorContext<S = any> = {
	/** Component tag name */
	component: string;
	/** The DOM element */
	element: HTMLElement;
	/** The original error */
	error: Error;
	/** Write proxy - MUTABLE, use this to fix state */
	state: S;
	/** Refs proxy */
	refs: Refs;
	/** Slots proxy */
	slots: Slots;
	/** When the error occurred */
	timestamp: number;
	/** Function to retry rendering after fixing */
	rerender: () => void;
	/** Cleaned stack trace */
	stack: string;
};
/**
 * Exported state snapshot returned by boreDOM.export().
 * Contains JSON-serializable component state for debugging.
 */
export type ExportedState = {
	/** Component tag name */
	component: string;
	/** JSON-serializable state snapshot, or error message if serialization failed */
	state: any;
	/** ISO timestamp of export */
	timestamp: string;
	/** Original error message (for errored components) */
	error: string;
};
/**
 * Context captured when an undefined function is called via the helpers proxy.
 * Available via $missingName, $missingArgs, etc. globals and boreDOM.missingFunctions map.
 */
export type MissingFunctionContext = {
	/** The function name that was called */
	name: string;
	/** Arguments passed to the function */
	args: any[];
	/** Component where the call occurred */
	component: string;
	/** Component DOM element */
	element: HTMLElement;
	/** When the call occurred */
	timestamp: number;
	/** Function to define the missing function and re-render */
	define: (implementation: Function) => void;
};
/**
 * Inferred template data generated for undefined custom elements.
 */
export type InferredTemplate = {
	/** The custom element tag name */
	tagName: string;
	/** Generated HTML template string */
	template: string;
	/** Props inferred from element attributes (kebab-case converted to camelCase) */
	props: Record<string, any>;
	/** Slot names inferred from child elements */
	slots: string[];
};
/**
 * Type node representing an inferred type.
 * Uses discriminated union for different type kinds.
 */
export type TypeNode = {
	kind: "primitive";
	value: "string" | "number" | "boolean" | "null" | "undefined";
} | {
	kind: "literal";
	value: string | number | boolean;
} | {
	kind: "array";
	elementType: TypeNode;
} | {
	kind: "object";
	properties: Record<string, TypeNode>;
} | {
	kind: "union";
	types: TypeNode[];
} | {
	kind: "function";
	params: ParamType[];
	returnType: TypeNode;
} | {
	kind: "date";
} | {
	kind: "unknown";
};
/**
 * Parameter type for function signatures.
 */
export type ParamType = {
	name: string;
	type: TypeNode;
	/** Whether the parameter is optional (defaults to false) */
	optional?: boolean;
};
/**
 * Tracked function type info.
 */
export type FunctionType = {
	params: ParamType[];
	returnType: TypeNode;
	callCount: number;
};
/**
 * Output structure for type inference.
 */
export type TypeDefinitions = {
	/** Generated TypeScript interface for app state */
	state: string;
	/** Inferred helper function signatures */
	helpers: Record<string, string>;
	/** Component prop types inferred from attributes */
	components: Record<string, string>;
	/** Event payload types */
	events: Record<string, string>;
	/** Raw type data for further processing */
	raw: {
		state: TypeNode;
		helpers: Record<string, FunctionType>;
		components: Record<string, TypeNode>;
		events: Record<string, TypeNode>;
	};
};
/**
 * Queries for the component tag name in the DOM. Throws error if not found.
 */
/**
 * Queries a component by CSS selector and returns it only if it is a
 * boreDOM component (Bored). Returns undefined when not found/mismatched.
 *
 * Example:
 * ```ts
 * const card = queryComponent('user-card');
 * if (card) card.setAttribute('data-visible', 'true');
 * ```
 */
export declare const queryComponent: (q: string) => Bored | undefined;
declare abstract class Bored extends HTMLElement {
	abstract renderCallback: (elem: Bored) => void;
}
/**
 * Registers a custom element with the given tag name.
 * Simpler alias for `component()` used by console API.
 *
 * @param tagName - The custom element tag name to register
 */
export declare const registerComponent: (tagName: string) => void;
/** Boolean-type debug features */
export type BooleanDebugFeature = Exclude<keyof DebugOptions, "outputFormat">;
/**
 * Check if a debug feature is enabled.
 * Respects both build-time __DEBUG__ flag and runtime config.
 *
 * @param feature - The debug feature to check ('console', 'globals', etc.)
 * @returns True if the feature is enabled
 *
 * @example
 * ```ts
 * if (isDebugEnabled('console')) {
 *   console.log('Debug logging enabled')
 * }
 * ```
 */
export declare function isDebugEnabled(feature: BooleanDebugFeature): boolean;
/**
 * Set debug configuration.
 * Can be called with boolean (enable/disable all) or granular options.
 *
 * @param config - Boolean to enable/disable all, or DebugOptions for granular control
 *
 * @example
 * ```ts
 * // Disable all debug features
 * setDebugConfig(false)
 *
 * // Granular control
 * setDebugConfig({
 *   console: true,
 *   globals: false,
 *   errorBoundary: true,
 * })
 * ```
 */
export declare function setDebugConfig(config: boolean | DebugOptions): void;
/**
 * Clear debug globals from window.
 */
export declare function clearGlobals(): void;
declare function exportState(tagName?: string): ExportedState | null;
export declare const VERSION = "0.25.25";
/**
 * Context for a running component, accessible via operate()
 */
export interface ComponentContext<S = any> {
	/** Mutable state proxy */
	state: S;
	/** Component refs */
	refs: Refs;
	/** Component slots */
	slots: Slots;
	/** DOM element */
	self: HTMLElement;
	/** Component detail */
	detail: WebComponentDetail;
	/** Force re-render */
	rerender: () => void;
}
/**
 * Exported component data structure
 */
export interface ExportedComponent {
	/** Component tag name */
	component: string;
	/** Current state snapshot (JSON-serializable) */
	state: any;
	/** Template HTML (if available) */
	template?: string;
	/** Timestamp of export */
	timestamp: string;
	/** Error message if component errored */
	error?: string;
}
declare function define<S>(tagName: string, template: string, logic: InitFunction<S> | ((appState: AppState<S>, detail?: any) => (c: any) => void)): boolean;
declare function operate<S = any>(selectorOrElement: string | HTMLElement, index?: number): ComponentContext<S> | undefined;
declare function exportComponent(selector: string): ExportedComponent | null;
declare function defineHelper(name: string, implementation: Function): void;
declare function clearHelper(name: string): void;
declare function clearMissingFunctions(): void;
declare function inferTemplate(tagName: string, element?: HTMLElement): InferredTemplate | null;
declare function inferTypes(): TypeDefinitions;
declare function typeOf(path: string): string;
declare function clearTypeTracking(): void;
export interface ValidationResult {
	valid: boolean;
	issues: ValidationIssue[];
}
export interface ValidationIssue {
	type: "syntax" | "reference" | "type" | "logic" | "warning";
	message: string;
	location?: string;
	suggestion?: string;
	severity: "error" | "warning";
}
export interface ApplyResult {
	success: boolean;
	error?: string;
	rollback: () => void;
	componentsAffected: string[];
	stateChanges: StateChange[];
}
export interface StateChange {
	path: string;
	before: any;
	after: any;
}
export interface BatchApplyResult {
	success: boolean;
	results: ApplyResult[];
	rollbackAll: () => void;
	error?: string;
	failedIndex?: number;
}
declare function validate(code: string): ValidationResult;
declare function apply(code: string): ApplyResult;
declare function applyBatch(codeBlocks: string[]): BatchApplyResult;
/**
 * Component information for LLM context.
 */
export interface LLMComponentInfo {
	/** Component tag name */
	tagName: string;
	/** HTML template string */
	template: string | null;
	/** Whether component has logic attached */
	hasLogic: boolean;
	/** Named refs in the component */
	refs: string[];
	/** Named slots in the component */
	slots: string[];
	/** Event handlers registered */
	events: string[];
	/** State paths this component accesses */
	stateAccess: string[];
	/** Whether component is in error state */
	hasError: boolean;
	/** Number of instances in DOM */
	instanceCount: number;
}
/**
 * Error information for LLM context.
 */
export interface LLMErrorInfo {
	/** Component tag name */
	component: string;
	/** Error message */
	error: string;
	/** Stack trace */
	stack: string;
	/** State at time of error */
	state: any;
	/** When error occurred */
	timestamp: number;
}
/**
 * Missing function information for LLM context.
 */
export interface LLMMissingFunctionInfo {
	/** Function name */
	name: string;
	/** Arguments passed */
	args: any[];
	/** Component where called */
	component: string;
	/** Inferred function signature */
	inferredSignature: string;
	/** Number of times called */
	callCount: number;
}
/**
 * Information about a missing function's calls.
 */
export interface LLMMissingCallInfo {
	/** All argument sets passed */
	args: any[][];
	/** Components that called this function */
	components: string[];
	/** Last call timestamp */
	lastCall: number;
}
/**
 * Detected patterns in the codebase.
 */
export interface LLMPatternInfo {
	/** Event naming convention */
	eventNaming: "kebab-case" | "camelCase" | "mixed" | "unknown";
	/** State structure style */
	stateStructure: "flat" | "nested" | "mixed" | "unknown";
	/** Component naming pattern */
	componentNaming: string;
}
/**
 * Attempt tracking for LLM workflow.
 */
export interface LLMAttemptInfo {
	/** Code that was attempted */
	code: string;
	/** Result of the attempt */
	result: "success" | "error";
	/** Error message if failed */
	error?: string;
	/** When attempt was made */
	timestamp: number;
}
/**
 * Example code for LLM context.
 */
export interface LLMExampleInfo {
	/** Description of what the example shows */
	description: string;
	/** The code */
	code: string;
}
/**
 * Complete session context for LLM consumption.
 */
export interface LLMContext {
	/** Framework identification */
	framework: {
		name: "boreDOM";
		version: string;
		capabilities: string[];
	};
	/** Application state info */
	state: {
		/** Inferred TypeScript interface */
		shape: string;
		/** All state paths */
		paths: string[];
		/** Sanitized sample data */
		sample: any;
	};
	/** Registered components */
	components: Record<string, LLMComponentInfo>;
	/** Current issues */
	issues: {
		errors: LLMErrorInfo[];
		missingFunctions: LLMMissingFunctionInfo[];
		missingComponents: string[];
	};
	/** Helper functions */
	helpers: {
		defined: Record<string, string>;
		missing: Record<string, LLMMissingCallInfo>;
	};
	/** Detected patterns */
	patterns: LLMPatternInfo;
}
/**
 * Focused context for current issue.
 */
export interface LLMFocusedContext {
	/** Current issue description */
	issue: {
		type: "error" | "missing_function" | "missing_component" | "none";
		description: string;
		component?: string;
		suggestion?: string;
	};
	/** Relevant component info */
	component?: LLMComponentInfo & {
		currentState: any;
	};
	/** Only state relevant to the issue */
	relevantState: any;
	/** Previous fix attempts */
	previousAttempts?: LLMAttemptInfo[];
	/** Similar working examples */
	examples?: LLMExampleInfo[];
}
declare function context$1(): LLMContext;
declare function focus$1(): LLMFocusedContext;
declare function copy(): string;
declare function recordAttempt(code: string, result: "success" | "error", error?: string): void;
declare function clearAttempts(): void;
/**
 * Global boreDOM object for debugging and programmatic access.
 * Exposed on window.boreDOM when running in browser.
 *
 * Note: We define getters explicitly instead of spreading debugAPI
 * because spread evaluates getters at spread-time, copying VALUES
 * instead of preserving the getters. This would cause lastError
 * and config to be frozen at module load time.
 */
export declare const boreDOM: {
	/** Map of all current errors by component name */
	readonly errors: Map<string, ErrorContext>;
	/** Most recent error context */
	readonly lastError: ErrorContext | null;
	/** Re-render a specific component or the last errored one */
	rerender: (tagName?: string) => void;
	/** Clear error state for a component */
	clearError: (tagName?: string) => void;
	/** Export state snapshot */
	export: typeof exportState;
	/** Current debug configuration (read-only) */
	readonly config: DebugOptions;
	/** Framework version */
	version: string;
	/** Define a new component at runtime */
	define: typeof define;
	/** Get live access to a component's internals */
	operate: typeof operate;
	/** Export component state and template */
	exportComponent: typeof exportComponent;
	/** Map of missing function calls by function name */
	readonly missingFunctions: Map<string, MissingFunctionContext[]>;
	/** Most recent missing function context */
	readonly lastMissing: MissingFunctionContext | null;
	/** Define a helper function available to all render functions */
	defineHelper: typeof defineHelper;
	/** Get all defined helpers */
	readonly helpers: Map<string, Function>;
	/** Clear a helper definition */
	clearHelper: typeof clearHelper;
	/** Clear all missing function records */
	clearMissingFunctions: typeof clearMissingFunctions;
	/** Map of inferred templates by tag name */
	readonly inferredTemplates: Map<string, InferredTemplate>;
	/** Manually infer template for a tag */
	inferTemplate: typeof inferTemplate;
	/** LLM context and output utilities */
	llm: {
		context: typeof context$1;
		focus: typeof focus$1;
		copy: typeof copy;
		readonly attempts: LLMAttemptInfo[];
		clearAttempts: typeof clearAttempts;
		_recordAttempt: typeof recordAttempt;
		inferTypes: typeof inferTypes;
		typeOf: typeof typeOf;
		_clearTypes: typeof clearTypeTracking;
		validate: typeof validate;
		apply: typeof apply;
		applyBatch: typeof applyBatch;
	};
};
/**
 * Queries all `<template>` elements that
 * have a `data-component` attribute defined and creates web components
 * with the tag name in that attribute.
 *
 * @param state An optional initial app state object. When provided this will
 * be proxified to allow for automatic updates of the dom whenever it
 * changes.
 *
 * @param componentsLogic An optional object that allows you to specify the
 * web components script code without having to place it in a separate file.
 * Its keys are the tag names and its value is the return type of
 * the `webComponent()` function. This overrides any external file
 * associated with the component.
 *
 * @param config Optional configuration for debug mode and other settings.
 * Set `{ debug: false }` for production-lite mode without a build step.
 *
 * @returns The app initial state.
 */
export declare function inflictBoreDOM<S>(state?: S, componentsLogic?: {
	[key: string]: ReturnType<typeof webComponent>;
}, config?: BoreDOMConfig): Promise<AppState<S>["app"]>;
/**
 * Creates a Web Component render updater
 *
 * @param initFunction Initialization function that returns the render function
 * @return A curried function to use as callback for component initialization
 */
export declare function webComponent<S>(initFunction: InitFunction<S | undefined>): (appState: AppState<S>, detail?: any) => (c: Bored) => void;

export {};
