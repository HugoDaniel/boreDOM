// Generated by dts-bundle-generator v9.5.1

export type WebComponentDetail = {
	index: number;
	name: string;
	data?: any;
};
export type WebComponentInitParams<S> = {
	detail: WebComponentDetail;
	state: S;
	refs: Refs;
	self: Bored;
	makeComponent: (tag: string, options?: {
		detail?: WebComponentDetail;
	}) => Bored;
	on: (eventName: string, eventHandler: (options: {
		state: S | undefined;
		e: CustomEvent["detail"];
		detail: WebComponentDetail;
	}) => void | Promise<void>) => void;
};
export type WebComponentRenderParams<S> = {
	detail: WebComponentDetail;
	state: S;
	refs: Refs;
	slots: Slots;
	self: Bored;
	makeComponent: (tag: string, options?: {
		detail?: WebComponentDetail;
	}) => Bored;
	/** Proxy-wrapped helpers - undefined functions are intercepted for inside-out development */
	helpers: Record<string, Function>;
};
/** The function returned by `webComponent`, used to create subscribers and call the initialize function */
export type LoadedFunction = ReturnType<typeof webComponent>;
/** The function passed as parameter to `webComponent`, used to initialize the component and create the render function */
export type InitFunction<S> = (options: WebComponentInitParams<S>) => RenderFunction<S>;
/** The function used to render function and update it visually */
export type RenderFunction<S> = (renderOpts: WebComponentRenderParams<S>) => void;
export type AppState<S> = {
	app: S | undefined;
	internal: {
		customTags: string[];
		components: Map<string, LoadedFunction | null>;
		updates: {
			path: string[];
			value: object[];
			raf: number | undefined;
			subscribers: Map<string, ((s?: S) => void)[]>;
		};
	};
};
export type Letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z";
export type Refs = {
	[key: `${Letter}${string}`]: HTMLElement;
};
export type Slots = {
	[key: `${Letter}${string}`]: HTMLElement;
};
/**
 * Debug configuration options for granular control over debug features.
 */
export type DebugOptions = {
	/** Log errors to console with full context (default: true) */
	console?: boolean;
	/** Expose $state, $refs, $slots, $self, $error, $rerender to window (default: true) */
	globals?: boolean;
	/** Catch render errors and prevent cascade (default: true, always recommended) */
	errorBoundary?: boolean;
	/** Add data-boredom-error attribute to errored components (default: true) */
	visualIndicators?: boolean;
	/** Store errors in boreDOM.errors map (default: true) */
	errorHistory?: boolean;
	/** Log version on init (default: true) */
	versionLog?: boolean;
	/** Enable console API (define, operate) (default: true) */
	api?: boolean;
	/** Enable method-missing interception via helpers proxy (default: true) */
	methodMissing?: boolean;
	/** Auto-generate skeleton templates for undefined components (default: true) */
	templateInference?: boolean;
	/** Strict mode: throw instead of inferring (default: false) */
	strict?: boolean;
	/** Output format: "human" for formatted console, "llm" for JSON (default: "human") */
	outputFormat?: "human" | "llm";
	/** Enable LLM integration API (context, focus, copy) (default: true) */
	llm?: boolean;
};
/**
 * Configuration options for inflictBoreDOM.
 */
export type BoreDOMConfig = {
	/** Debug mode: true for full debug, false to disable, or granular DebugOptions */
	debug?: boolean | DebugOptions;
	/** Single-file mode: skip dynamic imports and favor inline logic (default: false) */
	singleFile?: boolean;
	/** Mirror template data-* attributes onto component hosts (default: true) */
	mirrorAttributes?: boolean;
};
/**
 * Context exposed when a component render throws an error.
 * Available via $state, $refs, etc. globals and boreDOM.errors map.
 */
export type ErrorContext<S = any> = {
	/** Component tag name */
	component: string;
	/** The DOM element */
	element: HTMLElement;
	/** The original error */
	error: Error;
	/** Write proxy - MUTABLE, use this to fix state */
	state: S;
	/** Refs proxy */
	refs: Refs;
	/** Slots proxy */
	slots: Slots;
	/** When the error occurred */
	timestamp: number;
	/** Function to retry rendering after fixing */
	rerender: () => void;
	/** Cleaned stack trace */
	stack: string;
};
/**
 * Exported state snapshot returned by boreDOM.export().
 * Contains JSON-serializable component state for debugging.
 */
export type ExportedState = {
	/** Component tag name */
	component: string;
	/** JSON-serializable state snapshot, or error message if serialization failed */
	state: any;
	/** ISO timestamp of export */
	timestamp: string;
	/** Original error message (for errored components) */
	error: string;
};
export type SemanticAttributes = {
	id?: string;
	class?: string;
	type?: string;
	value?: string;
	checked?: boolean;
	disabled?: boolean;
	placeholder?: string;
	href?: string;
	src?: string;
	alt?: string;
	title?: string;
	role?: string;
	[key: `aria-${string}`]: string;
	[key: `data-${string}`]: string;
};
export type SemanticNode = {
	tagName: string;
	attributes?: SemanticAttributes;
	text?: string;
	children?: SemanticNode[];
};
export type JSONPatchOp = {
	op: "add";
	path: string;
	value: any;
} | {
	op: "remove";
	path: string;
} | {
	op: "replace";
	path: string;
	value: any;
} | {
	op: "test";
	path: string;
	value: any;
};
export type TransactionResult = {
	success: boolean;
	error?: string;
};
/**
 * Queries for the component tag name in the DOM. Throws error if not found.
 */
export declare const queryComponent: (q: string) => Bored | undefined;
declare abstract class Bored extends HTMLElement {
	abstract renderCallback: (elem: Bored) => void;
	[key: string]: any;
}
/**
 * Registers a custom element with the given tag name.
 * Simpler alias for `component()` used by console API.
 */
export declare const registerComponent: (tagName: string) => void;
/** Boolean-type debug features */
export type BooleanDebugFeature = Exclude<keyof DebugOptions, "outputFormat">;
/**
 * Check if a debug feature is enabled.
 * Respects both build-time __DEBUG__ flag and runtime config.
 *
 * @param feature - The debug feature to check ('console', 'globals', etc.)
 * @returns True if the feature is enabled
 *
 * @example
 * ```ts
 * if (isDebugEnabled('console')) {
 *   console.log('Debug logging enabled')
 * }
 * ```
 */
export declare function isDebugEnabled(feature: BooleanDebugFeature): boolean;
/**
 * Set debug configuration.
 * Can be called with boolean (enable/disable all) or granular options.
 *
 * @param config - Boolean to enable/disable all, or DebugOptions for granular control
 *
 * @example
 * ```ts
 * // Disable all debug features
 * setDebugConfig(false)
 *
 * // Granular control
 * setDebugConfig({
 *   console: true,
 *   globals: false,
 *   errorBoundary: true,
 * })
 * ```
 */
export declare function setDebugConfig(config: boolean | DebugOptions): void;
/**
 * Get current debug configuration (read-only copy).
 *
 * @returns A copy of the current debug configuration
 */
export declare function getDebugConfig(): DebugOptions;
/**
 * Clear debug globals from window.
 */
export declare function clearGlobals(): void;
declare function exportState(tagName?: string): ExportedState | null;
export declare const VERSION = "0.25.25";
export declare const html: (strings: TemplateStringsArray, ...values: Array<string | number>) => string;
export declare function component<S>(tagName: string, template: string, initFunction: InitFunction<S | undefined>): (appState: AppState<S>, detail?: any) => (c: Bored) => void;
/**
 * Global boreDOM object for debugging and programmatic access.
 * Exposed on window.boreDOM when running in browser.
 *
 * Note: We define getters explicitly instead of spreading debugAPI
 * because spread evaluates getters at spread-time, copying VALUES
 * instead of preserving the getters. This would cause lastError
 * and config to be frozen at module load time.
 */
export declare const boreDOM: {
	/** Map of all current errors by component name */
	readonly errors: Map<string, ErrorContext>;
	/** Most recent error context */
	readonly lastError: ErrorContext | null;
	/** Re-render a specific component or the last errored one */
	rerender: (tagName?: string) => void;
	/** Clear error state for a component */
	clearError: (tagName?: string) => void;
	/** Export state snapshot */
	export: typeof exportState;
	/** Current debug configuration (read-only) */
	readonly config: DebugOptions;
	/** @internal Set debug configuration (used by tests with multiple bundles) */
	_setDebugConfig: typeof setDebugConfig;
	/** Framework version */
	version: string;
	/** LLM context and output utilities */
	llm: {
		vision: (root?: Element) => SemanticNode | null;
		transact: (patch: JSONPatchOp[]) => TransactionResult;
		compact: () => {
			framework: {
				name: string;
				version: string;
			};
			state: {
				paths: string[];
				sample: Record<string, any>;
			};
			components: {
				tag: string;
				hasLogic: boolean;
			}[];
		} | null;
	};
	/** Create a template-backed component in single-file mode */
	component: typeof component;
	/** Template literal helper for HTML strings */
	html: (strings: TemplateStringsArray, ...values: Array<string | number>) => string;
};
/**
 * Queries all `<template>` elements that
 * have a `data-component` attribute defined and creates web components
 * with the tag name in that attribute.
 *
 * @param state An optional initial app state object. When provided this will
 * be proxified to allow for automatic updates of the dom whenever it
 * changes.
 *
 * @param componentsLogic An optional object that allows you to specify the
 * web components script code without having to place it in a separate file.
 * Its keys are the tag names and its value is the return type of
 * the `webComponent()` function. This overrides any external file
 * associated with the component.
 *
 * @param config Optional configuration for debug mode and other settings.
 * Set `{ debug: false }` for production-lite mode without a build step.
 *
 * @returns The app initial state.
 */
export declare function inflictBoreDOM<S>(state?: S, componentsLogic?: {
	[key: string]: ReturnType<typeof webComponent>;
}, config?: BoreDOMConfig): Promise<AppState<S>["app"]>;
/**
 * Creates a Web Component render updater
 *
 * @param initFunction Initialization function that returns the render function
 * @return A curried function to use as callback for component initialization
 */
export declare function webComponent<S>(initFunction: InitFunction<S | undefined>): (appState: AppState<S>, detail?: any) => (c: Bored) => void;

export {};
