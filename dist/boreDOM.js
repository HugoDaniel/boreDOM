#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// boreDOMCLI/generated_cli.js
var generated_cli_exports = {};
__export(generated_cli_exports, {
  BUILD_DIR: () => BUILD_DIR,
  build: () => build,
  buildRelativeServePath: () => buildRelativeServePath,
  copyBoreDOM: () => copyBoreDOM,
  getServePaths: () => getServePaths,
  normalizeServePath: () => normalizeServePath,
  options: () => options,
  processComponents: () => processComponents,
  setServePaths: () => setServePaths,
  updateIndex: () => updateIndex
});
module.exports = __toCommonJS(generated_cli_exports);
var import_fs_extra = __toESM(require("fs-extra"));
var import_mime_types = __toESM(require("mime-types"));
var import_path = __toESM(require("path"));
var glob = __toESM(require("glob"));
var cheerio = __toESM(require("cheerio"));
var import_commander = require("commander");
var import_http = __toESM(require("http"));
var import_finalhandler = __toESM(require("finalhandler"));
var import_js_beautify = __toESM(require("js-beautify"));
var import_chokidar = __toESM(require("chokidar"));
var import_serve_handler = __toESM(require("serve-handler"));
var boredom = `
Ly8gc3JjL2RvbS50cwp2YXIgZHluYW1pY0ltcG9ydFNjcmlwdHMgPSBhc3luYyAobmFtZXMpID0+IHsKICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpOwogIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHsKICAgIGNvbnN0IHNjcmlwdHMgPSBBcnJheS5mcm9tKHF1ZXJ5QWxsKCJzY3JpcHRbc3JjXSIpKTsKICAgIGNvbnN0IG1hdGNoaW5nU2NyaXB0ID0gc2NyaXB0cy5maW5kKChzY3JpcHQpID0+IHsKICAgICAgY29uc3Qgc3JjID0gc2NyaXB0LmdldEF0dHJpYnV0ZSgic3JjIikgPz8gIiI7CiAgICAgIGNvbnN0IGZpbGVuYW1lID0gc3JjLnNwbGl0KCIvIikucG9wKCkgPz8gIiI7CiAgICAgIHJldHVybiBmaWxlbmFtZSA9PT0gYCR7bmFtZXNbaV19LmpzYDsKICAgIH0pOwogICAgY29uc3Qgc2NyaXB0TG9jYXRpb24gPSBtYXRjaGluZ1NjcmlwdD8uZ2V0QXR0cmlidXRlKCJzcmMiKTsKICAgIGxldCBmID0gbnVsbDsKICAgIGlmIChzY3JpcHRMb2NhdGlvbikgewogICAgICB0cnkgewogICAgICAgIGNvbnN0IG1vZHVsZVVybCA9IG5ldyBVUkwoc2NyaXB0TG9jYXRpb24sIGRvY3VtZW50LmJhc2VVUkkpLmhyZWY7CiAgICAgICAgY29uc3QgZXhwb3J0cyA9IGF3YWl0IGltcG9ydChtb2R1bGVVcmwpOwogICAgICAgIGZvciAoY29uc3QgZXhwb3J0ZWQgb2YgT2JqZWN0LmtleXMoZXhwb3J0cykpIHsKICAgICAgICAgIGYgPSBleHBvcnRzW2V4cG9ydGVkXTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICByZXN1bHQuc2V0KG5hbWVzW2ldLCBmKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuYWJsZSB0byBpbXBvcnQgIiR7c2NyaXB0TG9jYXRpb259ImAsIGUpOwogICAgICB9CiAgICB9CiAgfQogIHJldHVybiByZXN1bHQ7Cn07CnZhciByZWdpc3RlclRlbXBsYXRlcyA9IGFzeW5jICh3ZWJDb21wb25lbnRGYWN0b3J5LCBvcHRpb25zKSA9PiB7CiAgY29uc3QgaXNMTE1CdWlsZCA9IHR5cGVvZiBfX0xMTV9fICE9PSAidW5kZWZpbmVkIiAmJiBfX0xMTV9fOwogIGNvbnN0IHNob3VsZE1pcnJvckF0dHJpYnV0ZXMgPSBvcHRpb25zPy5taXJyb3JBdHRyaWJ1dGVzID8/ICFpc0xMTUJ1aWxkOwogIGNvbnN0IG5hbWVzID0gW107CiAgY29uc3QgaW5saW5lTG9naWMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpOwogIGNvbnN0IHRlbXBsYXRlcyA9IEFycmF5LmZyb20ocXVlcnlBbGwoInRlbXBsYXRlW2RhdGEtY29tcG9uZW50XSIpKS5maWx0ZXIoKGVsZW0pID0+IGVsZW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCk7CiAgZm9yIChjb25zdCB0IG9mIHRlbXBsYXRlcykgewogICAgbGV0IG5hbWUgPSAiIjsKICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTsKICAgIGZvciAoY29uc3QgYXR0cmlidXRlIGluIHQuZGF0YXNldCkgewogICAgICBpZiAoYXR0cmlidXRlID09PSAiY29tcG9uZW50IikgewogICAgICAgIG5hbWUgPSB0LmRhdGFzZXRbYXR0cmlidXRlXSA/PyAiIjsKICAgICAgfSBlbHNlIGlmIChzaG91bGRNaXJyb3JBdHRyaWJ1dGVzKSB7CiAgICAgICAgYXR0cmlidXRlcy5wdXNoKFsKICAgICAgICAgIGRlY2FtZWxpemUoYXR0cmlidXRlKSwKICAgICAgICAgIHQuZGF0YXNldFthdHRyaWJ1dGVdID8/ICIiCiAgICAgICAgXSk7CiAgICAgIH0KICAgIH0KICAgIGlmICghbmFtZSkgewogICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIDx0ZW1wbGF0ZT4gZm91bmQ6IG1pc3NpbmcgZGF0YS1jb21wb25lbnRgLCB0KTsKICAgICAgY29udGludWU7CiAgICB9CiAgICBpZiAoaXNUZW1wbGF0ZSh0KSkgewogICAgICBjb25zdCBzY3JpcHQgPSB0LmNvbnRlbnQucXVlcnlTZWxlY3Rvcigic2NyaXB0Iik7CiAgICAgIGlmIChzY3JpcHQpIHsKICAgICAgICBjb25zdCBjb2RlID0gc2NyaXB0LnRleHRDb250ZW50OwogICAgICAgIGlmIChjb2RlICYmIGNvZGUudHJpbSgpLmxlbmd0aCA+IDApIHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY29kZV0sIHsgdHlwZTogInRleHQvamF2YXNjcmlwdCIgfSk7CiAgICAgICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7CiAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IGF3YWl0IGltcG9ydCh1cmwpOwogICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7CiAgICAgICAgICAgIHNjcmlwdC5yZW1vdmUoKTsKICAgICAgICAgICAgbGV0IHJhd0xvZ2ljID0gbnVsbDsKICAgICAgICAgICAgaWYgKG1vZHVsZS5kZWZhdWx0KSB7CiAgICAgICAgICAgICAgcmF3TG9naWMgPSBtb2R1bGUuZGVmYXVsdDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobW9kdWxlKTsKICAgICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICByYXdMb2dpYyA9IG1vZHVsZVtrZXlzWzBdXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHJhd0xvZ2ljKSB7CiAgICAgICAgICAgICAgY29uc3QgbG9naWMgPSB3ZWJDb21wb25lbnRGYWN0b3J5ID8gd2ViQ29tcG9uZW50RmFjdG9yeShyYXdMb2dpYykgOiByYXdMb2dpYzsKICAgICAgICAgICAgICBpbmxpbmVMb2dpYy5zZXQobmFtZSwgbG9naWMpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBjb21wb25lbnQobmFtZSwgeyBhdHRyaWJ1dGVzIH0pOwogICAgbmFtZXMucHVzaChuYW1lKTsKICB9CiAgcmV0dXJuIHsgbmFtZXMsIGlubGluZUxvZ2ljIH07Cn07CnZhciBjcmVhdGVDb21wb25lbnQgPSAobmFtZSwgdXBkYXRlKSA9PiB7CiAgY29uc3QgZWxlbWVudCA9IGNyZWF0ZShuYW1lKTsKICBpZiAoIWlzQm9yZWQoZWxlbWVudCkpIHsKICAgIGNvbnN0IGVycm9yID0gYFRoZSB0YWcgbmFtZSAiJHtuYW1lfSIgaXMgbm90IGEgQm9yZURPTSAgY29tcG9uZW50LgogICAgICAKImNyZWF0ZUNvbXBvbmVudCIgb25seSBhY2NlcHRzIHRhZy1uYW1lcyB3aXRoIG1hdGNoaW5nIDx0ZW1wbGF0ZT4gdGFncyB0aGF0IGhhdmUgYSBkYXRhLWNvbXBvbmVudCBhdHRyaWJ1dGUgaW4gdGhlbS5gOwogICAgY29uc29sZS5lcnJvcihlcnJvcik7CiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpOwogIH0KICBpZiAodXBkYXRlKSB7CiAgICBlbGVtZW50LnJlbmRlckNhbGxiYWNrID0gdXBkYXRlOwogIH0KICByZXR1cm4gZWxlbWVudDsKfTsKdmFyIHF1ZXJ5Q29tcG9uZW50ID0gKHEpID0+IHsKICBjb25zdCBlbGVtID0gcXVlcnkocSk7CiAgaWYgKGVsZW0gPT09IG51bGwgfHwgIWlzQm9yZWQoZWxlbSkpIHsKICAgIHJldHVybiB2b2lkIDA7CiAgfQogIHJldHVybiBlbGVtOwp9Owp2YXIgcXVlcnkgPSAocXVlcnkyKSA9PiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5Mik7CnZhciBxdWVyeUFsbCA9IChxdWVyeTIpID0+IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkyKTsKdmFyIGNyZWF0ZSA9ICh0YWdOYW1lLCBjaGlsZHJlbikgPT4gewogIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpOwogIGlmIChjaGlsZHJlbiAmJiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPiAwKSB7CiAgICBjaGlsZHJlbi5tYXAoKGMpID0+IGUuYXBwZW5kQ2hpbGQoYykpOwogIH0KICByZXR1cm4gZTsKfTsKdmFyIGRpc3BhdGNoID0gKG5hbWUsIGRldGFpbCkgPT4gewogIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAibG9hZGluZyIpIHsKICAgIGFkZEV2ZW50TGlzdGVuZXIoCiAgICAgICJET01Db250ZW50TG9hZGVkIiwKICAgICAgKCkgPT4gZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQobmFtZSwgeyBkZXRhaWwgfSkpCiAgICApOwogIH0gZWxzZSB7CiAgICBkaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChuYW1lLCB7IGRldGFpbCB9KSk7CiAgfQp9Owp2YXIgaXNUZW1wbGF0ZSA9IChlKSA9PiBlIGluc3RhbmNlb2YgSFRNTFRlbXBsYXRlRWxlbWVudDsKdmFyIGlzT2JqZWN0ID0gKHQpID0+IHR5cGVvZiB0ID09PSAib2JqZWN0IjsKdmFyIGlzRnVuY3Rpb24gPSAodCkgPT4gdHlwZW9mIHQgPT09ICJmdW5jdGlvbiI7CnZhciBpc0JvcmVkID0gKHQpID0+IGlzT2JqZWN0KHQpICYmICJpc0JvcmVkIiBpbiB0ICYmIEJvb2xlYW4odC5pc0JvcmVkKTsKdmFyIGRlY2FtZWxpemUgPSAoc3RyKSA9PiB7CiAgaWYgKHN0ciA9PT0gIiIgfHwgIXN0ci5zcGxpdCgiIikuc29tZSgoY2hhcikgPT4gY2hhciAhPT0gY2hhci50b0xvd2VyQ2FzZSgpKSkgewogICAgcmV0dXJuIHN0cjsKICB9CiAgbGV0IHJlc3VsdCA9ICIiOwogIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7CiAgICBjb25zdCBjaGFyID0gc3RyW2ldOwogICAgaWYgKGNoYXIgPT09IGNoYXIudG9VcHBlckNhc2UoKSAmJiBpICE9PSAwKSB7CiAgICAgIHJlc3VsdCArPSAiLSI7CiAgICB9CiAgICByZXN1bHQgKz0gY2hhci50b0xvd2VyQ2FzZSgpOwogIH0KICByZXR1cm4gcmVzdWx0Owp9Owp2YXIgaXNTdGFydHNXaXRoT24gPSAocykgPT4gcy5zdGFydHNXaXRoKCJvbiIpOwp2YXIgaXNTdGFydHNXaXRoUXVlcmllZE9uID0gKHMpID0+IHMuc3RhcnRzV2l0aCgicXVlcmllZE9uIik7CnZhciBnZXRFdmVudE5hbWUgPSAocykgPT4gewogIGlmIChpc1N0YXJ0c1dpdGhPbihzKSkgewogICAgcmV0dXJuIHMuc2xpY2UoMikudG9Mb3dlckNhc2UoKTsKICB9CiAgcmV0dXJuIHMuc2xpY2UoOSkudG9Mb3dlckNhc2UoKTsKfTsKdmFyIEJvcmVkID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7Cn07CnZhciBjb21wb25lbnQgPSAodGFnLCBwcm9wcyA9IHt9KSA9PiB7CiAgY29uc3QgaXNMTE1CdWlsZCA9IHR5cGVvZiBfX0xMTV9fICE9PSAidW5kZWZpbmVkIiAmJiBfX0xMTV9fOwogIGlmIChjdXN0b21FbGVtZW50cy5nZXQodGFnKSkgcmV0dXJuOwogIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgKICAgIHRhZywKICAgIGNsYXNzIGV4dGVuZHMgQm9yZWQgewogICAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsKICAgICAgICBpZiAodHlwZW9mIHByb3BzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9PT0gIm9iamVjdCIpIHsKICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhwcm9wcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spOwogICAgICAgIH0KICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgc3VwZXIoKTsKICAgICAgfQogICAgICBpc0JvcmVkID0gdHJ1ZTsKICAgICAgdHJhdmVyc2UoZiwgeyB0cmF2ZXJzZVNoYWRvd1Jvb3QsIHF1ZXJ5OiBxdWVyeTIgfSA9IHt9KSB7CiAgICAgICAgQXJyYXkuZnJvbSgKICAgICAgICAgIHRyYXZlcnNlU2hhZG93Um9vdCA/IHRoaXMuc2hhZG93Um9vdD8ucXVlcnlTZWxlY3RvckFsbChxdWVyeTIgPz8gIioiKSA/PyBbXSA6IFtdCiAgICAgICAgKS5jb25jYXQoQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkyID8/ICIqIikpKS5maWx0ZXIoKG4pID0+IG4gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkuZm9yRWFjaChmKTsKICAgICAgfQogICAgICAjcGFyc2VDdXN0b21FdmVudE5hbWVzKHN0cikgewogICAgICAgIHJldHVybiBzdHIuc3BsaXQoIiciKS5maWx0ZXIoCiAgICAgICAgICAocykgPT4gcy5sZW5ndGggPiAyICYmICEocy5pbmNsdWRlcygiKCIpIHx8IHMuaW5jbHVkZXMoIiwiKSB8fCBzLmluY2x1ZGVzKCIpIikpCiAgICAgICAgKTsKICAgICAgfQogICAgICAjcGFyc2VEaXJlY3RFdmVudE5hbWVzKHN0cikgewogICAgICAgIHJldHVybiBzdHIuc3BsaXQoL1tccyxdKy9nKS5tYXAoKHMpID0+IHMudHJpbSgpKS5maWx0ZXIoQm9vbGVhbik7CiAgICAgIH0KICAgICAgI3BhcnNlRXZlbnROYW1lcyhzdHIpIHsKICAgICAgICBjb25zdCB0cmltbWVkID0gc3RyLnRyaW0oKTsKICAgICAgICBpZiAodHJpbW1lZC5sZW5ndGggPT09IDApIHJldHVybiBbXTsKICAgICAgICBpZiAodHJpbW1lZC5pbmNsdWRlcygiZGlzcGF0Y2goIikgfHwgdHJpbW1lZC5pbmNsdWRlcygiJyIpKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy4jcGFyc2VDdXN0b21FdmVudE5hbWVzKHN0cik7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzLiNwYXJzZURpcmVjdEV2ZW50TmFtZXMoc3RyKTsKICAgICAgfQogICAgICAjY3JlYXRlRGlzcGF0Y2hlcnMoKSB7CiAgICAgICAgbGV0IGhvc3Q7CiAgICAgICAgdGhpcy50cmF2ZXJzZSgobm9kZSkgPT4gewogICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgewogICAgICAgICAgICBjb25zdCBpc1dlYkNvbXBvbmVudCA9IGN1c3RvbUVsZW1lbnRzLmdldCgKICAgICAgICAgICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKQogICAgICAgICAgICApOwogICAgICAgICAgICBpZiAoaXNXZWJDb21wb25lbnQpIGhvc3QgPSBub2RlOwogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tpXTsKICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLm5hbWU7CiAgICAgICAgICAgICAgY29uc3QgYWRkRGlzcGF0Y2hlcnMgPSAoZXZlbnROYW1lLCBjdXN0b21FdmVudE5hbWVzKSA9PiB7CiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tRXZlbnROYW1lcy5sZW5ndGggPT09IDApIHJldHVybjsKICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50TmFtZXMuZm9yRWFjaCgoY3VzdG9tRXZlbnROYW1lKSA9PiB7CiAgICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcigKICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUsCiAgICAgICAgICAgICAgICAgICAgKGUpID0+IGRpc3BhdGNoKGN1c3RvbUV2ZW50TmFtZSwgewogICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGUsCiAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVyOiBub2RlLAogICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLAogICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMucGFyZW50RWxlbWVudCA/IEFycmF5LmZyb20odGhpcy5wYXJlbnRFbGVtZW50LmNoaWxkcmVuKS5pbmRleE9mKAogICAgICAgICAgICAgICAgICAgICAgICB0aGlzCiAgICAgICAgICAgICAgICAgICAgICApIDogLTEKICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZS5zdGFydHNXaXRoKCJvbi0iKSkgewogICAgICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gYXR0cmlidXRlTmFtZS5zbGljZSgzKTsKICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZXMgPSB0aGlzLiNwYXJzZUV2ZW50TmFtZXMoYXR0cmlidXRlLnZhbHVlKTsKICAgICAgICAgICAgICAgIGFkZERpc3BhdGNoZXJzKGV2ZW50TmFtZSwgZXZlbnROYW1lcyk7CiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gImRhdGEtZGlzcGF0Y2giIHx8IGF0dHJpYnV0ZU5hbWUuc3RhcnRzV2l0aCgiZGF0YS1kaXNwYXRjaC0iKSkgewogICAgICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gYXR0cmlidXRlTmFtZSA9PT0gImRhdGEtZGlzcGF0Y2giID8gImNsaWNrIiA6IGF0dHJpYnV0ZU5hbWUuc2xpY2UoImRhdGEtZGlzcGF0Y2gtIi5sZW5ndGgpOwogICAgICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lcyA9IHRoaXMuI3BhcnNlRXZlbnROYW1lcyhhdHRyaWJ1dGUudmFsdWUpOwogICAgICAgICAgICAgICAgYWRkRGlzcGF0Y2hlcnMoZXZlbnROYW1lLCBldmVudE5hbWVzKTsKICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpOwogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICghaXNMTE1CdWlsZCAmJiBpc1N0YXJ0c1dpdGhPbihhdHRyaWJ1dGUubmFtZSkpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZXMgPSB0aGlzLiNwYXJzZUN1c3RvbUV2ZW50TmFtZXMoYXR0cmlidXRlLnZhbHVlKTsKICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWVzLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgICAgICAgYWRkRGlzcGF0Y2hlcnMoZ2V0RXZlbnROYW1lKGF0dHJpYnV0ZS5uYW1lKSwgZXZlbnROYW1lcyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgKICAgICAgICAgICAgICAgICAgYGRhdGEtJHthdHRyaWJ1dGVOYW1lfS1kaXNwYXRjaGVzYCwKICAgICAgICAgICAgICAgICAgZXZlbnROYW1lcy5qb2luKCkKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCB7IHRyYXZlcnNlU2hhZG93Um9vdDogdHJ1ZSB9KTsKICAgICAgfQogICAgICBpc0luaXRpYWxpemVkID0gZmFsc2U7CiAgICAgICNpbml0KCkgewogICAgICAgIGxldCB0ZW1wbGF0ZSA9IHF1ZXJ5KGBbZGF0YS1jb21wb25lbnQ9IiR7dGFnfSJdYCkgPz8gY3JlYXRlKCJ0ZW1wbGF0ZSIpOwogICAgICAgIGNvbnN0IGlzVGVtcGxhdGVTaGFkb3dSb290ID0gaXNMTE1CdWlsZCA/IG51bGwgOiB0ZW1wbGF0ZS5nZXRBdHRyaWJ1dGUoInNoYWRvd3Jvb3Rtb2RlIik7CiAgICAgICAgY29uc3QgaXNTaGFkb3dSb290TmVlZGVkID0gIWlzTExNQnVpbGQgJiYgKHByb3BzLnN0eWxlIHx8IHByb3BzLnNoYWRvdyB8fCBpc1RlbXBsYXRlU2hhZG93Um9vdCk7CiAgICAgICAgaWYgKGlzU2hhZG93Um9vdE5lZWRlZCkgewogICAgICAgICAgY29uc3Qgc2hhZG93Um9vdE1vZGUgPSBwcm9wcy5zaGFkb3dyb290bW9kZSA/PyBpc1RlbXBsYXRlU2hhZG93Um9vdCA/PyAib3BlbiI7CiAgICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBzaGFkb3dSb290TW9kZSB9KTsKICAgICAgICAgIGlmIChwcm9wcy5zdHlsZSkgewogICAgICAgICAgICBjb25zdCBzdHlsZSA9IGNyZWF0ZSgic3R5bGUiKTsKICAgICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBwcm9wcy5zdHlsZTsKICAgICAgICAgICAgc2hhZG93Um9vdC5hcHBlbmRDaGlsZChzdHlsZSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocHJvcHMuc2hhZG93KSB7CiAgICAgICAgICAgIGNvbnN0IHRtcCA9IGNyZWF0ZSgidGVtcGxhdGUiKTsKICAgICAgICAgICAgdG1wLmlubmVySFRNTCA9IHByb3BzLnNoYWRvdzsKICAgICAgICAgICAgc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0bXAuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpOwogICAgICAgICAgfSBlbHNlIGlmIChpc1RlbXBsYXRlU2hhZG93Um9vdCkgewogICAgICAgICAgICBzaGFkb3dSb290LmFwcGVuZENoaWxkKHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHRlbXBsYXRlICYmICFpc1RlbXBsYXRlU2hhZG93Um9vdCkgewogICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7CiAgICAgICAgfQogICAgICAgIGlmIChwcm9wcy5vblNsb3RDaGFuZ2UpIHsKICAgICAgICAgIHRoaXMudHJhdmVyc2UoKGVsZW0pID0+IHsKICAgICAgICAgICAgaWYgKCEoZWxlbSBpbnN0YW5jZW9mIEhUTUxTbG90RWxlbWVudCkpIHJldHVybjsKICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCJzbG90Y2hhbmdlIiwgKGUpID0+IHByb3BzLm9uU2xvdENoYW5nZT8uKGUpKTsKICAgICAgICAgIH0sIHsgdHJhdmVyc2VTaGFkb3dSb290OiB0cnVlIH0pOwogICAgICAgIH0KICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wcy5vbkNsaWNrKSkgewogICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCJjbGljayIsIHByb3BzLm9uQ2xpY2spOwogICAgICAgIH0KICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wcykpIHsKICAgICAgICAgIGlmIChpc1N0YXJ0c1dpdGhPbihrZXkpKSB7CiAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIGNvbnRpbnVlOwogICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZ2V0RXZlbnROYW1lKGtleSksIHZhbHVlKTsKICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdGFydHNXaXRoUXVlcmllZE9uKGtleSkpIHsKICAgICAgICAgICAgaWYgKGlzTExNQnVpbGQpIGNvbnRpbnVlOwogICAgICAgICAgICBjb25zdCBxdWVyaWVzID0gdmFsdWU7CiAgICAgICAgICAgIGlmICghaXNPYmplY3QocXVlcmllcykpIGNvbnRpbnVlOwogICAgICAgICAgICBjb25zdCBldmVudE5hbWUgPSBnZXRFdmVudE5hbWUoa2V5KTsKICAgICAgICAgICAgZm9yIChjb25zdCBbcXVlcnkyLCBoYW5kbGVyXSBvZiBPYmplY3QuZW50cmllcyhxdWVyaWVzKSkgewogICAgICAgICAgICAgIHRoaXMudHJhdmVyc2UoKG5vZGUpID0+IHsKICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpOwogICAgICAgICAgICAgIH0sIHsgdHJhdmVyc2VTaGFkb3dSb290OiB0cnVlLCBxdWVyeTogcXVlcnkyIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChwcm9wcy5hdHRyaWJ1dGVzICYmIEFycmF5LmlzQXJyYXkocHJvcHMuYXR0cmlidXRlcykpIHsKICAgICAgICAgIHByb3BzLmF0dHJpYnV0ZXMubWFwKAogICAgICAgICAgICAoW2F0dHIsIHZhbHVlXSkgPT4gdGhpcy5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICB0aGlzLiNjcmVhdGVEaXNwYXRjaGVycygpOwogICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7CiAgICAgIH0KICAgICAgcmVuZGVyQ2FsbGJhY2sgPSAoXykgPT4gewogICAgICB9OwogICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHsKICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgdGhpcy4jaW5pdCgpOwogICAgICAgIHRoaXMucmVuZGVyQ2FsbGJhY2sodGhpcyk7CiAgICAgICAgcHJvcHMuY29ubmVjdGVkQ2FsbGJhY2s/Lih0aGlzKTsKICAgICAgfQogICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHsKICAgICAgICBwcm9wcy5kaXNjb25uZWN0ZWRDYWxsYmFjaz8uKHRoaXMpOwogICAgICB9CiAgICAgIGFkb3B0ZWRDYWxsYmFjaygpIHsKICAgICAgICBwcm9wcy5hZG9wdGVkQ2FsbGJhY2s/Lih0aGlzKTsKICAgICAgfQogICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7CiAgICAgICAgaWYgKCFwcm9wcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spIHJldHVybjsKICAgICAgICBwcm9wcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tbbmFtZV0oewogICAgICAgICAgZWxlbWVudDogdGhpcywKICAgICAgICAgIG5hbWUsCiAgICAgICAgICBvbGRWYWx1ZSwKICAgICAgICAgIG5ld1ZhbHVlCiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICApOwp9Owp2YXIgcmVnaXN0ZXJDb21wb25lbnQgPSAodGFnTmFtZSkgPT4gewogIGNvbXBvbmVudCh0YWdOYW1lLCB7fSk7Cn07CgovLyBzcmMvdXRpbHMvYWNjZXNzLnRzCmZ1bmN0aW9uIGFjY2VzcyhwYXRoLCBvYmopIHsKICBsZXQgcmVzdWx0ID0gb2JqOwogIGlmIChvYmogPT09IG51bGwpIHJldHVybiByZXN1bHQ7CiAgcGF0aC5mb3JFYWNoKChhdHRyaWJ1dGUpID0+IHsKICAgIHJlc3VsdCA9IHJlc3VsdFthdHRyaWJ1dGVdOwogIH0pOwogIHJldHVybiByZXN1bHQ7Cn0KCi8vIHNyYy91dGlscy9mbGF0dGVuLnRzCmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBpZ25vcmUgPSBbXSkgewogIGNvbnN0IHN0YWNrID0gW3sKICAgIHBhdGg6IFtdLAogICAgb2JqCiAgfV07CiAgY29uc3QgcmVzdWx0ID0gW107CiAgY29uc3QgdmlzaXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpOwogIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7CiAgICBjb25zdCB7IHBhdGgsIG9iajogb2JqMiB9ID0gc3RhY2sucG9wKCk7CiAgICBpZiAodmlzaXRlZC5oYXMob2JqMikpIGNvbnRpbnVlOwogICAgdmlzaXRlZC5hZGQob2JqMik7CiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmoyKSB7CiAgICAgIGlmIChpZ25vcmUuaW5jbHVkZXMoa2V5KSkgY29udGludWU7CiAgICAgIGNvbnN0IHZhbHVlID0gb2JqMltrZXldOwogICAgICBjb25zdCBuZXdQYXRoID0gcGF0aC5jb25jYXQoa2V5KTsKICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gIm9iamVjdCIgJiYgdmFsdWUgIT09IG51bGwgJiYgIXZpc2l0ZWQuaGFzKHZhbHVlKSkgewogICAgICAgIHN0YWNrLnB1c2goewogICAgICAgICAgcGF0aDogbmV3UGF0aCwKICAgICAgICAgIG9iajogdmFsdWUKICAgICAgICB9KTsKICAgICAgfQogICAgICByZXN1bHQucHVzaCh7IHBhdGg6IG5ld1BhdGgsIHZhbHVlIH0pOwogICAgfQogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovLyBzcmMvdXRpbHMvaXNQb2pvLnRzCmZ1bmN0aW9uIGlzUE9KTyhhcmcpIHsKICBpZiAoYXJnID09IG51bGwgfHwgdHlwZW9mIGFyZyAhPT0gIm9iamVjdCIpIHsKICAgIHJldHVybiBmYWxzZTsKICB9CiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXJnKTsKICBpZiAocHJvdG8gPT0gbnVsbCkgewogICAgcmV0dXJuIHRydWU7CiAgfQogIHJldHVybiBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZTsKfQoKLy8gc3JjL2JvcmUudHMKdmFyIGV4dHJhY3REZXRhaWxEYXRhID0gKGVsZW1lbnQpID0+IHsKICBjb25zdCBkYXRhID0ge307CiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZWxlbWVudC5kYXRhc2V0KSkgewogICAgaWYgKGtleS5zdGFydHNXaXRoKCJwcm9wIikpIGNvbnRpbnVlOwogICAgaWYgKHZhbHVlID09PSB2b2lkIDApIGNvbnRpbnVlOwogICAgZGF0YVtrZXldID0gdmFsdWU7CiAgfQogIHJldHVybiBkYXRhOwp9OwpmdW5jdGlvbiBjcmVhdGVFdmVudHNIYW5kbGVyKGMsIGFwcCwgZGV0YWlsKSB7CiAgcmV0dXJuIChldmVudE5hbWUsIGhhbmRsZXIpID0+IHsKICAgIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCAoZXZlbnQpID0+IHsKICAgICAgbGV0IHRhcmdldCA9IGV2ZW50Py5kZXRhaWw/LmV2ZW50LmN1cnJlbnRUYXJnZXQ7CiAgICAgIGxldCBlbWl0ZXJFbGVtID0gdm9pZCAwOwogICAgICB3aGlsZSAodGFyZ2V0KSB7CiAgICAgICAgaWYgKHRhcmdldCA9PT0gYykgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgY29uc3QgbWF5YmVQcm9taXNlID0gaGFuZGxlcih7CiAgICAgICAgICAgICAgc3RhdGU6IGFwcCwKICAgICAgICAgICAgICBlOiBldmVudC5kZXRhaWwsCiAgICAgICAgICAgICAgZGV0YWlsCiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobWF5YmVQcm9taXNlKS5jYXRjaCgoZXJyb3IpID0+IHsKICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKAogICAgICAgICAgICAgICAgYEVycm9yIGluIGFzeW5jIGhhbmRsZXIgZm9yICIke2V2ZW50TmFtZX0iIGV2ZW50YCwKICAgICAgICAgICAgICAgIGVycm9yCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyIGZvciAiJHtldmVudE5hbWV9IiBldmVudGAsIGVycm9yKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7CiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGFyZ2V0ID0gdm9pZCAwOwogICAgICAgIH0KICAgICAgfQogICAgfSk7CiAgfTsKfQpmdW5jdGlvbiBjcmVhdGVSZWZzQWNjZXNzb3IoYykgewogIHJldHVybiBuZXcgUHJveHkoe30sIHsKICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7CiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKAogICAgICAgIGBSZWYgIiR7U3RyaW5nKHByb3ApfSIgbm90IGZvdW5kIGluIDwke2MudGFnTmFtZX0+YAogICAgICApOwogICAgICBpZiAodHlwZW9mIHByb3AgPT09ICJzdHJpbmciKSB7CiAgICAgICAgY29uc3Qgbm9kZUxpc3QgPSBjLnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXJlZj0iJHtwcm9wfSJdYCk7CiAgICAgICAgaWYgKCFub2RlTGlzdCkgdGhyb3cgZXJyb3I7CiAgICAgICAgY29uc3QgcmVmcyA9IEFycmF5LmZyb20obm9kZUxpc3QpLmZpbHRlcigKICAgICAgICAgIChyZWYpID0+IHJlZiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50CiAgICAgICAgKTsKICAgICAgICBpZiAocmVmcy5sZW5ndGggPT09IDApIHRocm93IGVycm9yOwogICAgICAgIGlmIChyZWZzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHJlZnNbMF07CiAgICAgICAgcmV0dXJuIHJlZnM7CiAgICAgIH0KICAgIH0KICB9KTsKfQpmdW5jdGlvbiBjcmVhdGVTbG90c0FjY2Vzc29yKGMpIHsKICByZXR1cm4gbmV3IFByb3h5KHt9LCB7CiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNpZXZlcikgewogICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcigKICAgICAgICBgU2xvdCAiJHtTdHJpbmcocHJvcCl9IiBub3QgZm91bmQgaW4gPCR7Yy50YWdOYW1lfT5gCiAgICAgICk7CiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gInN0cmluZyIpIHsKICAgICAgICBjb25zdCBub2RlTGlzdCA9IGMucXVlcnlTZWxlY3RvckFsbChgc2xvdFtuYW1lPSIke3Byb3B9Il1gKTsKICAgICAgICBpZiAoIW5vZGVMaXN0KSB0aHJvdyBlcnJvcjsKICAgICAgICBjb25zdCByZWZzID0gQXJyYXkuZnJvbShub2RlTGlzdCkuZmlsdGVyKAogICAgICAgICAgKHJlZikgPT4gcmVmIGluc3RhbmNlb2YgSFRNTFNsb3RFbGVtZW50CiAgICAgICAgKTsKICAgICAgICBpZiAocmVmcy5sZW5ndGggPT09IDApIHRocm93IGVycm9yOwogICAgICAgIGlmIChyZWZzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHJlZnNbMF07CiAgICAgICAgcmV0dXJuIHJlZnM7CiAgICAgIH0KICAgIH0sCiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkgewogICAgICBpZiAodHlwZW9mIHByb3AgIT09ICJzdHJpbmciKSByZXR1cm4gZmFsc2U7CiAgICAgIGxldCBlbGVtID0gdmFsdWU7CiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7CiAgICAgICAgdmFsdWUuc2V0QXR0cmlidXRlKCJkYXRhLXNsb3QiLCBwcm9wKTsKICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICJzdHJpbmciIHx8IHR5cGVvZiB2YWx1ZSA9PT0gIm51bWJlciIgfHwgdHlwZW9mIHZhbHVlID09PSAiYm9vbGVhbiIpIHsKICAgICAgICBlbGVtID0gY3JlYXRlKCJzcGFuIik7CiAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoImRhdGEtc2xvdCIsIHByb3ApOwogICAgICAgIGVsZW0uaW5uZXJUZXh0ID0gU3RyaW5nKHZhbHVlKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgZm9yIHNsb3QgJHtwcm9wfSBpbiA8JHtjLnRhZ05hbWV9PmApOwogICAgICB9CiAgICAgIGNvbnN0IGV4aXN0aW5nU2xvdHMgPSBBcnJheS5mcm9tKAogICAgICAgIGMucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtc2xvdD0iJHtwcm9wfSJdYCkKICAgICAgKTsKICAgICAgaWYgKGV4aXN0aW5nU2xvdHMubGVuZ3RoID4gMCkgewogICAgICAgIGV4aXN0aW5nU2xvdHMuZm9yRWFjaCgocykgPT4gcy5wYXJlbnRFbGVtZW50Py5yZXBsYWNlQ2hpbGQoZWxlbSwgcykpOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IHNsb3RzID0gQXJyYXkuZnJvbShjLnF1ZXJ5U2VsZWN0b3JBbGwoYHNsb3RbbmFtZT0iJHtwcm9wfSJdYCkpOwogICAgICAgIHNsb3RzLmZvckVhY2goKHMpID0+IHMucGFyZW50RWxlbWVudD8ucmVwbGFjZUNoaWxkKGVsZW0sIHMpKTsKICAgICAgfQogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICB9KTsKfQpmdW5jdGlvbiBjcmVhdGVTdGF0ZUFjY2Vzc29yKHN0YXRlLCBsb2csIGFsbG93V3JpdGVzID0gZmFsc2UsIGFjY3VtKSB7CiAgY29uc3QgY3VycmVudCA9IGFjY3VtIHx8IHsgdGFyZ2V0czogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIHBhdGg6IFtdIH07CiAgaWYgKHN0YXRlID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7CiAgcmV0dXJuIG5ldyBQcm94eShzdGF0ZSwgewogICAgLy8gU3RhdGUgYWNjZXNzb3JzIGFyZSByZWFkLW9ubHkgYnkgZGVmYXVsdDoKICAgIHNldCh0YXJnZXQsIHByb3AsIG5ld1ZhbHVlKSB7CiAgICAgIGlmIChhbGxvd1dyaXRlcykgewogICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIG5ld1ZhbHVlKTsKICAgICAgfQogICAgICBpZiAodHlwZW9mIHByb3AgPT09ICJzdHJpbmciKSB7CiAgICAgICAgY29uc29sZS5lcnJvcigKICAgICAgICAgIGBTdGF0ZSBpcyByZWFkLW9ubHkgZm9yIHdlYiBjb21wb25lbnRzLiBVbmFibGUgdG8gc2V0ICcke3Byb3B9Jy5gCiAgICAgICAgKTsKICAgICAgfQogICAgICByZXR1cm4gZmFsc2U7CiAgICB9LAogICAgLy8gUmVjdXJzaXZlbHkgYnVpbGQgYSBwcm94eSBmb3IgZWFjaCBzdGF0ZSBwcm9wIGJlaW5nIHJlYWQ6CiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgewogICAgICBjb25zdCB2YWx1ZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpOwogICAgICBjb25zdCBpc1Byb3RvID0gcHJvcCA9PT0gIl9fcHJvdG9fXyI7CiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gInN0cmluZyIgJiYgIWlzUHJvdG8pIHsKICAgICAgICBpZiAoIWN1cnJlbnQudGFyZ2V0cy5oYXModGFyZ2V0KSkgewogICAgICAgICAgY3VycmVudC50YXJnZXRzLnNldCh0YXJnZXQsIGN1cnJlbnQucGF0aC5qb2luKCIuIikpOwogICAgICAgIH0KICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gY3VycmVudC50YXJnZXRzLmdldCh0YXJnZXQpOwogICAgICAgIGN1cnJlbnQucGF0aC5sZW5ndGggPSAwOwogICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0UGF0aCA9PT0gInN0cmluZyIgJiYgdGFyZ2V0UGF0aCAhPT0gIiIpIHsKICAgICAgICAgIGN1cnJlbnQucGF0aC5wdXNoKC4uLnRhcmdldFBhdGguc3BsaXQoIi4iKSk7CiAgICAgICAgfQogICAgICAgIGN1cnJlbnQucGF0aC5wdXNoKHByb3ApOwogICAgICB9CiAgICAgIGlmIChpc1Byb3RvIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUE9KTyh2YWx1ZSkpIHsKICAgICAgICBpZiAoIWN1cnJlbnQudGFyZ2V0cy5oYXModmFsdWUpICYmIHR5cGVvZiBwcm9wID09PSAic3RyaW5nIikgewogICAgICAgICAgY3VycmVudC50YXJnZXRzLnNldCh2YWx1ZSwgY3VycmVudC5wYXRoLmpvaW4oIi4iKSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBjcmVhdGVTdGF0ZUFjY2Vzc29yKHZhbHVlLCBsb2csIGFsbG93V3JpdGVzLCBjdXJyZW50KTsKICAgICAgfQogICAgICBsZXQgcGF0aCA9IGN1cnJlbnQudGFyZ2V0cy5nZXQodGFyZ2V0KSA/PyAiIjsKICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAic3RyaW5nIiAmJiB0eXBlb2YgcHJvcCA9PT0gInN0cmluZyIpIHsKICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7CiAgICAgICAgICBwYXRoOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBwYXRoICs9IHBhdGggIT09ICIiID8gYC4ke3Byb3B9YCA6IHByb3A7CiAgICAgICAgfQogICAgICAgIGlmIChsb2cuaW5kZXhPZihwYXRoKSA9PT0gLTEpIHsKICAgICAgICAgIGxvZy5wdXNoKHBhdGgpOwogICAgICAgIH0KICAgICAgfQogICAgICBjdXJyZW50LnBhdGgubGVuZ3RoID0gMDsKICAgICAgY3VycmVudC5wYXRoLnB1c2gocGF0aCk7CiAgICAgIHJldHVybiB2YWx1ZTsKICAgIH0KICB9KTsKfQpmdW5jdGlvbiBjcmVhdGVTdWJzY3JpYmVyc0Rpc3BhdGNoZXIoc3RhdGUpIHsKICByZXR1cm4gKCkgPT4gewogICAgY29uc3QgdXBkYXRlcyA9IHN0YXRlLmludGVybmFsLnVwZGF0ZXM7CiAgICBjb25zdCBub3RpZmllZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7CiAgICBjb25zdCBub3RpZnkgPSAoZm5zKSA9PiB7CiAgICAgIGlmICghZm5zKSByZXR1cm47CiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZm5zLmxlbmd0aDsgaisrKSB7CiAgICAgICAgY29uc3QgZm4gPSBmbnNbal07CiAgICAgICAgaWYgKG5vdGlmaWVkLmhhcyhmbikpIGNvbnRpbnVlOwogICAgICAgIG5vdGlmaWVkLmFkZChmbik7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZuKHN0YXRlLmFwcCk7CiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICB9CiAgICAgIH0KICAgIH07CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVwZGF0ZXMucGF0aC5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCBwYXRoID0gdXBkYXRlcy5wYXRoW2ldOwogICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnNsaWNlKHBhdGguaW5kZXhPZigiLiIpICsgMSk7CiAgICAgIG5vdGlmeSh1cGRhdGVzLnN1YnNjcmliZXJzLmdldChyZWxhdGl2ZVBhdGgpKTsKICAgICAgZm9yIChjb25zdCBbc3Vic2NyaWJlclBhdGgsIGZuc10gb2YgdXBkYXRlcy5zdWJzY3JpYmVycy5lbnRyaWVzKCkpIHsKICAgICAgICBpZiAoc3Vic2NyaWJlclBhdGggPT09IHJlbGF0aXZlUGF0aCkgY29udGludWU7CiAgICAgICAgY29uc3Qgc3Vic2NyaWJlcldpdGhEb3QgPSBgJHtzdWJzY3JpYmVyUGF0aH0uYDsKICAgICAgICBjb25zdCByZWxhdGl2ZVdpdGhEb3QgPSBgJHtyZWxhdGl2ZVBhdGh9LmA7CiAgICAgICAgaWYgKHJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHN1YnNjcmliZXJXaXRoRG90KSB8fCBzdWJzY3JpYmVyUGF0aC5zdGFydHNXaXRoKHJlbGF0aXZlV2l0aERvdCkpIHsKICAgICAgICAgIG5vdGlmeShmbnMpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgdXBkYXRlcy5wYXRoID0gW107CiAgICB1cGRhdGVzLnZhbHVlID0gW107CiAgICB1cGRhdGVzLnJhZiA9IHZvaWQgMDsKICB9Owp9CmZ1bmN0aW9uIHByb3hpZnkoYm9yZWRvbSkgewogIGNvbnN0IHJ1bnRpbWUgPSBib3JlZG9tLmludGVybmFsOwogIGNvbnN0IHN0YXRlID0gYm9yZWRvbTsKICBpZiAoc3RhdGUgPT09IHZvaWQgMCkgcmV0dXJuIGJvcmVkb207CiAgY29uc3Qgb2JqZWN0c1dpdGhQcm94aWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7CiAgY29uc3QgUFJPWFlfTUFSS0VSID0gU3ltYm9sKCJib3JlZG9tLXByb3h5Iik7CiAgZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVQcm94eSh2YWx1ZSwgZG90dGVkUGF0aCkgewogICAgaWYgKG9iamVjdHNXaXRoUHJveGllcy5oYXModmFsdWUpKSByZXR1cm4gdmFsdWU7CiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh2YWx1ZSwgewogICAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgewogICAgICAgIGlmIChwcm9wID09PSBQUk9YWV9NQVJLRVIpIHJldHVybiB0cnVlOwogICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTsKICAgICAgfSwKICAgICAgc2V0KHRhcmdldCwgcHJvcCwgbmV3VmFsdWUpIHsKICAgICAgICBjb25zdCBpc0NoYW5nZWQgPSB0YXJnZXRbcHJvcF0gIT09IG5ld1ZhbHVlOwogICAgICAgIGlmICghaXNDaGFuZ2VkKSByZXR1cm4gdHJ1ZTsKICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBjb25zdCBuZXdQYXRoID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBkb3R0ZWRQYXRoIDogYCR7ZG90dGVkUGF0aH0uJHtwcm9wfWA7CiAgICAgICAgICBjb25zdCBpc0FscmVhZHlQcm94eSA9IG5ld1ZhbHVlICYmIG5ld1ZhbHVlW1BST1hZX01BUktFUl0gPT09IHRydWU7CiAgICAgICAgICBpZiAoIWlzQWxyZWFkeVByb3h5ICYmIChBcnJheS5pc0FycmF5KG5ld1ZhbHVlKSB8fCBpc1BPSk8obmV3VmFsdWUpKSkgewogICAgICAgICAgICBuZXdWYWx1ZSA9IHByb3hpZnlWYWx1ZShuZXdWYWx1ZSwgbmV3UGF0aCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgbmV3VmFsdWUpOwogICAgICAgIGlmICh0eXBlb2YgcHJvcCAhPT0gInN0cmluZyIpIHJldHVybiB0cnVlOwogICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgewogICAgICAgICAgcnVudGltZS51cGRhdGVzLnBhdGgucHVzaChgJHtkb3R0ZWRQYXRofWApOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBydW50aW1lLnVwZGF0ZXMucGF0aC5wdXNoKGAke2RvdHRlZFBhdGh9LiR7cHJvcH1gKTsKICAgICAgICB9CiAgICAgICAgcnVudGltZS51cGRhdGVzLnZhbHVlLnB1c2godGFyZ2V0KTsKICAgICAgICBpZiAoIXJ1bnRpbWUudXBkYXRlcy5yYWYpIHsKICAgICAgICAgIHJ1bnRpbWUudXBkYXRlcy5yYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoCiAgICAgICAgICAgIGNyZWF0ZVN1YnNjcmliZXJzRGlzcGF0Y2hlcihib3JlZG9tKQogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgIH0pOwogICAgb2JqZWN0c1dpdGhQcm94aWVzLmFkZCh2YWx1ZSk7CiAgICBvYmplY3RzV2l0aFByb3hpZXMuYWRkKHByb3h5KTsKICAgIHJldHVybiBwcm94eTsKICB9CiAgZnVuY3Rpb24gcHJveGlmeVZhbHVlKHZhbHVlLCBiYXNlUGF0aCkgewogICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAhaXNQT0pPKHZhbHVlKSkgcmV0dXJuIHZhbHVlOwogICAgaWYgKG9iamVjdHNXaXRoUHJveGllcy5oYXModmFsdWUpKSByZXR1cm4gdmFsdWU7CiAgICBpZiAodmFsdWUgJiYgdmFsdWVbUFJPWFlfTUFSS0VSXSA9PT0gdHJ1ZSkgcmV0dXJuIHZhbHVlOwogICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07CiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkgfHwgaXNQT0pPKGl0ZW0pKSB7CiAgICAgICAgICB2YWx1ZVtpXSA9IHByb3hpZnlWYWx1ZShpdGVtLCBiYXNlUGF0aCk7CiAgICAgICAgfQogICAgICB9CiAgICB9IGVsc2UgewogICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZSkpIHsKICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVba2V5XTsKICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSB8fCBpc1BPSk8oaXRlbSkpIHsKICAgICAgICAgIHZhbHVlW2tleV0gPSBwcm94aWZ5VmFsdWUoaXRlbSwgYCR7YmFzZVBhdGh9LiR7a2V5fWApOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlUHJveHkodmFsdWUsIGJhc2VQYXRoKTsKICB9CiAgZmxhdHRlbihib3JlZG9tLCBbImludGVybmFsIl0pLmZvckVhY2goKHsgcGF0aCwgdmFsdWUgfSkgPT4gewogICAgY29uc3QgbmVlZHNQcm94eSA9IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUE9KTyh2YWx1ZSkgJiYgIW9iamVjdHNXaXRoUHJveGllcy5oYXModmFsdWUpOwogICAgaWYgKG5lZWRzUHJveHkpIHsKICAgICAgY29uc3QgZG90dGVkUGF0aCA9IHBhdGguam9pbigiLiIpOwogICAgICBjb25zdCBwYXJlbnQgPSBhY2Nlc3MocGF0aC5zbGljZSgwLCAtMSksIHN0YXRlKTsKICAgICAgY29uc3QgaXNSb290ID0gcGFyZW50ID09PSB2YWx1ZTsKICAgICAgaWYgKGlzUm9vdCkgcmV0dXJuOwogICAgICBwYXJlbnRbcGF0aC5hdCgtMSldID0gY3JlYXRlUmVhY3RpdmVQcm94eSh2YWx1ZSwgZG90dGVkUGF0aCk7CiAgICB9CiAgfSk7CiAgcmV0dXJuIGJvcmVkb207Cn0KZnVuY3Rpb24gcnVuQ29tcG9uZW50c0luaXRpYWxpemVyKHN0YXRlKSB7CiAgY29uc3QgdGFnc0luRG9tID0gc3RhdGUuaW50ZXJuYWwuY3VzdG9tVGFncy5maWx0ZXIoCiAgICAodGFnKSA9PiAoCiAgICAgIC8vIEEgdGFnIGlzIGNvbnNpZGVyZWQgcHJlc2VudCBpZiBhdCBsZWFzdCBvbmUgaW5zdGFuY2UgZXhpc3RzIGluIHRoZSBET00KICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YWcpICE9PSBudWxsCiAgICApCiAgKTsKICBjb25zdCBjb21wb25lbnRzID0gc3RhdGUuaW50ZXJuYWwuY29tcG9uZW50czsKICBmb3IgKGNvbnN0IFt0YWdOYW1lLCBjb2RlXSBvZiBjb21wb25lbnRzLmVudHJpZXMoKSkgewogICAgaWYgKGNvZGUgPT09IG51bGwgfHwgIXRhZ3NJbkRvbS5pbmNsdWRlcyh0YWdOYW1lKSkgY29udGludWU7CiAgICBjb25zdCBlbGVtZW50cyA9IEFycmF5LmZyb20oCiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGFnTmFtZSkKICAgICkuZmlsdGVyKChlbCkgPT4gaXNCb3JlZChlbCkpOwogICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkgewogICAgICBjb250aW51ZTsKICAgIH0KICAgIGVsZW1lbnRzLmZvckVhY2goKGNvbXBvbmVudENsYXNzLCBpbmRleCkgPT4gewogICAgICBpZiAoY29tcG9uZW50Q2xhc3MuaXNCb3JlZEluaXRpYWxpemVkKSByZXR1cm47CiAgICAgIGNvbnN0IGRldGFpbCA9IHsKICAgICAgICBpbmRleCwKICAgICAgICBuYW1lOiB0YWdOYW1lLAogICAgICAgIGRhdGE6IGV4dHJhY3REZXRhaWxEYXRhKGNvbXBvbmVudENsYXNzKQogICAgICB9OwogICAgICBjb2RlKHN0YXRlLCBkZXRhaWwpKGNvbXBvbmVudENsYXNzKTsKICAgICAgY29tcG9uZW50Q2xhc3MuX19ib3JlRE9NRGV0YWlsID0gZGV0YWlsOwogICAgICBjb21wb25lbnRDbGFzcy5pc0JvcmVkSW5pdGlhbGl6ZWQgPSB0cnVlOwogICAgfSk7CiAgfQogIHJldHVybjsKfQpmdW5jdGlvbiBjcmVhdGVBbmRSdW5Db2RlKG5hbWUsIHN0YXRlLCBkZXRhaWwpIHsKICBjb25zdCBjb2RlID0gc3RhdGUuaW50ZXJuYWwuY29tcG9uZW50cy5nZXQobmFtZSk7CiAgaWYgKGNvZGUpIHsKICAgIGNvbnN0IGluZm8gPSB7IC4uLmRldGFpbCwgdGFnTmFtZTogbmFtZSB9OwogICAgaWYgKCFpbmZvLmRhdGEpIGluZm8uZGF0YSA9IHt9OwogICAgY29uc3QgZWxlbWVudCA9IGNyZWF0ZUNvbXBvbmVudChuYW1lLCBjb2RlKHN0YXRlLCBpbmZvKSk7CiAgICBlbGVtZW50Ll9fYm9yZURPTURldGFpbCA9IGluZm87CiAgICByZXR1cm4gZWxlbWVudDsKICB9CiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChuYW1lKTsKfQoKLy8gc3JjL2RlYnVnLnRzCnZhciBkZWJ1Z0NvbmZpZyA9IHsKICBjb25zb2xlOiB0cnVlLAogIGdsb2JhbHM6IHRydWUsCiAgZXJyb3JCb3VuZGFyeTogdHJ1ZSwKICB2aXN1YWxJbmRpY2F0b3JzOiB0cnVlLAogIGVycm9ySGlzdG9yeTogdHJ1ZSwKICB2ZXJzaW9uTG9nOiB0cnVlLAogIGFwaTogdHJ1ZSwKICBtZXRob2RNaXNzaW5nOiB0cnVlLAogIHRlbXBsYXRlSW5mZXJlbmNlOiB0cnVlLAogIHN0cmljdDogZmFsc2UsCiAgb3V0cHV0Rm9ybWF0OiAiaHVtYW4iLAogIGxsbTogdHJ1ZQp9Owp2YXIgZXJyb3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKdmFyIGxhc3RFcnJvciA9IG51bGw7CmZ1bmN0aW9uIGlzRGVidWdFbmFibGVkKGZlYXR1cmUpIHsKICBpZiAodHlwZW9mIF9fREVCVUdfXyAhPT0gInVuZGVmaW5lZCIgJiYgIV9fREVCVUdfXykgewogICAgaWYgKGZlYXR1cmUgPT09ICJlcnJvckJvdW5kYXJ5IikgewogICAgICByZXR1cm4gZGVidWdDb25maWcuZXJyb3JCb3VuZGFyeSA/PyB0cnVlOwogICAgfQogICAgcmV0dXJuIGZhbHNlOwogIH0KICBjb25zdCB2YWx1ZSA9IGRlYnVnQ29uZmlnW2ZlYXR1cmVdOwogIGlmIChmZWF0dXJlID09PSAic3RyaWN0IikgewogICAgcmV0dXJuIHZhbHVlID8/IGZhbHNlOwogIH0KICByZXR1cm4gdmFsdWUgPz8gdHJ1ZTsKfQpmdW5jdGlvbiBzZXREZWJ1Z0NvbmZpZyhjb25maWcpIHsKICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gImJvb2xlYW4iKSB7CiAgICBjb25zdCBlbmFibGVkID0gY29uZmlnOwogICAgZGVidWdDb25maWcgPSB7CiAgICAgIGNvbnNvbGU6IGVuYWJsZWQsCiAgICAgIGdsb2JhbHM6IGVuYWJsZWQsCiAgICAgIGVycm9yQm91bmRhcnk6IHRydWUsCiAgICAgIC8vIEFsd2F5cyBrZWVwIGVycm9yIGJvdW5kYXJ5IGZvciBzYWZldHkKICAgICAgdmlzdWFsSW5kaWNhdG9yczogZW5hYmxlZCwKICAgICAgZXJyb3JIaXN0b3J5OiBlbmFibGVkLAogICAgICB2ZXJzaW9uTG9nOiBlbmFibGVkLAogICAgICBhcGk6IGVuYWJsZWQsCiAgICAgIG1ldGhvZE1pc3Npbmc6IGVuYWJsZWQsCiAgICAgIHRlbXBsYXRlSW5mZXJlbmNlOiBlbmFibGVkLAogICAgICBzdHJpY3Q6IGZhbHNlLAogICAgICAvLyBTdHJpY3QgbW9kZSBvbmx5IGVuYWJsZWQgZXhwbGljaXRseQogICAgICBvdXRwdXRGb3JtYXQ6ICJodW1hbiIsCiAgICAgIC8vIEFsd2F5cyBodW1hbiBmb3JtYXQgYnkgZGVmYXVsdAogICAgICBsbG06IGVuYWJsZWQKICAgICAgLy8gTExNIEFQSSBmb2xsb3dzIGRlYnVnIG1vZGUKICAgIH07CiAgfSBlbHNlIHsKICAgIGRlYnVnQ29uZmlnID0geyAuLi5kZWJ1Z0NvbmZpZywgLi4uY29uZmlnIH07CiAgfQp9CmZ1bmN0aW9uIGdldERlYnVnQ29uZmlnKCkgewogIHJldHVybiB7IC4uLmRlYnVnQ29uZmlnIH07Cn0KZnVuY3Rpb24gZXhwb3NlR2xvYmFscyhjdHgpIHsKICBpZiAodHlwZW9mIF9fREVCVUdfXyAhPT0gInVuZGVmaW5lZCIgJiYgIV9fREVCVUdfXykgcmV0dXJuOwogIGlmICghaXNEZWJ1Z0VuYWJsZWQoImdsb2JhbHMiKSkgcmV0dXJuOwogIGlmICh0eXBlb2Ygd2luZG93ID09PSAidW5kZWZpbmVkIikgcmV0dXJuOwogIGNvbnN0IHcgPSB3aW5kb3c7CiAgdy4kc3RhdGUgPSBjdHguc3RhdGU7CiAgdy4kcmVmcyA9IGN0eC5yZWZzOwogIHcuJHNsb3RzID0gY3R4LnNsb3RzOwogIHcuJHNlbGYgPSBjdHguZWxlbWVudDsKICB3LiRlcnJvciA9IGN0eC5lcnJvcjsKICB3LiRjb21wb25lbnQgPSBjdHguY29tcG9uZW50OwogIHcuJHJlcmVuZGVyID0gY3R4LnJlcmVuZGVyOwp9CmZ1bmN0aW9uIGNsZWFyR2xvYmFscygpIHsKICBpZiAodHlwZW9mIF9fREVCVUdfXyAhPT0gInVuZGVmaW5lZCIgJiYgIV9fREVCVUdfXykgcmV0dXJuOwogIGlmICghaXNEZWJ1Z0VuYWJsZWQoImdsb2JhbHMiKSkgcmV0dXJuOwogIGlmICh0eXBlb2Ygd2luZG93ID09PSAidW5kZWZpbmVkIikgcmV0dXJuOwogIGNvbnN0IHcgPSB3aW5kb3c7CiAgZGVsZXRlIHcuJHN0YXRlOwogIGRlbGV0ZSB3LiRyZWZzOwogIGRlbGV0ZSB3LiRzbG90czsKICBkZWxldGUgdy4kc2VsZjsKICBkZWxldGUgdy4kZXJyb3I7CiAgZGVsZXRlIHcuJGNvbXBvbmVudDsKICBkZWxldGUgdy4kcmVyZW5kZXI7Cn0KZnVuY3Rpb24gbG9nRXJyb3IoY3R4KSB7CiAgaWYgKHR5cGVvZiBfX0RFQlVHX18gIT09ICJ1bmRlZmluZWQiICYmICFfX0RFQlVHX18pIHJldHVybjsKICBpZiAoIWlzRGVidWdFbmFibGVkKCJjb25zb2xlIikpIHJldHVybjsKICBpZiAoZGVidWdDb25maWcub3V0cHV0Rm9ybWF0ID09PSAibGxtIikgewogICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoewogICAgICB0eXBlOiAiZXJyb3IiLAogICAgICBjb21wb25lbnQ6IGN0eC5jb21wb25lbnQsCiAgICAgIG1lc3NhZ2U6IGN0eC5lcnJvcj8ubWVzc2FnZSwKICAgICAgc3RhY2s6IGN0eC5lcnJvcj8uc3RhY2sKICAgIH0pKTsKICAgIHJldHVybjsKICB9CiAgY29uc29sZS5sb2coCiAgICAiJWNcdXsxRjUzNH0gYm9yZURPTTogRXJyb3IgaW4gJWM8JXM+JWMgcmVuZGVyIiwKICAgICJjb2xvcjogI2ZmNmI2YjsgZm9udC13ZWlnaHQ6IGJvbGQiLAogICAgImNvbG9yOiAjNGVjZGM0OyBmb250LXdlaWdodDogYm9sZCIsCiAgICBjdHguY29tcG9uZW50LAogICAgImNvbG9yOiAjZmY2YjZiIgogICk7CiAgY29uc29sZS5lcnJvcihjdHguZXJyb3IpOwogIGlmIChpc0RlYnVnRW5hYmxlZCgiZ2xvYmFscyIpKSB7CiAgICBjb25zb2xlLmxvZygiJWNcdXsxRjRDQn0gRGVidWcgY29udGV4dCBsb2FkZWQ6IiwgImNvbG9yOiAjOTVhNWE2OyBmb250LXdlaWdodDogYm9sZCIpOwogICAgY29uc29sZS5sb2coIiAgICRzdGF0ZSAgICAgXHUyMTkyIiwgY3R4LnN0YXRlKTsKICAgIGNvbnNvbGUubG9nKCIgICAkcmVmcyAgICAgIFx1MjE5MiIsIGN0eC5yZWZzKTsKICAgIGNvbnNvbGUubG9nKCIgICAkc2xvdHMgICAgIFx1MjE5MiIsIGN0eC5zbG90cyk7CiAgICBjb25zb2xlLmxvZygiICAgJHNlbGYgICAgICBcdTIxOTIiLCBjdHguZWxlbWVudCk7CiAgICBjb25zb2xlLmxvZygiJWNcdXsxRjRBMX0gUXVpY2sgZml4ZXM6IiwgImNvbG9yOiAjZjM5YzEyOyBmb250LXdlaWdodDogYm9sZCIpOwogICAgY29uc29sZS5sb2coIiAgICRzdGF0ZS5wcm9wZXJ0eU5hbWUgPSB2YWx1ZSIpOwogICAgY29uc29sZS5sb2coIiAgICRyZXJlbmRlcigpIik7CiAgICBjb25zb2xlLmxvZygiJWNcdXsxRjRFNH0gV2hlbiBmaXhlZDoiLCAiY29sb3I6ICMyN2FlNjA7IGZvbnQtd2VpZ2h0OiBib2xkIik7CiAgICBjb25zb2xlLmxvZyhgICAgYm9yZURPTS5leHBvcnQoJyR7Y3R4LmNvbXBvbmVudH0nKWApOwogIH0KfQpmdW5jdGlvbiBsb2dFcnJvck1pbmltYWwoY29tcG9uZW50MywgZXJyb3IpIHsKICBjb25zb2xlLmVycm9yKGBbYm9yZURPTV0gUmVuZGVyIGVycm9yIGluIDwke2NvbXBvbmVudDN9PjogJHtlcnJvci5tZXNzYWdlfWApOwp9CmZ1bmN0aW9uIGxvZ0luaXRFcnJvcihjb21wb25lbnQzLCBlcnJvcikgewogIGlmICh0eXBlb2YgX19ERUJVR19fICE9PSAidW5kZWZpbmVkIiAmJiAhX19ERUJVR19fKSByZXR1cm47CiAgaWYgKCFpc0RlYnVnRW5hYmxlZCgiY29uc29sZSIpKSByZXR1cm47CiAgY29uc29sZS5sb2coCiAgICAiJWNcdXsxRjUzNH0gYm9yZURPTTogRXJyb3IgaW4gJWM8JXM+JWMgaW5pdCIsCiAgICAiY29sb3I6ICNmZjZiNmI7IGZvbnQtd2VpZ2h0OiBib2xkIiwKICAgICJjb2xvcjogIzRlY2RjNDsgZm9udC13ZWlnaHQ6IGJvbGQiLAogICAgY29tcG9uZW50MywKICAgICJjb2xvcjogI2ZmNmI2YiIKICApOwogIGNvbnNvbGUuZXJyb3IoZXJyb3IpOwp9CmZ1bmN0aW9uIHN0b3JlRXJyb3IoY3R4KSB7CiAgaWYgKHR5cGVvZiBfX0RFQlVHX18gIT09ICJ1bmRlZmluZWQiICYmICFfX0RFQlVHX18pIHJldHVybjsKICBpZiAoIWlzRGVidWdFbmFibGVkKCJlcnJvckhpc3RvcnkiKSkgcmV0dXJuOwogIGVycm9ycy5zZXQoY3R4LmNvbXBvbmVudCwgY3R4KTsKICBsYXN0RXJyb3IgPSBjdHg7Cn0KZnVuY3Rpb24gY2xlYXJFcnJvcihjb21wb25lbnQzKSB7CiAgaWYgKHR5cGVvZiBfX0RFQlVHX18gIT09ICJ1bmRlZmluZWQiICYmICFfX0RFQlVHX18pIHJldHVybjsKICBpZiAoIWlzRGVidWdFbmFibGVkKCJlcnJvckhpc3RvcnkiKSkgcmV0dXJuOwogIGlmIChjb21wb25lbnQzKSB7CiAgICBlcnJvcnMuZGVsZXRlKGNvbXBvbmVudDMpOwogICAgaWYgKGxhc3RFcnJvcj8uY29tcG9uZW50ID09PSBjb21wb25lbnQzKSB7CiAgICAgIGxhc3RFcnJvciA9IG51bGw7CiAgICB9CiAgfSBlbHNlIGlmIChsYXN0RXJyb3IpIHsKICAgIGVycm9ycy5kZWxldGUobGFzdEVycm9yLmNvbXBvbmVudCk7CiAgICBsYXN0RXJyb3IgPSBudWxsOwogIH0KfQpmdW5jdGlvbiBtYXJrQ29tcG9uZW50RXJyb3IoZWxlbWVudCkgewogIGlmICh0eXBlb2YgX19ERUJVR19fICE9PSAidW5kZWZpbmVkIiAmJiAhX19ERUJVR19fKSByZXR1cm47CiAgaWYgKCFpc0RlYnVnRW5hYmxlZCgidmlzdWFsSW5kaWNhdG9ycyIpKSByZXR1cm47CiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoImRhdGEtYm9yZWRvbS1lcnJvciIsICJ0cnVlIik7Cn0KZnVuY3Rpb24gY2xlYXJDb21wb25lbnRFcnJvck1hcmsoZWxlbWVudCkgewogIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCJkYXRhLWJvcmVkb20tZXJyb3IiKTsKfQpmdW5jdGlvbiBleHBvcnRTdGF0ZSh0YWdOYW1lKSB7CiAgY29uc3QgY3R4ID0gdGFnTmFtZSA/IGVycm9ycy5nZXQodGFnTmFtZSkgOiBsYXN0RXJyb3I7CiAgaWYgKCFjdHgpIHJldHVybiBudWxsOwogIHRyeSB7CiAgICByZXR1cm4gewogICAgICBjb21wb25lbnQ6IGN0eC5jb21wb25lbnQsCiAgICAgIHN0YXRlOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGN0eC5zdGF0ZSkpLAogICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKGN0eC50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksCiAgICAgIGVycm9yOiBjdHguZXJyb3IubWVzc2FnZQogICAgfTsKICB9IGNhdGNoIChlKSB7CiAgICBpZiAoaXNEZWJ1Z0VuYWJsZWQoImNvbnNvbGUiKSkgewogICAgICBjb25zb2xlLndhcm4oCiAgICAgICAgYFtib3JlRE9NXSBleHBvcnRTdGF0ZTogVW5hYmxlIHRvIHNlcmlhbGl6ZSBzdGF0ZSBmb3IgPCR7Y3R4LmNvbXBvbmVudH0+OmAsCiAgICAgICAgZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogZQogICAgICApOwogICAgfQogICAgcmV0dXJuIHsKICAgICAgY29tcG9uZW50OiBjdHguY29tcG9uZW50LAogICAgICBzdGF0ZTogIltVbmFibGUgdG8gc2VyaWFsaXplIC0gY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlcyBvciBmdW5jdGlvbnNdIiwKICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShjdHgudGltZXN0YW1wKS50b0lTT1N0cmluZygpLAogICAgICBlcnJvcjogY3R4LmVycm9yLm1lc3NhZ2UKICAgIH07CiAgfQp9CnZhciBkZWJ1Z0FQSSA9IHsKICAvKiogTWFwIG9mIGFsbCBjdXJyZW50IGVycm9ycyBieSBjb21wb25lbnQgbmFtZSAqLwogIGdldCBlcnJvcnMoKSB7CiAgICByZXR1cm4gZXJyb3JzOwogIH0sCiAgLyoqIE1vc3QgcmVjZW50IGVycm9yIGNvbnRleHQgKi8KICBnZXQgbGFzdEVycm9yKCkgewogICAgcmV0dXJuIGxhc3RFcnJvcjsKICB9LAogIC8qKiBSZS1yZW5kZXIgYSBzcGVjaWZpYyBjb21wb25lbnQgb3IgdGhlIGxhc3QgZXJyb3JlZCBvbmUgKi8KICByZXJlbmRlcih0YWdOYW1lKSB7CiAgICBjb25zdCBjdHggPSB0YWdOYW1lID8gZXJyb3JzLmdldCh0YWdOYW1lKSA6IGxhc3RFcnJvcjsKICAgIGlmIChjdHgpIHsKICAgICAgY3R4LnJlcmVuZGVyKCk7CiAgICB9IGVsc2UgewogICAgICBjb25zb2xlLndhcm4oIltib3JlRE9NXSBObyBlcnJvciBjb250ZXh0IGZvdW5kIHRvIHJlcmVuZGVyIik7CiAgICB9CiAgfSwKICAvKiogQ2xlYXIgZXJyb3Igc3RhdGUgZm9yIGEgY29tcG9uZW50ICovCiAgY2xlYXJFcnJvcih0YWdOYW1lKSB7CiAgICBjb25zdCBjdHggPSB0YWdOYW1lID8gZXJyb3JzLmdldCh0YWdOYW1lKSA6IGxhc3RFcnJvcjsKICAgIGlmIChjdHgpIHsKICAgICAgY2xlYXJDb21wb25lbnRFcnJvck1hcmsoY3R4LmVsZW1lbnQpOwogICAgICBjbGVhckVycm9yKHRhZ05hbWUpOwogICAgICBjbGVhckdsb2JhbHMoKTsKICAgIH0gZWxzZSBpZiAoaXNEZWJ1Z0VuYWJsZWQoImNvbnNvbGUiKSkgewogICAgICBjb25zb2xlLndhcm4oCiAgICAgICAgdGFnTmFtZSA/IGBbYm9yZURPTV0gY2xlYXJFcnJvcjogTm8gZXJyb3IgZm91bmQgZm9yIDwke3RhZ05hbWV9PmAgOiAiW2JvcmVET01dIGNsZWFyRXJyb3I6IE5vIGVycm9yIHRvIGNsZWFyIgogICAgICApOwogICAgfQogIH0sCiAgLyoqIEV4cG9ydCBzdGF0ZSBzbmFwc2hvdCAqLwogIGV4cG9ydDogZXhwb3J0U3RhdGUsCiAgLyoqIEN1cnJlbnQgZGVidWcgY29uZmlndXJhdGlvbiAocmVhZC1vbmx5KSAqLwogIGdldCBjb25maWcoKSB7CiAgICByZXR1cm4gZ2V0RGVidWdDb25maWcoKTsKICB9Cn07CgovLyBzcmMvY29uc29sZS1hcGkudHMKdmFyIFdFQl9DT01QT05FTlRfTUFSS0VSID0gU3ltYm9sKCJib3JlRE9NLndlYkNvbXBvbmVudCIpOwp2YXIgY3VycmVudEFwcFN0YXRlID0gbnVsbDsKdmFyIHN0b3JlZFdlYkNvbXBvbmVudCA9IG51bGw7CnZhciBzdG9yZWRSZWdpc3RlckNvbXBvbmVudCA9IG51bGw7CnZhciBjb21wb25lbnRDb250ZXh0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpOwpmdW5jdGlvbiBzZXRDdXJyZW50QXBwU3RhdGUoc3RhdGUsIHdlYkNvbXBvbmVudEZuLCByZWdpc3RlckNvbXBvbmVudEZuKSB7CiAgY3VycmVudEFwcFN0YXRlID0gc3RhdGU7CiAgaWYgKHdlYkNvbXBvbmVudEZuKSBzdG9yZWRXZWJDb21wb25lbnQgPSB3ZWJDb21wb25lbnRGbjsKICBpZiAocmVnaXN0ZXJDb21wb25lbnRGbikgc3RvcmVkUmVnaXN0ZXJDb21wb25lbnQgPSByZWdpc3RlckNvbXBvbmVudEZuOwp9CmZ1bmN0aW9uIGdldEN1cnJlbnRBcHBTdGF0ZSgpIHsKICByZXR1cm4gY3VycmVudEFwcFN0YXRlOwp9CmZ1bmN0aW9uIHN0b3JlQ29tcG9uZW50Q29udGV4dChlbGVtZW50LCBjb250ZXh0KSB7CiAgaWYgKHR5cGVvZiBfX0RFQlVHX18gIT09ICJ1bmRlZmluZWQiICYmICFfX0RFQlVHX18pIHJldHVybjsKICBpZiAoIWlzRGVidWdFbmFibGVkKCJhcGkiKSkgcmV0dXJuOwogIGNvbXBvbmVudENvbnRleHRzLnNldChlbGVtZW50LCBjb250ZXh0KTsKfQpmdW5jdGlvbiBpc1dlYkNvbXBvbmVudFJlc3VsdChmbikgewogIHJldHVybiB0eXBlb2YgZm4gPT09ICJmdW5jdGlvbiIgJiYgZm5bV0VCX0NPTVBPTkVOVF9NQVJLRVJdID09PSB0cnVlOwp9CmZ1bmN0aW9uIGRlZmluZSh0YWdOYW1lLCB0ZW1wbGF0ZSwgbG9naWMpIHsKICBpZiAodHlwZW9mIF9fREVCVUdfXyAhPT0gInVuZGVmaW5lZCIgJiYgIV9fREVCVUdfXykgewogICAgY29uc29sZS53YXJuKCJbYm9yZURPTV0gZGVmaW5lKCkgaXMgbm90IGF2YWlsYWJsZSBpbiBwcm9kdWN0aW9uIGJ1aWxkIik7CiAgICByZXR1cm4gZmFsc2U7CiAgfQogIGlmICghaXNEZWJ1Z0VuYWJsZWQoImFwaSIpKSB7CiAgICBjb25zb2xlLndhcm4oIltib3JlRE9NXSBkZWZpbmUoKSBpcyBkaXNhYmxlZCAoZGVidWcuYXBpIGlzIGZhbHNlKSIpOwogICAgcmV0dXJuIGZhbHNlOwogIH0KICBpZiAoIWN1cnJlbnRBcHBTdGF0ZSkgewogICAgdGhyb3cgbmV3IEVycm9yKCJbYm9yZURPTV0gQ2Fubm90IGRlZmluZSBjb21wb25lbnQgYmVmb3JlIGluZmxpY3RCb3JlRE9NKCkiKTsKICB9CiAgaWYgKCF0YWdOYW1lLmluY2x1ZGVzKCItIikpIHsKICAgIHRocm93IG5ldyBFcnJvcihgW2JvcmVET01dIEludmFsaWQgdGFnIG5hbWUgIiR7dGFnTmFtZX0iOiBtdXN0IGNvbnRhaW4gYSBoeXBoZW5gKTsKICB9CiAgaWYgKGN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkgewogICAgdGhyb3cgbmV3IEVycm9yKGBbYm9yZURPTV0gQ29tcG9uZW50ICIke3RhZ05hbWV9IiBpcyBhbHJlYWR5IGRlZmluZWRgKTsKICB9CiAgaWYgKCFzdG9yZWRXZWJDb21wb25lbnQgfHwgIXN0b3JlZFJlZ2lzdGVyQ29tcG9uZW50KSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoIltib3JlRE9NXSBDb25zb2xlIEFQSSBub3QgaW5pdGlhbGl6ZWQuIENhbGwgaW5mbGljdEJvcmVET00oKSBmaXJzdC4iKTsKICB9CiAgY29uc3QgYXBwU3RhdGUgPSBjdXJyZW50QXBwU3RhdGU7CiAgY29uc3Qgd2ViQ29tcG9uZW50Rm4gPSBzdG9yZWRXZWJDb21wb25lbnQ7CiAgY29uc3QgcmVnaXN0ZXJDb21wb25lbnRGbiA9IHN0b3JlZFJlZ2lzdGVyQ29tcG9uZW50OwogIGNvbnN0IHRlbXBsYXRlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZW1wbGF0ZSIpOwogIHRlbXBsYXRlRWwuaW5uZXJIVE1MID0gdGVtcGxhdGU7CiAgdGVtcGxhdGVFbC5zZXRBdHRyaWJ1dGUoImRhdGEtY29tcG9uZW50IiwgdGFnTmFtZSk7CiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wbGF0ZUVsKTsKICBjb25zdCBjb21wb25lbnRMb2dpYyA9IGlzV2ViQ29tcG9uZW50UmVzdWx0KGxvZ2ljKSA/IGxvZ2ljIDogd2ViQ29tcG9uZW50Rm4obG9naWMpOwogIGFwcFN0YXRlLmludGVybmFsLmNvbXBvbmVudHMuc2V0KHRhZ05hbWUsIGNvbXBvbmVudExvZ2ljKTsKICBhcHBTdGF0ZS5pbnRlcm5hbC5jdXN0b21UYWdzLnB1c2godGFnTmFtZSk7CiAgcmVnaXN0ZXJDb21wb25lbnRGbih0YWdOYW1lKTsKICBpbml0aWFsaXplRXhpc3RpbmdFbGVtZW50cyh0YWdOYW1lLCBjb21wb25lbnRMb2dpYyk7CiAgaWYgKGlzRGVidWdFbmFibGVkKCJjb25zb2xlIikpIHsKICAgIGNvbnNvbGUubG9nKAogICAgICAiJWNcdTI3MDUgYm9yZURPTTogRGVmaW5lZCAlYzwlcz4iLAogICAgICAiY29sb3I6ICMyN2FlNjA7IGZvbnQtd2VpZ2h0OiBib2xkIiwKICAgICAgImNvbG9yOiAjNGVjZGM0OyBmb250LXdlaWdodDogYm9sZCIsCiAgICAgIHRhZ05hbWUKICAgICk7CiAgfQogIHJldHVybiB0cnVlOwp9CmZ1bmN0aW9uIGluaXRpYWxpemVFeGlzdGluZ0VsZW1lbnRzKHRhZ05hbWUsIGxvZ2ljKSB7CiAgaWYgKCFjdXJyZW50QXBwU3RhdGUpIHJldHVybjsKICBjb25zdCBlbGVtZW50cyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YWdOYW1lKSk7CiAgY29uc3QgZmFpbGVkQ291bnQgPSB7IGNvdW50OiAwIH07CiAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHsKICAgIGlmIChlbGVtIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgInJlbmRlckNhbGxiYWNrIiBpbiBlbGVtKSB7CiAgICAgIHRyeSB7CiAgICAgICAgY29uc3QgZGV0YWlsID0geyBpbmRleCwgbmFtZTogdGFnTmFtZSwgZGF0YTogdm9pZCAwIH07CiAgICAgICAgY29uc3QgcmVuZGVyQ2FsbGJhY2sgPSBsb2dpYyhjdXJyZW50QXBwU3RhdGUsIGRldGFpbCk7CiAgICAgICAgZWxlbS5yZW5kZXJDYWxsYmFjayA9IHJlbmRlckNhbGxiYWNrOwogICAgICAgIHJlbmRlckNhbGxiYWNrKGVsZW0pOwogICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgIGZhaWxlZENvdW50LmNvdW50Kys7CiAgICAgICAgaWYgKGlzRGVidWdFbmFibGVkKCJjb25zb2xlIikpIHsKICAgICAgICAgIGNvbnNvbGUuZXJyb3IoCiAgICAgICAgICAgIGBbYm9yZURPTV0gRmFpbGVkIHRvIGluaXRpYWxpemUgPCR7dGFnTmFtZX0+IGluc3RhbmNlICR7aW5kZXh9OmAsCiAgICAgICAgICAgIGVycm9yCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0pOwogIGlmIChmYWlsZWRDb3VudC5jb3VudCA+IDAgJiYgaXNEZWJ1Z0VuYWJsZWQoImNvbnNvbGUiKSkgewogICAgY29uc29sZS53YXJuKAogICAgICBgW2JvcmVET01dICR7ZmFpbGVkQ291bnQuY291bnR9IG9mICR7ZWxlbWVudHMubGVuZ3RofSA8JHt0YWdOYW1lfT4gaW5zdGFuY2VzIGZhaWxlZCB0byBpbml0aWFsaXplYAogICAgKTsKICB9Cn0KZnVuY3Rpb24gb3BlcmF0ZShzZWxlY3Rvck9yRWxlbWVudCwgaW5kZXggPSAwKSB7CiAgaWYgKHR5cGVvZiBfX0RFQlVHX18gIT09ICJ1bmRlZmluZWQiICYmICFfX0RFQlVHX18pIHsKICAgIGNvbnNvbGUud2FybigiW2JvcmVET01dIG9wZXJhdGUoKSBpcyBub3QgYXZhaWxhYmxlIGluIHByb2R1Y3Rpb24gYnVpbGQiKTsKICAgIHJldHVybiB2b2lkIDA7CiAgfQogIGlmICghaXNEZWJ1Z0VuYWJsZWQoImFwaSIpKSB7CiAgICBjb25zb2xlLndhcm4oIltib3JlRE9NXSBvcGVyYXRlKCkgaXMgZGlzYWJsZWQgKGRlYnVnLmFwaSBpcyBmYWxzZSkiKTsKICAgIHJldHVybiB2b2lkIDA7CiAgfQogIGxldCBlbGVtZW50ID0gbnVsbDsKICBpZiAodHlwZW9mIHNlbGVjdG9yT3JFbGVtZW50ID09PSAic3RyaW5nIikgewogICAgY29uc3QgZWxlbWVudHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JPckVsZW1lbnQpKS5maWx0ZXIoKGVsKSA9PiBlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KTsKICAgIGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF0gPz8gbnVsbDsKICB9IGVsc2UgewogICAgZWxlbWVudCA9IHNlbGVjdG9yT3JFbGVtZW50OwogIH0KICBpZiAoIWVsZW1lbnQpIHsKICAgIGlmIChpc0RlYnVnRW5hYmxlZCgiY29uc29sZSIpKSB7CiAgICAgIGNvbnNvbGUud2FybihgW2JvcmVET01dIG9wZXJhdGUoKTogTm8gZWxlbWVudCBmb3VuZCBmb3IgIiR7c2VsZWN0b3JPckVsZW1lbnR9ImApOwogICAgfQogICAgcmV0dXJuIHZvaWQgMDsKICB9CiAgY29uc3QgY29udGV4dCA9IGNvbXBvbmVudENvbnRleHRzLmdldChlbGVtZW50KTsKICBpZiAoIWNvbnRleHQpIHsKICAgIGlmIChpc0RlYnVnRW5hYmxlZCgiY29uc29sZSIpKSB7CiAgICAgIGNvbnNvbGUud2FybihgW2JvcmVET01dIG9wZXJhdGUoKTogRWxlbWVudCBpcyBub3QgYSBib3JlRE9NIGNvbXBvbmVudCBvciBub3QgaW5pdGlhbGl6ZWRgKTsKICAgIH0KICAgIHJldHVybiB2b2lkIDA7CiAgfQogIHJldHVybiBjb250ZXh0Owp9CmZ1bmN0aW9uIGV4cG9ydENvbXBvbmVudChzZWxlY3RvcikgewogIGlmICh0eXBlb2YgX19ERUJVR19fICE9PSAidW5kZWZpbmVkIiAmJiAhX19ERUJVR19fKSB7CiAgICBjb25zb2xlLndhcm4oIltib3JlRE9NXSBleHBvcnRDb21wb25lbnQoKSBpcyBub3QgYXZhaWxhYmxlIGluIHByb2R1Y3Rpb24gYnVpbGQiKTsKICAgIHJldHVybiBudWxsOwogIH0KICBpZiAoIWlzRGVidWdFbmFibGVkKCJhcGkiKSkgewogICAgY29uc29sZS53YXJuKCJbYm9yZURPTV0gZXhwb3J0Q29tcG9uZW50KCkgaXMgZGlzYWJsZWQgKGRlYnVnLmFwaSBpcyBmYWxzZSkiKTsKICAgIHJldHVybiBudWxsOwogIH0KICBjb25zdCBjdHggPSBvcGVyYXRlKHNlbGVjdG9yKTsKICBpZiAoIWN0eCkgcmV0dXJuIG51bGw7CiAgY29uc3QgdGVtcGxhdGVFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHRlbXBsYXRlW2RhdGEtY29tcG9uZW50PSIke2N0eC5kZXRhaWwubmFtZX0iXWApOwogIGNvbnN0IHRlbXBsYXRlSHRtbCA9IHRlbXBsYXRlRWw/LmlubmVySFRNTCA/PyB2b2lkIDA7CiAgdHJ5IHsKICAgIHJldHVybiB7CiAgICAgIGNvbXBvbmVudDogY3R4LmRldGFpbC5uYW1lLAogICAgICBzdGF0ZTogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjdHguc3RhdGUpKSwKICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlSHRtbCwKICAgICAgdGltZXN0YW1wOiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCkKICAgIH07CiAgfSBjYXRjaCAoZSkgewogICAgaWYgKGlzRGVidWdFbmFibGVkKCJjb25zb2xlIikpIHsKICAgICAgY29uc29sZS53YXJuKAogICAgICAgIGBbYm9yZURPTV0gZXhwb3J0Q29tcG9uZW50OiBVbmFibGUgdG8gc2VyaWFsaXplIHN0YXRlIGZvciA8JHtjdHguZGV0YWlsLm5hbWV9PjpgLAogICAgICAgIGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IGUKICAgICAgKTsKICAgIH0KICAgIHJldHVybiB7CiAgICAgIGNvbXBvbmVudDogY3R4LmRldGFpbC5uYW1lLAogICAgICBzdGF0ZTogIltVbmFibGUgdG8gc2VyaWFsaXplIC0gY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlcyBvciBmdW5jdGlvbnNdIiwKICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlSHRtbCwKICAgICAgdGltZXN0YW1wOiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCkKICAgIH07CiAgfQp9CnZhciBjb25zb2xlQVBJID0gewogIGRlZmluZSwKICBvcGVyYXRlLAogIGV4cG9ydENvbXBvbmVudAp9OwoKLy8gc3JjL2luc2lkZS1vdXQudHMKdmFyIHVzZXJEZWZpbmVkSGVscGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7CnZhciBtaXNzaW5nRnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKdmFyIGxhc3RNaXNzaW5nID0gbnVsbDsKdmFyIGluZmVycmVkVGVtcGxhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKdmFyIHRlbXBsYXRlT2JzZXJ2ZXIgPSBudWxsOwpmdW5jdGlvbiBjcmVhdGVSZW5kZXJIZWxwZXJzKGNvbXBvbmVudE5hbWUsIGVsZW1lbnQsIHJlcmVuZGVyKSB7CiAgaWYgKHR5cGVvZiBfX0RFQlVHX18gIT09ICJ1bmRlZmluZWQiICYmICFfX0RFQlVHX18pIHsKICAgIHJldHVybiB7fTsKICB9CiAgaWYgKCFpc0RlYnVnRW5hYmxlZCgibWV0aG9kTWlzc2luZyIpKSB7CiAgICByZXR1cm4ge307CiAgfQogIHJldHVybiBuZXcgUHJveHkoe30sIHsKICAgIGdldChfdGFyZ2V0LCBwcm9wKSB7CiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gInN5bWJvbCIgfHwgcHJvcCA9PT0gInRoZW4iIHx8IHByb3AgPT09ICJ0b0pTT04iKSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfQogICAgICBpZiAodXNlckRlZmluZWRIZWxwZXJzLmhhcyhwcm9wKSkgewogICAgICAgIGNvbnN0IGhlbHBlciA9IHVzZXJEZWZpbmVkSGVscGVycy5nZXQocHJvcCk7CiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7CiAgICAgICAgICBjb25zdCByZXN1bHQgPSBoZWxwZXIoLi4uYXJncyk7CiAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH07CiAgICAgIH0KICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7CiAgICAgICAgY29uc3QgY3R4ID0gewogICAgICAgICAgbmFtZTogcHJvcCwKICAgICAgICAgIGFyZ3MsCiAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudE5hbWUsCiAgICAgICAgICBlbGVtZW50LAogICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLAogICAgICAgICAgZGVmaW5lOiAoaW1wbCkgPT4gewogICAgICAgICAgICBkZWZpbmVIZWxwZXIocHJvcCwgaW1wbCk7CiAgICAgICAgICAgIHJlcmVuZGVyKCk7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBsb2dNaXNzaW5nRnVuY3Rpb24oY3R4KTsKICAgICAgICBzdG9yZU1pc3NpbmdGdW5jdGlvbihjdHgpOwogICAgICAgIGV4cG9zZU1pc3NpbmdHbG9iYWxzKGN0eCk7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfTsKICAgIH0sCiAgICBoYXMoX3RhcmdldCwgcHJvcCkgewogICAgICByZXR1cm4gdHlwZW9mIHByb3AgPT09ICJzdHJpbmciICYmIHVzZXJEZWZpbmVkSGVscGVycy5oYXMocHJvcCk7CiAgICB9CiAgfSk7Cn0KZnVuY3Rpb24gZGVmaW5lSGVscGVyKG5hbWUsIGltcGxlbWVudGF0aW9uKSB7CiAgaWYgKHR5cGVvZiBfX0RFQlVHX18gIT09ICJ1bmRlZmluZWQiICYmICFfX0RFQlVHX18pIHJldHVybjsKICBpZiAoIWlzRGVidWdFbmFibGVkKCJtZXRob2RNaXNzaW5nIikpIHJldHVybjsKICB1c2VyRGVmaW5lZEhlbHBlcnMuc2V0KG5hbWUsIGltcGxlbWVudGF0aW9uKTsKICBpZiAoaXNEZWJ1Z0VuYWJsZWQoImNvbnNvbGUiKSkgewogICAgY29uc29sZS5sb2coCiAgICAgICIlY1x1MjcwNSBib3JlRE9NOiBEZWZpbmVkIGhlbHBlciAlYyVzIiwKICAgICAgImNvbG9yOiAjMjdhZTYwOyBmb250LXdlaWdodDogYm9sZCIsCiAgICAgICJjb2xvcjogIzliNTliNjsgZm9udC13ZWlnaHQ6IGJvbGQiLAogICAgICBuYW1lCiAgICApOwogIH0KfQpmdW5jdGlvbiBjbGVhckhlbHBlcihuYW1lKSB7CiAgdXNlckRlZmluZWRIZWxwZXJzLmRlbGV0ZShuYW1lKTsKfQpmdW5jdGlvbiBjbGVhck1pc3NpbmdGdW5jdGlvbnMoKSB7CiAgbWlzc2luZ0Z1bmN0aW9ucy5jbGVhcigpOwogIGxhc3RNaXNzaW5nID0gbnVsbDsKfQpmdW5jdGlvbiBsb2dNaXNzaW5nRnVuY3Rpb24oY3R4KSB7CiAgaWYgKCFpc0RlYnVnRW5hYmxlZCgiY29uc29sZSIpKSByZXR1cm47CiAgY29uc29sZS5sb2coCiAgICAiJWNcdTI2QTBcdUZFMEYgYm9yZURPTTogTWlzc2luZyBmdW5jdGlvbiAlYyVzJWMgaW4gPCVzPiIsCiAgICAiY29sb3I6ICNmMzljMTI7IGZvbnQtd2VpZ2h0OiBib2xkIiwKICAgICJjb2xvcjogIzliNTliNjsgZm9udC13ZWlnaHQ6IGJvbGQiLAogICAgY3R4Lm5hbWUsCiAgICAiY29sb3I6ICNmMzljMTIiLAogICAgY3R4LmNvbXBvbmVudAogICk7CiAgaWYgKGN0eC5hcmdzLmxlbmd0aCA+IDApIHsKICAgIGNvbnNvbGUubG9nKCIgICBBcmd1bWVudHM6IiwgY3R4LmFyZ3MpOwogIH0KICBjb25zb2xlLmxvZygiJWNcdXsxRjRBMX0gRGVmaW5lIGl0OiIsICJjb2xvcjogIzM0OThkYjsgZm9udC13ZWlnaHQ6IGJvbGQiKTsKICBjb25zb2xlLmxvZyhgICAgJGRlZmluZU1pc3NpbmcoKCR7Z2VuZXJhdGVBcmdOYW1lcyhjdHguYXJncyl9KSA9PiB7IC4uLiB9KWApOwogIGNvbnNvbGUubG9nKAogICAgYCAgIGJvcmVET00uZGVmaW5lSGVscGVyKCcke2N0eC5uYW1lfScsICgke2dlbmVyYXRlQXJnTmFtZXMoY3R4LmFyZ3MpfSkgPT4geyAuLi4gfSlgCiAgKTsKfQpmdW5jdGlvbiBnZW5lcmF0ZUFyZ05hbWVzKGFyZ3MpIHsKICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiAiIjsKICByZXR1cm4gYXJncy5tYXAoKGFyZywgaSkgPT4gewogICAgaWYgKGFyZyA9PT0gbnVsbCB8fCBhcmcgPT09IHZvaWQgMCkgcmV0dXJuIGBhcmcke2l9YDsKICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHJldHVybiAiaXRlbXMiOwogICAgaWYgKHR5cGVvZiBhcmcgPT09ICJvYmplY3QiKSB7CiAgICAgIGlmICgibmFtZSIgaW4gYXJnICYmICJlbWFpbCIgaW4gYXJnKSByZXR1cm4gInVzZXIiOwogICAgICBpZiAoImlkIiBpbiBhcmcgJiYgInRpdGxlIiBpbiBhcmcpIHJldHVybiAiaXRlbSI7CiAgICAgIGlmICgiaWQiIGluIGFyZykgcmV0dXJuICJyZWNvcmQiOwogICAgICByZXR1cm4gImRhdGEiOwogICAgfQogICAgaWYgKHR5cGVvZiBhcmcgPT09ICJzdHJpbmciKSByZXR1cm4gInRleHQiOwogICAgaWYgKHR5cGVvZiBhcmcgPT09ICJudW1iZXIiKSByZXR1cm4gImNvdW50IjsKICAgIGlmICh0eXBlb2YgYXJnID09PSAiYm9vbGVhbiIpIHJldHVybiAiZmxhZyI7CiAgICByZXR1cm4gYGFyZyR7aX1gOwogIH0pLmpvaW4oIiwgIik7Cn0KZnVuY3Rpb24gc3RvcmVNaXNzaW5nRnVuY3Rpb24oY3R4KSB7CiAgaWYgKCFpc0RlYnVnRW5hYmxlZCgiZXJyb3JIaXN0b3J5IikpIHJldHVybjsKICBjb25zdCBleGlzdGluZyA9IG1pc3NpbmdGdW5jdGlvbnMuZ2V0KGN0eC5uYW1lKSB8fCBbXTsKICBpZiAoZXhpc3RpbmcubGVuZ3RoID49IDEwKSB7CiAgICBleGlzdGluZy5zaGlmdCgpOwogIH0KICBleGlzdGluZy5wdXNoKGN0eCk7CiAgbWlzc2luZ0Z1bmN0aW9ucy5zZXQoY3R4Lm5hbWUsIGV4aXN0aW5nKTsKICBsYXN0TWlzc2luZyA9IGN0eDsKfQpmdW5jdGlvbiBleHBvc2VNaXNzaW5nR2xvYmFscyhjdHgpIHsKICBpZiAoIWlzRGVidWdFbmFibGVkKCJnbG9iYWxzIikpIHJldHVybjsKICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gInVuZGVmaW5lZCIpIHJldHVybjsKICBjb25zdCB3ID0gd2luZG93OwogIHcuJG1pc3NpbmdOYW1lID0gY3R4Lm5hbWU7CiAgdy4kbWlzc2luZ0FyZ3MgPSBjdHguYXJnczsKICB3LiRtaXNzaW5nQ29tcG9uZW50ID0gY3R4LmNvbXBvbmVudDsKICB3LiRkZWZpbmVNaXNzaW5nID0gY3R4LmRlZmluZTsKfQpmdW5jdGlvbiBpbmZlclRlbXBsYXRlKHRhZ05hbWUsIGVsZW1lbnQpIHsKICBpZiAodHlwZW9mIF9fREVCVUdfXyAhPT0gInVuZGVmaW5lZCIgJiYgIV9fREVCVUdfXykgcmV0dXJuIG51bGw7CiAgaWYgKCFpc0RlYnVnRW5hYmxlZCgidGVtcGxhdGVJbmZlcmVuY2UiKSkgcmV0dXJuIG51bGw7CiAgaWYgKGlzRGVidWdFbmFibGVkKCJzdHJpY3QiKSkgcmV0dXJuIG51bGw7CiAgY29uc3QgcHJvcHMgPSB7fTsKICBjb25zdCBzbG90cyA9IFtdOwogIGlmIChlbGVtZW50KSB7CiAgICBmb3IgKGNvbnN0IGF0dHIgb2YgQXJyYXkuZnJvbShlbGVtZW50LmF0dHJpYnV0ZXMpKSB7CiAgICAgIGlmIChhdHRyLm5hbWUuc3RhcnRzV2l0aCgiZGF0YS0iKSkgY29udGludWU7CiAgICAgIGlmIChbImNsYXNzIiwgImlkIiwgInN0eWxlIl0uaW5jbHVkZXMoYXR0ci5uYW1lKSkgY29udGludWU7CiAgICAgIGNvbnN0IGNhbWVsTmFtZSA9IGtlYmFiVG9DYW1lbChhdHRyLm5hbWUpOwogICAgICBwcm9wc1tjYW1lbE5hbWVdID0gcGFyc2VBdHRyaWJ1dGVWYWx1ZShhdHRyLnZhbHVlKTsKICAgIH0KICAgIGZvciAoY29uc3QgY2hpbGQgb2YgQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkcmVuKSkgewogICAgICBjb25zdCBzbG90TmFtZSA9IGNoaWxkLmdldEF0dHJpYnV0ZSgic2xvdCIpOwogICAgICBpZiAoc2xvdE5hbWUgJiYgIXNsb3RzLmluY2x1ZGVzKHNsb3ROYW1lKSkgewogICAgICAgIHNsb3RzLnB1c2goc2xvdE5hbWUpOwogICAgICB9CiAgICB9CiAgfQogIGNvbnN0IHByb3BzU2xvdHMgPSBPYmplY3Qua2V5cyhwcm9wcykubWFwKChwKSA9PiBgICAgIDxzbG90IG5hbWU9IiR7Y2FtZWxUb0tlYmFiKHApfSI+JHtmb3JtYXRWYWx1ZShwcm9wc1twXSl9PC9zbG90PmApLmpvaW4oIlxuIik7CiAgY29uc3QgZGVmYXVsdFNsb3QgPSBzbG90cy5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCA/ICcgICAgPHNsb3QgbmFtZT0iY29udGVudCI+TG9hZGluZy4uLjwvc2xvdD4nIDogIiI7CiAgY29uc3QgdGVtcGxhdGUgPSBgPGRpdiBjbGFzcz0iJHt0YWdOYW1lfS1za2VsZXRvbiIgZGF0YS1pbmZlcnJlZD4KJHtwcm9wc1Nsb3RzIHx8IGRlZmF1bHRTbG90fQogIDwvZGl2PmA7CiAgcmV0dXJuIHsgdGFnTmFtZSwgdGVtcGxhdGUsIHByb3BzLCBzbG90cyB9Owp9CmZ1bmN0aW9uIHJlZ2lzdGVySW5mZXJyZWRDb21wb25lbnQodGFnTmFtZSwgZWxlbWVudCkgewogIGlmICh0eXBlb2YgX19ERUJVR19fICE9PSAidW5kZWZpbmVkIiAmJiAhX19ERUJVR19fKSByZXR1cm4gZmFsc2U7CiAgaWYgKCFpc0RlYnVnRW5hYmxlZCgidGVtcGxhdGVJbmZlcmVuY2UiKSkgcmV0dXJuIGZhbHNlOwogIGlmIChjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHJldHVybiBmYWxzZTsKICBpZiAoIWdldEN1cnJlbnRBcHBTdGF0ZSgpKSByZXR1cm4gZmFsc2U7CiAgY29uc3QgaW5mZXJlbmNlID0gaW5mZXJUZW1wbGF0ZSh0YWdOYW1lLCBlbGVtZW50KTsKICBpZiAoIWluZmVyZW5jZSkgcmV0dXJuIGZhbHNlOwogIGNvbnN0IHsgdGVtcGxhdGUsIHByb3BzIH0gPSBpbmZlcmVuY2U7CiAgaW5mZXJyZWRUZW1wbGF0ZXMuc2V0KHRhZ05hbWUsIGluZmVyZW5jZSk7CiAgbG9nSW5mZXJyZWRDb21wb25lbnQodGFnTmFtZSwgcHJvcHMpOwogIHRyeSB7CiAgICBkZWZpbmUoCiAgICAgIHRhZ05hbWUsCiAgICAgIHRlbXBsYXRlLAogICAgICAvLyBTdHViIHJlbmRlciB0aGF0IGxvZ3Mgd2hhdCBpdCByZWNlaXZlcwogICAgICAoeyBzdGF0ZSB9KSA9PiAoeyBzbG90cyB9KSA9PiB7CiAgICAgICAgaWYgKGlzRGVidWdFbmFibGVkKCJjb25zb2xlIikpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKAogICAgICAgICAgICAiJWNcdXsxRjUyRX0gYm9yZURPTTogSW5mZXJyZWQgPCVzPiByZW5kZXJpbmciLAogICAgICAgICAgICAiY29sb3I6ICM5YjU5YjY7IGZvbnQtd2VpZ2h0OiBib2xkIiwKICAgICAgICAgICAgdGFnTmFtZQogICAgICAgICAgKTsKICAgICAgICAgIGNvbnNvbGUubG9nKCIgICBJbmZlcnJlZCBwcm9wczoiLCBwcm9wcyk7CiAgICAgICAgICBjb25zb2xlLmxvZygiICAgQXBwIHN0YXRlOiIsIHN0YXRlKTsKICAgICAgICB9CiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7CiAgICAgICAgICBjb25zdCBzbG90S2V5ID0gY2FtZWxUb0tlYmFiKGtleSk7CiAgICAgICAgICBpZiAoc2xvdHNbc2xvdEtleV0pIHsKICAgICAgICAgICAgc2xvdHNbc2xvdEtleV0gPSBTdHJpbmcodmFsdWUpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgKTsKICAgIHJldHVybiB0cnVlOwogIH0gY2F0Y2ggKGUpIHsKICAgIGlmIChpc0RlYnVnRW5hYmxlZCgiY29uc29sZSIpKSB7CiAgICAgIGNvbnNvbGUud2FybihgW2JvcmVET01dIEZhaWxlZCB0byByZWdpc3RlciBpbmZlcnJlZCA8JHt0YWdOYW1lfT46YCwgZSk7CiAgICB9CiAgICByZXR1cm4gZmFsc2U7CiAgfQp9CmZ1bmN0aW9uIGxvZ0luZmVycmVkQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7CiAgaWYgKCFpc0RlYnVnRW5hYmxlZCgiY29uc29sZSIpKSByZXR1cm47CiAgY29uc29sZS5sb2coCiAgICAiJWNcdXsxRjUyRX0gYm9yZURPTTogSW5mZXJyaW5nIHRlbXBsYXRlIGZvciAlYzwlcz4iLAogICAgImNvbG9yOiAjOWI1OWI2OyBmb250LXdlaWdodDogYm9sZCIsCiAgICAiY29sb3I6ICM0ZWNkYzQ7IGZvbnQtd2VpZ2h0OiBib2xkIiwKICAgIHRhZ05hbWUKICApOwogIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID4gMCkgewogICAgY29uc29sZS5sb2coIiVjXHV7MUY0Q0J9IEluZmVycmVkIHByb3BzIGZyb20gYXR0cmlidXRlczoiLCAiY29sb3I6ICM5NWE1YTYiKTsKICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkgewogICAgICBjb25zb2xlLmxvZyhgICAgJHtrZXl9OiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKTsKICAgIH0KICB9CiAgY29uc29sZS5sb2coIiVjXHV7MUY0QTF9IERlZmluZSBwcm9wZXJseSB3aXRoOiIsICJjb2xvcjogIzM0OThkYjsgZm9udC13ZWlnaHQ6IGJvbGQiKTsKICBjb25zb2xlLmxvZygKICAgIGAgICBib3JlRE9NLmRlZmluZSgnJHt0YWdOYW1lfScsICc8eW91ciB0ZW1wbGF0ZT4nLCAoeyBzdGF0ZSB9KSA9PiAoeyBzbG90cyB9KSA9PiB7IC4uLiB9KWAKICApOwp9CmZ1bmN0aW9uIG9ic2VydmVVbmRlZmluZWRFbGVtZW50cygpIHsKICBpZiAodHlwZW9mIF9fREVCVUdfXyAhPT0gInVuZGVmaW5lZCIgJiYgIV9fREVCVUdfXykgcmV0dXJuOwogIGlmICghaXNEZWJ1Z0VuYWJsZWQoInRlbXBsYXRlSW5mZXJlbmNlIikpIHJldHVybjsKICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gInVuZGVmaW5lZCIpIHJldHVybjsKICBpZiAodGVtcGxhdGVPYnNlcnZlcikgcmV0dXJuOwogIHRlbXBsYXRlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7CiAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykgewogICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgQXJyYXkuZnJvbShtdXRhdGlvbi5hZGRlZE5vZGVzKSkgewogICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgbm9kZS50YWdOYW1lLmluY2x1ZGVzKCItIikpIHsKICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTsKICAgICAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7CiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigKICAgICAgICAgICAgICBgdGVtcGxhdGVbZGF0YS1jb21wb25lbnQ9IiR7dGFnTmFtZX0iXWAKICAgICAgICAgICAgKTsKICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkgewogICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHsKICAgICAgICAgICAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7CiAgICAgICAgICAgICAgICAgIHJlZ2lzdGVySW5mZXJyZWRDb21wb25lbnQodGFnTmFtZSwgbm9kZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9KTsKICB0ZW1wbGF0ZU9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwgewogICAgY2hpbGRMaXN0OiB0cnVlLAogICAgc3VidHJlZTogdHJ1ZQogIH0pOwp9CmZ1bmN0aW9uIGtlYmFiVG9DYW1lbChzdHIpIHsKICByZXR1cm4gc3RyLnJlcGxhY2UoLy0oW2Etel0pL2csIChfLCBsZXR0ZXIpID0+IGxldHRlci50b1VwcGVyQ2FzZSgpKTsKfQpmdW5jdGlvbiBjYW1lbFRvS2ViYWIoc3RyKSB7CiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csICItJDEiKS50b0xvd2VyQ2FzZSgpOwp9CmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlVmFsdWUodmFsdWUpIHsKICBpZiAodmFsdWUgPT09ICJ0cnVlIikgcmV0dXJuIHRydWU7CiAgaWYgKHZhbHVlID09PSAiZmFsc2UiKSByZXR1cm4gZmFsc2U7CiAgY29uc3QgbnVtID0gTnVtYmVyKHZhbHVlKTsKICBpZiAoIWlzTmFOKG51bSkgJiYgdmFsdWUgIT09ICIiKSByZXR1cm4gbnVtOwogIGlmICh2YWx1ZS5zdGFydHNXaXRoKCJ7IikgfHwgdmFsdWUuc3RhcnRzV2l0aCgiWyIpKSB7CiAgICB0cnkgewogICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7CiAgICB9IGNhdGNoIHsKICAgICAgcmV0dXJuIHZhbHVlOwogICAgfQogIH0KICByZXR1cm4gdmFsdWU7Cn0KZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUpIHsKICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCkgcmV0dXJuICIiOwogIGlmICh0eXBlb2YgdmFsdWUgPT09ICJvYmplY3QiKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpOwogIHJldHVybiBTdHJpbmcodmFsdWUpOwp9CnZhciBpbnNpZGVPdXRBUEkgPSB7CiAgLyoqIE1hcCBvZiBtaXNzaW5nIGZ1bmN0aW9uIGNhbGxzIGJ5IGZ1bmN0aW9uIG5hbWUgKi8KICBnZXQgbWlzc2luZ0Z1bmN0aW9ucygpIHsKICAgIHJldHVybiBtaXNzaW5nRnVuY3Rpb25zOwogIH0sCiAgLyoqIE1vc3QgcmVjZW50IG1pc3NpbmcgZnVuY3Rpb24gY29udGV4dCAqLwogIGdldCBsYXN0TWlzc2luZygpIHsKICAgIHJldHVybiBsYXN0TWlzc2luZzsKICB9LAogIC8qKiBEZWZpbmUgYSBoZWxwZXIgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGFsbCByZW5kZXIgZnVuY3Rpb25zICovCiAgZGVmaW5lSGVscGVyLAogIC8qKiBHZXQgYWxsIGRlZmluZWQgaGVscGVycyAqLwogIGdldCBoZWxwZXJzKCkgewogICAgcmV0dXJuIG5ldyBNYXAodXNlckRlZmluZWRIZWxwZXJzKTsKICB9LAogIC8qKiBDbGVhciBhIGhlbHBlciBkZWZpbml0aW9uICovCiAgY2xlYXJIZWxwZXIsCiAgLyoqIENsZWFyIGFsbCBtaXNzaW5nIGZ1bmN0aW9uIHJlY29yZHMgKi8KICBjbGVhck1pc3NpbmdGdW5jdGlvbnMsCiAgLyoqIE1hcCBvZiBpbmZlcnJlZCB0ZW1wbGF0ZXMgYnkgdGFnIG5hbWUgKi8KICBnZXQgaW5mZXJyZWRUZW1wbGF0ZXMoKSB7CiAgICByZXR1cm4gaW5mZXJyZWRUZW1wbGF0ZXM7CiAgfSwKICAvKiogTWFudWFsbHkgaW5mZXIgdGVtcGxhdGUgZm9yIGEgdGFnICh1c2VmdWwgZm9yIHRlc3RpbmcpICovCiAgaW5mZXJUZW1wbGF0ZQp9OwoKLy8gc3JjL3Zpc2lvbi50cwp2YXIgSUdOT1JFRF9UQUdTID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWwogICJzY3JpcHQiLAogICJzdHlsZSIsCiAgIm5vc2NyaXB0IiwKICAidGVtcGxhdGUiLAogICJsaW5rIiwKICAibWV0YSIsCiAgImhlYWQiLAogICJ0aXRsZSIKXSk7CnZhciBJTVBPUlRBTlRfQVRUUlMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbCiAgImlkIiwKICAiY2xhc3MiLAogICJ0eXBlIiwKICAidmFsdWUiLAogICJjaGVja2VkIiwKICAiZGlzYWJsZWQiLAogICJwbGFjZWhvbGRlciIsCiAgImhyZWYiLAogICJzcmMiLAogICJhbHQiLAogICJ0aXRsZSIsCiAgInJvbGUiCl0pOwpmdW5jdGlvbiBpc1Zpc2libGUoZWxlbWVudCkgewogIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgiaGlkZGVuIikpIHJldHVybiBmYWxzZTsKICBpZiAoZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAibm9uZSIpIHJldHVybiBmYWxzZTsKICBpZiAoZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID09PSAiaGlkZGVuIikgcmV0dXJuIGZhbHNlOwogIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgiYXJpYS1oaWRkZW4iKSA9PT0gInRydWUiKSByZXR1cm4gZmFsc2U7CiAgcmV0dXJuIHRydWU7Cn0KZnVuY3Rpb24gZ2V0U2VtYW50aWNET00oZWxlbWVudCkgewogIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybiBudWxsOwogIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTsKICBpZiAoSUdOT1JFRF9UQUdTLmhhcyh0YWdOYW1lKSkgcmV0dXJuIG51bGw7CiAgaWYgKCFpc1Zpc2libGUoZWxlbWVudCkpIHJldHVybiBudWxsOwogIGNvbnN0IG5vZGUgPSB7IHRhZ05hbWUgfTsKICBjb25zdCBhdHRyaWJ1dGVzID0ge307CiAgbGV0IGhhc0F0dHJzID0gZmFsc2U7CiAgZm9yIChjb25zdCBhdHRyIG9mIEFycmF5LmZyb20oZWxlbWVudC5hdHRyaWJ1dGVzKSkgewogICAgY29uc3QgbmFtZSA9IGF0dHIubmFtZTsKICAgIGlmIChJTVBPUlRBTlRfQVRUUlMuaGFzKG5hbWUpIHx8IG5hbWUuc3RhcnRzV2l0aCgiYXJpYS0iKSB8fCBuYW1lLnN0YXJ0c1dpdGgoImRhdGEtIikpIHsKICAgICAgaWYgKG5hbWUgPT09ICJjaGVja2VkIiB8fCBuYW1lID09PSAiZGlzYWJsZWQiKSB7CiAgICAgICAgYXR0cmlidXRlc1tuYW1lXSA9IGVsZW1lbnRbbmFtZV07CiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gInZhbHVlIiAmJiAodGFnTmFtZSA9PT0gImlucHV0IiB8fCB0YWdOYW1lID09PSAidGV4dGFyZWEiIHx8IHRhZ05hbWUgPT09ICJzZWxlY3QiKSkgewogICAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSBlbGVtZW50LnZhbHVlOwogICAgICB9IGVsc2UgewogICAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSBhdHRyLnZhbHVlOwogICAgICB9CiAgICAgIGhhc0F0dHJzID0gdHJ1ZTsKICAgIH0KICB9CiAgaWYgKGhhc0F0dHJzKSBub2RlLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzOwogIGxldCB0ZXh0ID0gIiI7CiAgZm9yIChjb25zdCBjaGlsZCBvZiBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2RlcykpIHsKICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHsKICAgICAgY29uc3QgdmFsID0gY2hpbGQubm9kZVZhbHVlPy50cmltKCk7CiAgICAgIGlmICh2YWwpIHRleHQgKz0gdmFsICsgIiAiOwogICAgfQogIH0KICB0ZXh0ID0gdGV4dC50cmltKCk7CiAgaWYgKHRleHQpIG5vZGUudGV4dCA9IHRleHQ7CiAgY29uc3QgY2hpbGRyZW4gPSBbXTsKICBmb3IgKGNvbnN0IGNoaWxkIG9mIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZHJlbikpIHsKICAgIGNvbnN0IHNlbWFudGljQ2hpbGQgPSBnZXRTZW1hbnRpY0RPTShjaGlsZCk7CiAgICBpZiAoc2VtYW50aWNDaGlsZCkgewogICAgICBjaGlsZHJlbi5wdXNoKHNlbWFudGljQ2hpbGQpOwogICAgfQogIH0KICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuOwogIGlmICh0YWdOYW1lID09PSAiZGl2IiAmJiAhaGFzQXR0cnMgJiYgIXRleHQgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDsKICByZXR1cm4gbm9kZTsKfQoKLy8gc3JjL3BhdGNoLnRzCmZ1bmN0aW9uIGFwcGx5UGF0Y2goc3RhdGUsIHBhdGNoKSB7CiAgY29uc3QgdW5kb1N0YWNrID0gW107CiAgdHJ5IHsKICAgIGZvciAoY29uc3Qgb3Agb2YgcGF0Y2gpIHsKICAgICAgY29uc3QgaW52ZXJzZSA9IGFwcGx5T3Aoc3RhdGUsIG9wKTsKICAgICAgaWYgKGludmVyc2UpIHVuZG9TdGFjay5wdXNoKGludmVyc2UpOwogICAgfQogICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9OwogIH0gY2F0Y2ggKGUpIHsKICAgIGZvciAobGV0IGkgPSB1bmRvU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKICAgICAgdHJ5IHsKICAgICAgICBhcHBseU9wKHN0YXRlLCB1bmRvU3RhY2tbaV0pOwogICAgICB9IGNhdGNoIChyb2xsYmFja0Vycm9yKSB7CiAgICAgICAgY29uc29sZS5lcnJvcigiQ3JpdGljYWw6IFJvbGxiYWNrIGZhaWxlZCIsIHJvbGxiYWNrRXJyb3IpOwogICAgICB9CiAgICB9CiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGUubWVzc2FnZSB8fCBTdHJpbmcoZSkgfTsKICB9Cn0KZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHsKICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7CiAgaWYgKHR5cGVvZiBhICE9PSAib2JqZWN0IiB8fCBhID09PSBudWxsIHx8IHR5cGVvZiBiICE9PSAib2JqZWN0IiB8fCBiID09PSBudWxsKSByZXR1cm4gZmFsc2U7CiAgaWYgKEFycmF5LmlzQXJyYXkoYSkgIT09IEFycmF5LmlzQXJyYXkoYikpIHJldHVybiBmYWxzZTsKICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpOwogIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMoYik7CiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gZmFsc2U7CiAgZm9yIChjb25zdCBrZXkgb2Yga2V5c0EpIHsKICAgIGlmICgha2V5c0IuaW5jbHVkZXMoa2V5KSB8fCAhZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlOwogIH0KICByZXR1cm4gdHJ1ZTsKfQpmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkgewogIGlmIChwYXRoID09PSAiIikgcmV0dXJuIFtdOwogIGlmIChwYXRoID09PSAiLyIpIHJldHVybiBbIiJdOwogIHJldHVybiBwYXRoLnNwbGl0KCIvIikuc2xpY2UoMSkubWFwKAogICAgKHNlZ21lbnQpID0+IHNlZ21lbnQucmVwbGFjZSgvfjEvZywgIi8iKS5yZXBsYWNlKC9+MC9nLCAifiIpCiAgKTsKfQpmdW5jdGlvbiBhcHBseU9wKHJvb3QsIG9wKSB7CiAgY29uc3QgcGFydHMgPSBwYXJzZVBhdGgob3AucGF0aCk7CiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkgewogICAgdGhyb3cgbmV3IEVycm9yKCJDYW5ub3Qgb3BlcmF0ZSBvbiByb290IHN0YXRlIGRpcmVjdGx5Iik7CiAgfQogIGNvbnN0IGtleSA9IHBhcnRzLnBvcCgpOwogIGxldCB0YXJnZXQgPSByb290OwogIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXJ0cykgewogICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwIHx8IHRhcmdldCA9PT0gbnVsbCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGggbm90IGZvdW5kOiAke29wLnBhdGh9YCk7CiAgICB9CiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7CiAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoc2VnbWVudCwgMTApOwogICAgICBpZiAoaXNOYU4oaW5kZXgpKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXJyYXkgaW5kZXg6ICR7c2VnbWVudH1gKTsKICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2luZGV4XTsKICAgIH0gZWxzZSB7CiAgICAgIHRhcmdldCA9IHRhcmdldFtzZWdtZW50XTsKICAgIH0KICB9CiAgaWYgKHRhcmdldCA9PT0gdm9pZCAwIHx8IHRhcmdldCA9PT0gbnVsbCkgewogICAgdGhyb3cgbmV3IEVycm9yKGBQYXRoIG5vdCBmb3VuZDogJHtvcC5wYXRofWApOwogIH0KICBpZiAob3Aub3AgPT09ICJ0ZXN0IikgewogICAgbGV0IHZhbHVlVG9DaGVjazsKICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHsKICAgICAgaWYgKGtleSA9PT0gIi0iKSB7CiAgICAgICAgdmFsdWVUb0NoZWNrID0gdm9pZCAwOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoa2V5LCAxMCk7CiAgICAgICAgaWYgKGlzTmFOKGluZGV4KSB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkgewogICAgICAgICAgdmFsdWVUb0NoZWNrID0gdm9pZCAwOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YWx1ZVRvQ2hlY2sgPSB0YXJnZXRbaW5kZXhdOwogICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgdmFsdWVUb0NoZWNrID0gdGFyZ2V0W2tleV07CiAgICB9CiAgICBpZiAoIWRlZXBFcXVhbCh2YWx1ZVRvQ2hlY2ssIG9wLnZhbHVlKSkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlc3QgZmFpbGVkIGF0ICR7b3AucGF0aH06IGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkob3AudmFsdWUpfSwgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsdWVUb0NoZWNrKX1gKTsKICAgIH0KICAgIHJldHVybiBudWxsOwogIH0KICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7CiAgICBpZiAoa2V5ID09PSAiLSIpIHsKICAgICAgaWYgKG9wLm9wID09PSAiYWRkIikgewogICAgICAgIHRhcmdldC5wdXNoKG9wLnZhbHVlKTsKICAgICAgICByZXR1cm4geyBvcDogInJlbW92ZSIsIHBhdGg6IG9wLnBhdGgucmVwbGFjZSgvLSQvLCAodGFyZ2V0Lmxlbmd0aCAtIDEpLnRvU3RyaW5nKCkpIH07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJDYW4gb25seSBhZGQgdG8gJy0nIGluZGV4Iik7CiAgICAgIH0KICAgIH0KICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoa2V5LCAxMCk7CiAgICBpZiAoaXNOYU4oaW5kZXgpIHx8IGluZGV4IDwgMCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXJyYXkgaW5kZXg6ICR7a2V5fWApOwogICAgfQogICAgaWYgKG9wLm9wID09PSAiYWRkIikgewogICAgICBpZiAoaW5kZXggPiB0YXJnZXQubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoIkluZGV4IG91dCBvZiBib3VuZHMiKTsKICAgICAgdGFyZ2V0LnNwbGljZShpbmRleCwgMCwgb3AudmFsdWUpOwogICAgICByZXR1cm4geyBvcDogInJlbW92ZSIsIHBhdGg6IG9wLnBhdGggfTsKICAgIH0gZWxzZSBpZiAob3Aub3AgPT09ICJyZW1vdmUiKSB7CiAgICAgIGlmIChpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoIkluZGV4IG91dCBvZiBib3VuZHMiKTsKICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRbaW5kZXhdOwogICAgICB0YXJnZXQuc3BsaWNlKGluZGV4LCAxKTsKICAgICAgcmV0dXJuIHsgb3A6ICJhZGQiLCBwYXRoOiBvcC5wYXRoLCB2YWx1ZTogb2xkVmFsdWUgfTsKICAgIH0gZWxzZSBpZiAob3Aub3AgPT09ICJyZXBsYWNlIikgewogICAgICBpZiAoaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCJJbmRleCBvdXQgb2YgYm91bmRzIik7CiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2luZGV4XTsKICAgICAgdGFyZ2V0W2luZGV4XSA9IG9wLnZhbHVlOwogICAgICByZXR1cm4geyBvcDogInJlcGxhY2UiLCBwYXRoOiBvcC5wYXRoLCB2YWx1ZTogb2xkVmFsdWUgfTsKICAgIH0KICB9IGVsc2UgewogICAgaWYgKG9wLm9wID09PSAiYWRkIikgewogICAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldOwogICAgICBjb25zdCBleGlzdGVkID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KTsKICAgICAgdGFyZ2V0W2tleV0gPSBvcC52YWx1ZTsKICAgICAgcmV0dXJuIGV4aXN0ZWQgPyB7IG9wOiAicmVwbGFjZSIsIHBhdGg6IG9wLnBhdGgsIHZhbHVlOiBvbGRWYWx1ZSB9IDogeyBvcDogInJlbW92ZSIsIHBhdGg6IG9wLnBhdGggfTsKICAgIH0gZWxzZSBpZiAob3Aub3AgPT09ICJyZXBsYWNlIikgewogICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGggbm90IGZvdW5kOiAke29wLnBhdGh9YCk7CiAgICAgIH0KICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTsKICAgICAgdGFyZ2V0W2tleV0gPSBvcC52YWx1ZTsKICAgICAgcmV0dXJuIHsgb3A6ICJyZXBsYWNlIiwgcGF0aDogb3AucGF0aCwgdmFsdWU6IG9sZFZhbHVlIH07CiAgICB9IGVsc2UgaWYgKG9wLm9wID09PSAicmVtb3ZlIikgewogICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGggbm90IGZvdW5kOiAke29wLnBhdGh9YCk7CiAgICAgIH0KICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTsKICAgICAgZGVsZXRlIHRhcmdldFtrZXldOwogICAgICByZXR1cm4geyBvcDogImFkZCIsIHBhdGg6IG9wLnBhdGgsIHZhbHVlOiBvbGRWYWx1ZSB9OwogICAgfQogIH0KICByZXR1cm4gbnVsbDsKfQoKLy8gc3JjL3ZlcnNpb24udHMKdmFyIFZFUlNJT04gPSAiMC4yNS4yNSI7CgovLyBzcmMvbGxtLnRzCnZhciBpc0xMTUVuYWJsZWQgPSB0eXBlb2YgX19MTE1fXyAhPT0gInVuZGVmaW5lZCIgPyBfX0xMTV9fIDogdHlwZW9mIF9fREVCVUdfXyA9PT0gInVuZGVmaW5lZCIgfHwgX19ERUJVR19fOwp2YXIgX3Zpc2lvbiA9IChyb290KSA9PiB7CiAgcmV0dXJuIGdldFNlbWFudGljRE9NKHJvb3QgfHwgZG9jdW1lbnQuYm9keSk7Cn07CnZhciBfdHJhbnNhY3QgPSAocGF0Y2gpID0+IHsKICBjb25zdCBhcHBTdGF0ZSA9IGdldEN1cnJlbnRBcHBTdGF0ZSgpOwogIGlmICghYXBwU3RhdGUgfHwgIWFwcFN0YXRlLmFwcCkgewogICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAiTm8gYXBwIHN0YXRlIGZvdW5kIiB9OwogIH0KICByZXR1cm4gYXBwbHlQYXRjaChhcHBTdGF0ZS5hcHAsIHBhdGNoKTsKfTsKdmFyIGxsbUFQSSA9IHsKICAvKioKICAgKiBSZXR1cm5zIGEgbGlnaHR3ZWlnaHQsIHNlbWFudGljIEpTT04gdHJlZSBvZiB0aGUgRE9NLgogICAqIFVzZSB0aGlzIHRvICJzZWUiIHRoZSBVSSBzdHJ1Y3R1cmUsIGF0dHJpYnV0ZXMsIGFuZCB0ZXh0IHdpdGhvdXQKICAgKiB0aGUgbm9pc2Ugb2YgZnVsbCBET00gbm9kZXMuIEhpZGRlbiBlbGVtZW50cyBhbmQgc2NyaXB0cyBhcmUgaWdub3JlZC4KICAgKiAKICAgKiBAcmV0dXJucyB7U2VtYW50aWNOb2RlIHwgbnVsbH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGUgc2VtYW50aWMgdHJlZS4KICAgKi8KICB2aXNpb246IGlzTExNRW5hYmxlZCA/IF92aXNpb24gOiAoKSA9PiBudWxsLAogIC8qKgogICAqIFNhZmVseSBtb2RpZmllcyB0aGUgYXBwIHN0YXRlIHVzaW5nIGEgSlNPTiBQYXRjaCB0cmFuc2FjdGlvbi4KICAgKiBTdXBwb3J0cyBvcGVyYXRpb25zOiAiYWRkIiwgInJlbW92ZSIsICJyZXBsYWNlIiwgInRlc3QiLgogICAqIAogICAqIEFUT01JQ0lUWTogSWYgYW55IG9wZXJhdGlvbiBmYWlscyAoaW5jbHVkaW5nIGEgInRlc3QiKSwgdGhlIGVudGlyZQogICAqIHRyYW5zYWN0aW9uIGlzIHJvbGxlZCBiYWNrLCBhbmQgdGhlIHN0YXRlIHJlbWFpbnMgdW5jaGFuZ2VkLgogICAqIAogICAqIFJFQUNUSVZJVFk6IFN1Y2Nlc3NmdWwgcGF0Y2hlcyBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgRE9NIHVwZGF0ZXMuCiAgICogCiAgICogQHBhcmFtIHtKU09OUGF0Y2hPcFtdfSBwYXRjaCAtIEFycmF5IG9mIHBhdGNoIG9wZXJhdGlvbnMuCiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVzdWx0fSB7IHN1Y2Nlc3M6IHRydWUgfSBvciB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogc3RyaW5nIH0KICAgKi8KICB0cmFuc2FjdDogaXNMTE1FbmFibGVkID8gX3RyYW5zYWN0IDogKCkgPT4gKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAiUHJvZHVjdGlvbiBtb2RlIiB9KSwKICAvKioKICAgKiBSZXR1cm5zIGEgY29tcGFjdCwgTExNLWZyaWVuZGx5IHN1bW1hcnkgb2YgdGhlIGFwcC4KICAgKiBJbmNsdWRlcyBmcmFtZXdvcmsvdmVyc2lvbiwgY29tcG9uZW50IGxpc3QsIGFuZCBzdGF0ZSBwYXRocy4KICAgKi8KICBjb21wYWN0OiBpc0xMTUVuYWJsZWQgPyAoKSA9PiB7CiAgICBjb25zdCBhcHBTdGF0ZSA9IGdldEN1cnJlbnRBcHBTdGF0ZSgpOwogICAgaWYgKCFhcHBTdGF0ZSB8fCAhYXBwU3RhdGUuYXBwKSByZXR1cm4gbnVsbDsKICAgIGNvbnN0IHN0YXRlID0gYXBwU3RhdGUuYXBwOwogICAgY29uc3QgcGF0aHMgPSBmbGF0dGVuKHN0YXRlKS5tYXAoKGVudHJ5KSA9PiBlbnRyeS5wYXRoLmpvaW4oIi4iKSk7CiAgICBjb25zdCBzYW1wbGUgPSB7fTsKICAgIE9iamVjdC5lbnRyaWVzKHN0YXRlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHsKICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7CiAgICAgICAgc2FtcGxlW2tleV0gPSBgWyR7dmFsdWUubGVuZ3RofV1gOwogICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gIm9iamVjdCIpIHsKICAgICAgICBzYW1wbGVba2V5XSA9ICJ7Li4ufSI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgc2FtcGxlW2tleV0gPSB2YWx1ZTsKICAgICAgfQogICAgfSk7CiAgICBjb25zdCBjb21wb25lbnRzID0gQXJyYXkuZnJvbShhcHBTdGF0ZS5pbnRlcm5hbC5jb21wb25lbnRzLmVudHJpZXMoKSkubWFwKChbdGFnLCBsb2dpY10pID0+ICh7IHRhZywgaGFzTG9naWM6IEJvb2xlYW4obG9naWMpIH0pKTsKICAgIHJldHVybiB7CiAgICAgIGZyYW1ld29yazogeyBuYW1lOiAiYm9yZURPTSIsIHZlcnNpb246IFZFUlNJT04gfSwKICAgICAgc3RhdGU6IHsgcGF0aHMsIHNhbXBsZSB9LAogICAgICBjb21wb25lbnRzCiAgICB9OwogIH0gOiAoKSA9PiBudWxsCn07CgovLyBzcmMvYmluZGluZ3MudHMKdmFyIHRvQ2FtZWxDYXNlID0gKHZhbHVlKSA9PiB2YWx1ZS5yZXBsYWNlKC8tKFthLXpdKS9nLCAoXywgY2hhcikgPT4gY2hhci50b1VwcGVyQ2FzZSgpKTsKdmFyIHBhcnNlUGF0aDIgPSAocmF3KSA9PiB7CiAgY29uc3Qgbm9ybWFsaXplZCA9IHJhdy5yZXBsYWNlKC9cWyhcZCspXF0vZywgIi4kMSIpLnJlcGxhY2UoL15cLi8sICIiKTsKICByZXR1cm4gbm9ybWFsaXplZC5zcGxpdCgiLiIpLmZpbHRlcihCb29sZWFuKTsKfTsKdmFyIHJlc29sdmVQYXRoID0gKHRhcmdldCwgcmF3KSA9PiB7CiAgaWYgKHRhcmdldCA9PT0gdm9pZCAwIHx8IHRhcmdldCA9PT0gbnVsbCkgcmV0dXJuIHZvaWQgMDsKICBjb25zdCBwYXRoID0gcGFyc2VQYXRoMihyYXcpOwogIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRhcmdldDsKICByZXR1cm4gYWNjZXNzKHBhdGgsIHRhcmdldCk7Cn07CnZhciByZXNvbHZlVmFsdWUgPSAoZXhwciwgc2NvcGUpID0+IHsKICBjb25zdCByYXcgPSBleHByLnRyaW0oKTsKICBpZiAoIXJhdykgcmV0dXJuIHZvaWQgMDsKICBpZiAocmF3ID09PSAiaW5kZXgiIHx8IHJhdyA9PT0gImkiKSByZXR1cm4gc2NvcGUuaW5kZXg7CiAgaWYgKHJhdyA9PT0gIml0ZW0iKSByZXR1cm4gc2NvcGUuaXRlbTsKICBpZiAocmF3ID09PSAiZGV0YWlsIikgcmV0dXJuIHNjb3BlLmRldGFpbDsKICBpZiAocmF3ID09PSAic2VsZiIpIHJldHVybiBzY29wZS5zZWxmOwogIGlmIChyYXcuc3RhcnRzV2l0aCgic3RhdGUuIikpIHJldHVybiByZXNvbHZlUGF0aChzY29wZS5zdGF0ZSwgcmF3LnNsaWNlKDYpKTsKICBpZiAocmF3LnN0YXJ0c1dpdGgoIml0ZW0uIikpIHJldHVybiByZXNvbHZlUGF0aChzY29wZS5pdGVtLCByYXcuc2xpY2UoNSkpOwogIGlmIChyYXcuc3RhcnRzV2l0aCgiZGV0YWlsLiIpKSByZXR1cm4gcmVzb2x2ZVBhdGgoc2NvcGUuZGV0YWlsLCByYXcuc2xpY2UoNykpOwogIGlmIChyYXcuc3RhcnRzV2l0aCgic2VsZi4iKSkgcmV0dXJuIHJlc29sdmVQYXRoKHNjb3BlLnNlbGYsIHJhdy5zbGljZSg1KSk7CiAgcmV0dXJuIHJlc29sdmVQYXRoKHNjb3BlLnN0YXRlLCByYXcpOwp9Owp2YXIgY29sbGVjdEVsZW1lbnRzID0gKHJvb3QpID0+IHsKICBjb25zdCBlbGVtZW50cyA9IFtdOwogIGlmIChyb290IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkgewogICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcigKICAgICAgcm9vdCwKICAgICAgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQKICAgICk7CiAgICB3aGlsZSAod2Fsa2VyLm5leHROb2RlKCkpIHsKICAgICAgZWxlbWVudHMucHVzaCh3YWxrZXIuY3VycmVudE5vZGUpOwogICAgfQogICAgcmV0dXJuIGVsZW1lbnRzOwogIH0KICBlbGVtZW50cy5wdXNoKHJvb3QpOwogIHJvb3QudHJhdmVyc2UoKGVsZW0pID0+IHsKICAgIGVsZW1lbnRzLnB1c2goZWxlbSk7CiAgfSwgeyB0cmF2ZXJzZVNoYWRvd1Jvb3Q6IHRydWUgfSk7CiAgcmV0dXJuIGVsZW1lbnRzOwp9Owp2YXIgZ2V0Q2xhc3NCYXNlID0gKGVsZW1lbnQpID0+IHsKICBjb25zdCBzdG9yZWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgiZGF0YS1jbGFzcy1iYXNlIik7CiAgaWYgKHN0b3JlZCAhPT0gbnVsbCkgcmV0dXJuIHN0b3JlZDsKICBjb25zdCBiYXNlID0gZWxlbWVudC5jbGFzc05hbWU7CiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoImRhdGEtY2xhc3MtYmFzZSIsIGJhc2UpOwogIHJldHVybiBiYXNlOwp9Owp2YXIgYXBwbHlDbGFzc0JpbmRpbmcgPSAoZWxlbWVudCwgZXhwciwgc2NvcGUpID0+IHsKICBjb25zdCBiYXNlID0gZ2V0Q2xhc3NCYXNlKGVsZW1lbnQpOwogIGlmIChleHByLmluY2x1ZGVzKCI6IikpIHsKICAgIGNvbnN0IHRvZ2dsZWQgPSBbXTsKICAgIGV4cHIuc3BsaXQoIiwiKS5mb3JFYWNoKChwYXJ0KSA9PiB7CiAgICAgIGNvbnN0IFtuYW1lLCB2YWx1ZUV4cHJdID0gcGFydC5zcGxpdCgiOiIpLm1hcCgocykgPT4gcy50cmltKCkpOwogICAgICBpZiAoIW5hbWUgfHwgIXZhbHVlRXhwcikgcmV0dXJuOwogICAgICBpZiAocmVzb2x2ZVZhbHVlKHZhbHVlRXhwciwgc2NvcGUpKSB7CiAgICAgICAgdG9nZ2xlZC5wdXNoKG5hbWUpOwogICAgICB9CiAgICB9KTsKICAgIGNvbnN0IGNvbWJpbmVkID0gW2Jhc2UsIC4uLnRvZ2dsZWRdLmZpbHRlcihCb29sZWFuKS5qb2luKCIgIikudHJpbSgpOwogICAgZWxlbWVudC5jbGFzc05hbWUgPSBjb21iaW5lZDsKICAgIHJldHVybjsKICB9CiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlVmFsdWUoZXhwciwgc2NvcGUpOwogIGlmICh0eXBlb2YgcmVzb2x2ZWQgPT09ICJzdHJpbmciKSB7CiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFtiYXNlLCByZXNvbHZlZF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oIiAiKS50cmltKCk7CiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc29sdmVkKSkgewogICAgZWxlbWVudC5jbGFzc05hbWUgPSBbYmFzZSwgcmVzb2x2ZWQuam9pbigiICIpXS5maWx0ZXIoQm9vbGVhbikuam9pbigiICIpLnRyaW0oKTsKICB9IGVsc2UgaWYgKHJlc29sdmVkICYmIHR5cGVvZiByZXNvbHZlZCA9PT0gIm9iamVjdCIpIHsKICAgIGNvbnN0IHRvZ2dsZWQgPSBPYmplY3QuZW50cmllcyhyZXNvbHZlZCkuZmlsdGVyKChbLCB2YWx1ZV0pID0+IEJvb2xlYW4odmFsdWUpKS5tYXAoKFtuYW1lXSkgPT4gbmFtZSk7CiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFtiYXNlLCAuLi50b2dnbGVkXS5maWx0ZXIoQm9vbGVhbikuam9pbigiICIpLnRyaW0oKTsKICB9IGVsc2UgewogICAgZWxlbWVudC5jbGFzc05hbWUgPSBiYXNlLnRyaW0oKTsKICB9Cn07CnZhciBhcHBseUF0dHJpYnV0ZUJpbmRpbmdzID0gKGVsZW1lbnRzLCBzY29wZSkgPT4gewogIGNvbnN0IHNraXBMaXN0SXRlbXMgPSBzY29wZS5pdGVtID09PSB2b2lkIDA7CiAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4gewogICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVGVtcGxhdGVFbGVtZW50KSByZXR1cm47CiAgICBpZiAoc2tpcExpc3RJdGVtcyAmJiBlbGVtZW50LmNsb3Nlc3QoIltkYXRhLWxpc3QtaXRlbV0iKSkgcmV0dXJuOwogICAgY29uc3QgdGV4dEJpbmRpbmcgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgiZGF0YS10ZXh0Iik7CiAgICBpZiAodGV4dEJpbmRpbmcpIHsKICAgICAgY29uc3QgdmFsdWUgPSByZXNvbHZlVmFsdWUodGV4dEJpbmRpbmcsIHNjb3BlKTsKICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IG51bGwgPyAiIiA6IFN0cmluZyh2YWx1ZSk7CiAgICB9CiAgICBjb25zdCBzaG93QmluZGluZyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCJkYXRhLXNob3ciKTsKICAgIGlmIChzaG93QmluZGluZykgewogICAgICBlbGVtZW50LmhpZGRlbiA9ICFCb29sZWFuKHJlc29sdmVWYWx1ZShzaG93QmluZGluZywgc2NvcGUpKTsKICAgIH0KICAgIGNvbnN0IGNsYXNzQmluZGluZyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCJkYXRhLWNsYXNzIik7CiAgICBpZiAoY2xhc3NCaW5kaW5nKSB7CiAgICAgIGFwcGx5Q2xhc3NCaW5kaW5nKGVsZW1lbnQsIGNsYXNzQmluZGluZywgc2NvcGUpOwogICAgfQogICAgY29uc3QgdmFsdWVCaW5kaW5nID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoImRhdGEtdmFsdWUiKTsKICAgIGlmICh2YWx1ZUJpbmRpbmcgJiYgInZhbHVlIiBpbiBlbGVtZW50KSB7CiAgICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZVZhbHVlKHZhbHVlQmluZGluZywgc2NvcGUpOwogICAgICBlbGVtZW50LnZhbHVlID0gdmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCA/ICIiIDogU3RyaW5nKHZhbHVlKTsKICAgIH0KICAgIGNvbnN0IGNoZWNrZWRCaW5kaW5nID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoImRhdGEtY2hlY2tlZCIpOwogICAgaWYgKGNoZWNrZWRCaW5kaW5nICYmICJjaGVja2VkIiBpbiBlbGVtZW50KSB7CiAgICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZVZhbHVlKGNoZWNrZWRCaW5kaW5nLCBzY29wZSk7CiAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IEJvb2xlYW4odmFsdWUpOwogICAgfQogICAgY29uc3QgcHJvcEF0dHJpYnV0ZXMgPSBBcnJheS5mcm9tKGVsZW1lbnQuYXR0cmlidXRlcykuZmlsdGVyKChhdHRyKSA9PiBhdHRyLm5hbWUuc3RhcnRzV2l0aCgiZGF0YS1wcm9wLSIpKTsKICAgIGlmIChwcm9wQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7CiAgICAgIGxldCBkZXRhaWxDaGFuZ2VkID0gZmFsc2U7CiAgICAgIHByb3BBdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHsKICAgICAgICBjb25zdCBwcm9wTmFtZSA9IGF0dHIubmFtZS5zbGljZSgiZGF0YS1wcm9wLSIubGVuZ3RoKTsKICAgICAgICBpZiAoIXByb3BOYW1lKSByZXR1cm47CiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlVmFsdWUoYXR0ci52YWx1ZSwgc2NvcGUpOwogICAgICAgIGNvbnN0IGRhdGFBdHRyaWJ1dGUgPSBgZGF0YS0ke3Byb3BOYW1lfWA7CiAgICAgICAgY29uc3QgY3VycmVudCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGRhdGFBdHRyaWJ1dGUpOwogICAgICAgIGNvbnN0IGlzQXR0cmlidXRlVmFsdWUgPSByZXNvbHZlZCA9PT0gdm9pZCAwIHx8IHJlc29sdmVkID09PSBudWxsIHx8IHR5cGVvZiByZXNvbHZlZCA9PT0gInN0cmluZyIgfHwgdHlwZW9mIHJlc29sdmVkID09PSAibnVtYmVyIiB8fCB0eXBlb2YgcmVzb2x2ZWQgPT09ICJib29sZWFuIjsKICAgICAgICBjb25zdCBuZXh0ID0gaXNBdHRyaWJ1dGVWYWx1ZSAmJiByZXNvbHZlZCAhPT0gdm9pZCAwICYmIHJlc29sdmVkICE9PSBudWxsID8gU3RyaW5nKHJlc29sdmVkKSA6IG51bGw7CiAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHsKICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7CiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGRhdGFBdHRyaWJ1dGUpOwogICAgICAgICAgICBkZXRhaWxDaGFuZ2VkID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQgIT09IG5leHQpIHsKICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGRhdGFBdHRyaWJ1dGUsIG5leHQpOwogICAgICAgICAgZGV0YWlsQ2hhbmdlZCA9IHRydWU7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGRldGFpbEtleSA9IHRvQ2FtZWxDYXNlKHByb3BOYW1lKTsKICAgICAgICBjb25zdCBkZXRhaWwgPSBlbGVtZW50Ll9fYm9yZURPTURldGFpbDsKICAgICAgICBpZiAoZGV0YWlsKSB7CiAgICAgICAgICBpZiAoIWRldGFpbC5kYXRhKSBkZXRhaWwuZGF0YSA9IHt9OwogICAgICAgICAgaWYgKGRldGFpbC5kYXRhW2RldGFpbEtleV0gIT09IHJlc29sdmVkKSB7CiAgICAgICAgICAgIGRldGFpbC5kYXRhW2RldGFpbEtleV0gPSByZXNvbHZlZDsKICAgICAgICAgICAgZGV0YWlsQ2hhbmdlZCA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9KTsKICAgICAgaWYgKGRldGFpbENoYW5nZWQpIHsKICAgICAgICBjb25zdCByZXJlbmRlciA9IGVsZW1lbnQuX19ib3JlRE9NUmVyZW5kZXI7CiAgICAgICAgaWYgKHR5cGVvZiByZXJlbmRlciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcmVyZW5kZXIoKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9KTsKfTsKdmFyIGFwcGx5TGlzdEJpbmRpbmcgPSAoZWxlbWVudCwgc2NvcGUpID0+IHsKICBjb25zdCBsaXN0RXhwciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCJkYXRhLWxpc3QiKTsKICBpZiAoIWxpc3RFeHByKSByZXR1cm47CiAgY29uc3QgdGVtcGxhdGUgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoInRlbXBsYXRlW2RhdGEtaXRlbV0iKTsKICBpZiAoISh0ZW1wbGF0ZSBpbnN0YW5jZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQpKSByZXR1cm47CiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlVmFsdWUobGlzdEV4cHIsIHNjb3BlKTsKICBjb25zdCBpdGVtcyA9IEFycmF5LmlzQXJyYXkocmVzb2x2ZWQpID8gcmVzb2x2ZWQgOiBbXTsKICBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGRyZW4pLmZvckVhY2goKGNoaWxkKSA9PiB7CiAgICBpZiAoY2hpbGQuaGFzQXR0cmlidXRlKCJkYXRhLWxpc3QtaXRlbSIpKSB7CiAgICAgIGNoaWxkLnJlbW92ZSgpOwogICAgfQogIH0pOwogIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpOwogIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7CiAgICBjb25zdCBjbG9uZSA9IHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpOwogICAgQXJyYXkuZnJvbShjbG9uZS5jaGlsZE5vZGVzKS5mb3JFYWNoKChub2RlKSA9PiB7CiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgewogICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCJkYXRhLWxpc3QtaXRlbSIsICIiKTsKICAgICAgfQogICAgfSk7CiAgICBhcHBseUJpbmRpbmdzVG9GcmFnbWVudChjbG9uZSwgeyAuLi5zY29wZSwgaXRlbSwgaW5kZXggfSk7CiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjbG9uZSk7CiAgfSk7CiAgZWxlbWVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7Cn07CnZhciBhcHBseUJpbmRpbmdzVG9GcmFnbWVudCA9IChmcmFnbWVudCwgc2NvcGUpID0+IHsKICBsZXQgZWxlbWVudHMgPSBjb2xsZWN0RWxlbWVudHMoZnJhZ21lbnQpOwogIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IGFwcGx5TGlzdEJpbmRpbmcoZWxlbWVudCwgc2NvcGUpKTsKICBlbGVtZW50cyA9IGNvbGxlY3RFbGVtZW50cyhmcmFnbWVudCk7CiAgYXBwbHlBdHRyaWJ1dGVCaW5kaW5ncyhlbGVtZW50cywgc2NvcGUpOwp9Owp2YXIgYXBwbHlCaW5kaW5ncyA9IChyb290LCBzY29wZSkgPT4gewogIGxldCBlbGVtZW50cyA9IGNvbGxlY3RFbGVtZW50cyhyb290KTsKICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiBhcHBseUxpc3RCaW5kaW5nKGVsZW1lbnQsIHNjb3BlKSk7CiAgZWxlbWVudHMgPSBjb2xsZWN0RWxlbWVudHMocm9vdCk7CiAgYXBwbHlBdHRyaWJ1dGVCaW5kaW5ncyhlbGVtZW50cywgc2NvcGUpOwp9OwoKLy8gc3JjL2luZGV4LnRzCnZhciBoYXNMb2dnZWRWZXJzaW9uID0gZmFsc2U7CnZhciBkZWJ1Z0FwaUVuYWJsZWQgPSB0eXBlb2YgX19ERUJVR19fID09PSAidW5kZWZpbmVkIiB8fCBfX0RFQlVHX187CnZhciBodG1sID0gKHN0cmluZ3MsIC4uLnZhbHVlcykgPT4gewogIGxldCByZXN1bHQgPSAiIjsKICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpKyspIHsKICAgIHJlc3VsdCArPSBzdHJpbmdzW2ldOwogICAgaWYgKGkgPCB2YWx1ZXMubGVuZ3RoKSByZXN1bHQgKz0gU3RyaW5nKHZhbHVlc1tpXSk7CiAgfQogIHJldHVybiByZXN1bHQ7Cn07CmZ1bmN0aW9uIGNvbXBvbmVudDIodGFnTmFtZSwgdGVtcGxhdGUsIGluaXRGdW5jdGlvbikgewogIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICJ1bmRlZmluZWQiKSB7CiAgICBjb25zdCBleGlzdGluZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoCiAgICAgIGB0ZW1wbGF0ZVtkYXRhLWNvbXBvbmVudD0iJHt0YWdOYW1lfSJdYAogICAgKTsKICAgIGlmIChleGlzdGluZykgewogICAgICBleGlzdGluZy5pbm5lckhUTUwgPSB0ZW1wbGF0ZTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbnN0IHRlbXBsYXRlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZW1wbGF0ZSIpOwogICAgICB0ZW1wbGF0ZUVsLnNldEF0dHJpYnV0ZSgiZGF0YS1jb21wb25lbnQiLCB0YWdOYW1lKTsKICAgICAgdGVtcGxhdGVFbC5pbm5lckhUTUwgPSB0ZW1wbGF0ZTsKICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wbGF0ZUVsKTsKICAgIH0KICB9CiAgcmV0dXJuIHdlYkNvbXBvbmVudChpbml0RnVuY3Rpb24pOwp9CnZhciBib3JlRE9NID0gewogIC8qKiBNYXAgb2YgYWxsIGN1cnJlbnQgZXJyb3JzIGJ5IGNvbXBvbmVudCBuYW1lICovCiAgZ2V0IGVycm9ycygpIHsKICAgIHJldHVybiBkZWJ1Z0FQSS5lcnJvcnM7CiAgfSwKICAvKiogTW9zdCByZWNlbnQgZXJyb3IgY29udGV4dCAqLwogIGdldCBsYXN0RXJyb3IoKSB7CiAgICByZXR1cm4gZGVidWdBUEkubGFzdEVycm9yOwogIH0sCiAgLyoqIFJlLXJlbmRlciBhIHNwZWNpZmljIGNvbXBvbmVudCBvciB0aGUgbGFzdCBlcnJvcmVkIG9uZSAqLwogIHJlcmVuZGVyOiBkZWJ1Z0FQSS5yZXJlbmRlciwKICAvKiogQ2xlYXIgZXJyb3Igc3RhdGUgZm9yIGEgY29tcG9uZW50ICovCiAgY2xlYXJFcnJvcjogZGVidWdBUEkuY2xlYXJFcnJvciwKICAvKiogRXhwb3J0IHN0YXRlIHNuYXBzaG90ICovCiAgZXhwb3J0OiBkZWJ1Z0FQSS5leHBvcnQsCiAgLyoqIEN1cnJlbnQgZGVidWcgY29uZmlndXJhdGlvbiAocmVhZC1vbmx5KSAqLwogIGdldCBjb25maWcoKSB7CiAgICByZXR1cm4gZGVidWdBUEkuY29uZmlnOwogIH0sCiAgLyoqIEBpbnRlcm5hbCBTZXQgZGVidWcgY29uZmlndXJhdGlvbiAodXNlZCBieSB0ZXN0cyB3aXRoIG11bHRpcGxlIGJ1bmRsZXMpICovCiAgX3NldERlYnVnQ29uZmlnOiBzZXREZWJ1Z0NvbmZpZywKICAvKiogRnJhbWV3b3JrIHZlcnNpb24gKi8KICB2ZXJzaW9uOiBWRVJTSU9OLAogIC8vIExMTSBJbnRlZ3JhdGlvbiBBUEkgKFBoYXNlIDQpCiAgLyoqIExMTSBjb250ZXh0IGFuZCBvdXRwdXQgdXRpbGl0aWVzICovCiAgbGxtOiBsbG1BUEksCiAgLyoqIENyZWF0ZSBhIHRlbXBsYXRlLWJhY2tlZCBjb21wb25lbnQgaW4gc2luZ2xlLWZpbGUgbW9kZSAqLwogIGNvbXBvbmVudDogY29tcG9uZW50MiwKICAvKiogVGVtcGxhdGUgbGl0ZXJhbCBoZWxwZXIgZm9yIEhUTUwgc3RyaW5ncyAqLwogIGh0bWwKfTsKaWYgKGRlYnVnQXBpRW5hYmxlZCkgewogIE9iamVjdC5hc3NpZ24oYm9yZURPTSwgewogICAgLyoqIERlZmluZSBhIG5ldyBjb21wb25lbnQgYXQgcnVudGltZSAqLwogICAgZGVmaW5lOiBjb25zb2xlQVBJLmRlZmluZSwKICAgIC8qKiBHZXQgbGl2ZSBhY2Nlc3MgdG8gYSBjb21wb25lbnQncyBpbnRlcm5hbHMgKi8KICAgIG9wZXJhdGU6IGNvbnNvbGVBUEkub3BlcmF0ZSwKICAgIC8qKiBFeHBvcnQgY29tcG9uZW50IHN0YXRlIGFuZCB0ZW1wbGF0ZSAqLwogICAgZXhwb3J0Q29tcG9uZW50OiBjb25zb2xlQVBJLmV4cG9ydENvbXBvbmVudCwKICAgIC8qKiBEZWZpbmUgYSBoZWxwZXIgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGFsbCByZW5kZXIgZnVuY3Rpb25zICovCiAgICBkZWZpbmVIZWxwZXI6IGluc2lkZU91dEFQSS5kZWZpbmVIZWxwZXIsCiAgICAvKiogQ2xlYXIgYSBoZWxwZXIgZGVmaW5pdGlvbiAqLwogICAgY2xlYXJIZWxwZXI6IGluc2lkZU91dEFQSS5jbGVhckhlbHBlciwKICAgIC8qKiBDbGVhciBhbGwgbWlzc2luZyBmdW5jdGlvbiByZWNvcmRzICovCiAgICBjbGVhck1pc3NpbmdGdW5jdGlvbnM6IGluc2lkZU91dEFQSS5jbGVhck1pc3NpbmdGdW5jdGlvbnMsCiAgICAvKiogTWFudWFsbHkgaW5mZXIgdGVtcGxhdGUgZm9yIGEgdGFnICovCiAgICBpbmZlclRlbXBsYXRlOiBpbnNpZGVPdXRBUEkuaW5mZXJUZW1wbGF0ZQogIH0pOwogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGJvcmVET00sIHsKICAgIC8qKiBNYXAgb2YgbWlzc2luZyBmdW5jdGlvbiBjYWxscyBieSBmdW5jdGlvbiBuYW1lICovCiAgICBtaXNzaW5nRnVuY3Rpb25zOiB7CiAgICAgIGdldDogKCkgPT4gaW5zaWRlT3V0QVBJLm1pc3NpbmdGdW5jdGlvbnMKICAgIH0sCiAgICAvKiogTW9zdCByZWNlbnQgbWlzc2luZyBmdW5jdGlvbiBjb250ZXh0ICovCiAgICBsYXN0TWlzc2luZzogewogICAgICBnZXQ6ICgpID0+IGluc2lkZU91dEFQSS5sYXN0TWlzc2luZwogICAgfSwKICAgIC8qKiBHZXQgYWxsIGRlZmluZWQgaGVscGVycyAqLwogICAgaGVscGVyczogewogICAgICBnZXQ6ICgpID0+IGluc2lkZU91dEFQSS5oZWxwZXJzCiAgICB9LAogICAgLyoqIE1hcCBvZiBpbmZlcnJlZCB0ZW1wbGF0ZXMgYnkgdGFnIG5hbWUgKi8KICAgIGluZmVycmVkVGVtcGxhdGVzOiB7CiAgICAgIGdldDogKCkgPT4gaW5zaWRlT3V0QVBJLmluZmVycmVkVGVtcGxhdGVzCiAgICB9CiAgfSk7Cn0KaWYgKHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiKSB7CiAgd2luZG93LmJvcmVET00gPSBib3JlRE9NOwogIHdpbmRvdy5kaXNwYXRjaCA9IGRpc3BhdGNoOwp9CmFzeW5jIGZ1bmN0aW9uIGluZmxpY3RCb3JlRE9NKHN0YXRlLCBjb21wb25lbnRzTG9naWMsIGNvbmZpZykgewogIGlmIChjb25maWc/LmRlYnVnICE9PSB2b2lkIDApIHsKICAgIHNldERlYnVnQ29uZmlnKGNvbmZpZy5kZWJ1Zyk7CiAgfQogIGlmICghaGFzTG9nZ2VkVmVyc2lvbiAmJiBpc0RlYnVnRW5hYmxlZCgidmVyc2lvbkxvZyIpKSB7CiAgICBoYXNMb2dnZWRWZXJzaW9uID0gdHJ1ZTsKICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIGNvbnNvbGUuaW5mbyA9PT0gImZ1bmN0aW9uIikgewogICAgfQogIH0KICBjb25zdCB3cmFwcGVyID0gKGZuKSA9PiB7CiAgICBpZiAoZm4gJiYgZm5bV0VCX0NPTVBPTkVOVF9NQVJLRVJdKSB7CiAgICAgIHJldHVybiBmbjsKICAgIH0KICAgIGlmICh0eXBlb2YgZm4gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgcmV0dXJuIHdlYkNvbXBvbmVudChmbik7CiAgICB9CiAgICByZXR1cm4gZm47CiAgfTsKICBjb25zdCBpc1NpbmdsZUZpbGVCdWlsZCA9IHR5cGVvZiBfX1NJTkdMRV9GSUxFX18gIT09ICJ1bmRlZmluZWQiICYmIF9fU0lOR0xFX0ZJTEVfXzsKICBjb25zdCBzaW5nbGVGaWxlID0gY29uZmlnPy5zaW5nbGVGaWxlID8/IGlzU2luZ2xlRmlsZUJ1aWxkOwogIGNvbnN0IHsgbmFtZXM6IHJlZ2lzdGVyZWROYW1lcywgaW5saW5lTG9naWMgfSA9IGF3YWl0IHJlZ2lzdGVyVGVtcGxhdGVzKAogICAgd3JhcHBlciwKICAgIHsKICAgICAgbWlycm9yQXR0cmlidXRlczogY29uZmlnPy5taXJyb3JBdHRyaWJ1dGVzCiAgICB9CiAgKTsKICBjb25zdCBjb21wb25lbnRzQ29kZSA9IHNpbmdsZUZpbGUgPyAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIDogYXdhaXQgZHluYW1pY0ltcG9ydFNjcmlwdHMocmVnaXN0ZXJlZE5hbWVzKTsKICBpZiAoaW5saW5lTG9naWMpIHsKICAgIGZvciAoY29uc3QgW3RhZ05hbWUsIGxvZ2ljXSBvZiBpbmxpbmVMb2dpYykgewogICAgICBpZiAoIWNvbXBvbmVudHNDb2RlLmhhcyh0YWdOYW1lKSB8fCBjb21wb25lbnRzQ29kZS5nZXQodGFnTmFtZSkgPT09IG51bGwpIHsKICAgICAgICBjb21wb25lbnRzQ29kZS5zZXQodGFnTmFtZSwgbG9naWMpOwogICAgICB9CiAgICB9CiAgfQogIGlmIChjb21wb25lbnRzTG9naWMpIHsKICAgIGZvciAoY29uc3QgdGFnTmFtZSBvZiBPYmplY3Qua2V5cyhjb21wb25lbnRzTG9naWMpKSB7CiAgICAgIGNvbXBvbmVudHNDb2RlLnNldCh0YWdOYW1lLCBjb21wb25lbnRzTG9naWNbdGFnTmFtZV0pOwogICAgfQogIH0KICBmb3IgKGNvbnN0IG5hbWUgb2YgcmVnaXN0ZXJlZE5hbWVzKSB7CiAgICBpZiAoIWNvbXBvbmVudHNDb2RlLmhhcyhuYW1lKSB8fCBjb21wb25lbnRzQ29kZS5nZXQobmFtZSkgPT09IG51bGwpIHsKICAgICAgY29tcG9uZW50c0NvZGUuc2V0KG5hbWUsIHdlYkNvbXBvbmVudCgoKSA9PiAoKSA9PiB7CiAgICAgIH0pKTsKICAgIH0KICB9CiAgY29uc3QgaW5pdGlhbFN0YXRlID0gewogICAgYXBwOiBzdGF0ZSwKICAgIGludGVybmFsOiB7CiAgICAgIGN1c3RvbVRhZ3M6IHJlZ2lzdGVyZWROYW1lcywKICAgICAgY29tcG9uZW50czogY29tcG9uZW50c0NvZGUsCiAgICAgIHVwZGF0ZXM6IHsKICAgICAgICBwYXRoOiBbXSwKICAgICAgICB2YWx1ZTogW10sCiAgICAgICAgcmFmOiB2b2lkIDAsCiAgICAgICAgc3Vic2NyaWJlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkKICAgICAgfQogICAgfQogIH07CiAgY29uc3QgcHJveGlmaWVkU3RhdGUgPSBwcm94aWZ5KGluaXRpYWxTdGF0ZSk7CiAgcHJveGlmaWVkU3RhdGUuaW50ZXJuYWwudXBkYXRlcy5wYXRoID0gW107CiAgcHJveGlmaWVkU3RhdGUuaW50ZXJuYWwudXBkYXRlcy52YWx1ZSA9IFtdOwogIGlmIChwcm94aWZpZWRTdGF0ZS5pbnRlcm5hbC51cGRhdGVzLnJhZikgewogICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocHJveGlmaWVkU3RhdGUuaW50ZXJuYWwudXBkYXRlcy5yYWYpOwogICAgcHJveGlmaWVkU3RhdGUuaW50ZXJuYWwudXBkYXRlcy5yYWYgPSB2b2lkIDA7CiAgfQogIHNldEN1cnJlbnRBcHBTdGF0ZShwcm94aWZpZWRTdGF0ZSwgd2ViQ29tcG9uZW50LCByZWdpc3RlckNvbXBvbmVudCk7CiAgcnVuQ29tcG9uZW50c0luaXRpYWxpemVyKHByb3hpZmllZFN0YXRlKTsKICBvYnNlcnZlVW5kZWZpbmVkRWxlbWVudHMoKTsKICByZXR1cm4gcHJveGlmaWVkU3RhdGUuYXBwOwp9CmZ1bmN0aW9uIHdlYkNvbXBvbmVudChpbml0RnVuY3Rpb24pIHsKICBjb25zdCByZXN1bHQgPSAoYXBwU3RhdGUsIGRldGFpbCkgPT4gKGMpID0+IHsKICAgIGNvbnN0IHsgaW50ZXJuYWwsIGFwcCB9ID0gYXBwU3RhdGU7CiAgICBsZXQgbG9nID0gW107CiAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZVN0YXRlQWNjZXNzb3IoYXBwLCBsb2csIHRydWUpOwogICAgY29uc3QgcmVmcyA9IGNyZWF0ZVJlZnNBY2Nlc3NvcihjKTsKICAgIGNvbnN0IHNsb3RzID0gY3JlYXRlU2xvdHNBY2Nlc3NvcihjKTsKICAgIGNvbnN0IG9uID0gY3JlYXRlRXZlbnRzSGFuZGxlcihjLCBhcHAsIGRldGFpbCk7CiAgICBsZXQgcmVuZGVyRnVuY3Rpb247CiAgICBjLnN0YXRlID0gc3RhdGU7CiAgICBjLnJlZnMgPSByZWZzOwogICAgYy5zbG90cyA9IHNsb3RzOwogICAgY29uc3QgdXBkYXRlU3Vic2NyaWJlcnMgPSBhc3luYyAoKSA9PiB7CiAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gaW50ZXJuYWwudXBkYXRlcy5zdWJzY3JpYmVyczsKICAgICAgZm9yIChsZXQgcGF0aCBvZiBsb2cpIHsKICAgICAgICBjb25zdCBmdW5jdGlvbnMgPSBzdWJzY3JpYmVycy5nZXQocGF0aCk7CiAgICAgICAgaWYgKGZ1bmN0aW9ucykgewogICAgICAgICAgaWYgKCFmdW5jdGlvbnMuaW5jbHVkZXMocmVuZGVyRnVuY3Rpb24pKSB7CiAgICAgICAgICAgIGZ1bmN0aW9ucy5wdXNoKHJlbmRlckZ1bmN0aW9uKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3Vic2NyaWJlcnMuc2V0KHBhdGgsIFtyZW5kZXJGdW5jdGlvbl0pOwogICAgICAgIH0KICAgICAgfQogICAgfTsKICAgIGxldCB1c2VyRGVmaW5lZFJlbmRlcmVyOwogICAgdHJ5IHsKICAgICAgdXNlckRlZmluZWRSZW5kZXJlciA9IGluaXRGdW5jdGlvbih7CiAgICAgICAgZGV0YWlsLAogICAgICAgIHN0YXRlLAogICAgICAgIHJlZnMsCiAgICAgICAgb24sCiAgICAgICAgc2VsZjogYywKICAgICAgICBtYWtlQ29tcG9uZW50OiAodGFnLCBvcHRzKSA9PiB7CiAgICAgICAgICByZXR1cm4gY3JlYXRlQW5kUnVuQ29kZSh0YWcsIGFwcFN0YXRlLCBvcHRzPy5kZXRhaWwpOwogICAgICAgIH0KICAgICAgfSk7CiAgICB9IGNhdGNoIChlcnJvcikgewogICAgICBjb25zdCBlcnIgPSBlcnJvcjsKICAgICAgaWYgKGlzRGVidWdFbmFibGVkKCJjb25zb2xlIikpIHsKICAgICAgICBsb2dJbml0RXJyb3IoZGV0YWlsPy5uYW1lID8/IGMudGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBlcnIpOwogICAgICB9CiAgICAgIHVzZXJEZWZpbmVkUmVuZGVyZXIgPSAoKSA9PiB7CiAgICAgIH07CiAgICB9CiAgICByZW5kZXJGdW5jdGlvbiA9IChyZW5kZXJTdGF0ZSkgPT4gewogICAgICBjb25zdCBjb21wb25lbnROYW1lID0gZGV0YWlsPy5uYW1lID8/IGMudGFnTmFtZS50b0xvd2VyQ2FzZSgpOwogICAgICBjb25zdCBoZWxwZXJzID0gY3JlYXRlUmVuZGVySGVscGVycygKICAgICAgICBjb21wb25lbnROYW1lLAogICAgICAgIGMsCiAgICAgICAgKCkgPT4gcmVuZGVyRnVuY3Rpb24ocmVuZGVyU3RhdGUpCiAgICAgICk7CiAgICAgIGNvbnN0IHJlbmRlckFjY2Vzc29yID0gY3JlYXRlU3RhdGVBY2Nlc3NvcihyZW5kZXJTdGF0ZSwgbG9nLCBmYWxzZSk7CiAgICAgIGlmIChpc0RlYnVnRW5hYmxlZCgiZXJyb3JCb3VuZGFyeSIpKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHVzZXJEZWZpbmVkUmVuZGVyZXIoewogICAgICAgICAgICBzdGF0ZTogcmVuZGVyQWNjZXNzb3IsCiAgICAgICAgICAgIHJlZnMsCiAgICAgICAgICAgIHNsb3RzLAogICAgICAgICAgICBzZWxmOiBjLAogICAgICAgICAgICBkZXRhaWwsCiAgICAgICAgICAgIG1ha2VDb21wb25lbnQ6ICh0YWcsIG9wdHMpID0+IHsKICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQW5kUnVuQ29kZSh0YWcsIGFwcFN0YXRlLCBvcHRzPy5kZXRhaWwpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBoZWxwZXJzCiAgICAgICAgICB9KTsKICAgICAgICAgIGFwcGx5QmluZGluZ3MoYywgeyBzdGF0ZTogcmVuZGVyQWNjZXNzb3IsIGRldGFpbCwgc2VsZjogYyB9KTsKICAgICAgICAgIHVwZGF0ZVN1YnNjcmliZXJzKCk7CiAgICAgICAgICBjbGVhckNvbXBvbmVudEVycm9yTWFyayhjKTsKICAgICAgICAgIGNsZWFyRXJyb3IoY29tcG9uZW50TmFtZSk7CiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgIGNvbnN0IGVyciA9IGVycm9yOwogICAgICAgICAgY29uc3QgY3R4ID0gewogICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudE5hbWUsCiAgICAgICAgICAgIGVsZW1lbnQ6IGMsCiAgICAgICAgICAgIGVycm9yOiBlcnIsCiAgICAgICAgICAgIHN0YXRlOiBhcHAsCiAgICAgICAgICAgIC8vIFdyaXRlIHByb3h5IC0gTVVUQUJMRQogICAgICAgICAgICByZWZzLAogICAgICAgICAgICBzbG90cywKICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLAogICAgICAgICAgICByZXJlbmRlcjogKCkgPT4gcmVuZGVyRnVuY3Rpb24ocmVuZGVyU3RhdGUpLAogICAgICAgICAgICBzdGFjazogZXJyLnN0YWNrID8/ICIiCiAgICAgICAgICB9OwogICAgICAgICAgaWYgKGlzRGVidWdFbmFibGVkKCJjb25zb2xlIikpIHsKICAgICAgICAgICAgbG9nRXJyb3IoY3R4KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGxvZ0Vycm9yTWluaW1hbChjb21wb25lbnROYW1lLCBlcnIpOwogICAgICAgICAgfQogICAgICAgICAgZXhwb3NlR2xvYmFscyhjdHgpOwogICAgICAgICAgc3RvcmVFcnJvcihjdHgpOwogICAgICAgICAgbWFya0NvbXBvbmVudEVycm9yKGMpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICB1c2VyRGVmaW5lZFJlbmRlcmVyKHsKICAgICAgICAgIHN0YXRlOiByZW5kZXJBY2Nlc3NvciwKICAgICAgICAgIHJlZnMsCiAgICAgICAgICBzbG90cywKICAgICAgICAgIHNlbGY6IGMsCiAgICAgICAgICBkZXRhaWwsCiAgICAgICAgICBtYWtlQ29tcG9uZW50OiAodGFnLCBvcHRzKSA9PiB7CiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBbmRSdW5Db2RlKHRhZywgYXBwU3RhdGUsIG9wdHM/LmRldGFpbCk7CiAgICAgICAgICB9LAogICAgICAgICAgaGVscGVycwogICAgICAgIH0pOwogICAgICAgIGFwcGx5QmluZGluZ3MoYywgeyBzdGF0ZTogcmVuZGVyQWNjZXNzb3IsIGRldGFpbCwgc2VsZjogYyB9KTsKICAgICAgICB1cGRhdGVTdWJzY3JpYmVycygpOwogICAgICB9CiAgICB9OwogICAgc3RvcmVDb21wb25lbnRDb250ZXh0KGMsIHsKICAgICAgc3RhdGU6IGFwcCwKICAgICAgcmVmcywKICAgICAgc2xvdHMsCiAgICAgIHNlbGY6IGMsCiAgICAgIGRldGFpbCwKICAgICAgcmVyZW5kZXI6ICgpID0+IHJlbmRlckZ1bmN0aW9uKGFwcCkKICAgIH0pOwogICAgYy5fX2JvcmVET01EZXRhaWwgPSBkZXRhaWw7CiAgICBjLl9fYm9yZURPTVJlcmVuZGVyID0gKCkgPT4gcmVuZGVyRnVuY3Rpb24oYXBwKTsKICAgIHJlbmRlckZ1bmN0aW9uKHN0YXRlKTsKICB9OwogIHJlc3VsdFtXRUJfQ09NUE9ORU5UX01BUktFUl0gPSB0cnVlOwogIHJldHVybiByZXN1bHQ7Cn0KZXhwb3J0IHsKICBWRVJTSU9OLAogIGJvcmVET00sCiAgY2xlYXJHbG9iYWxzLAogIGNvbXBvbmVudDIgYXMgY29tcG9uZW50LAogIGdldERlYnVnQ29uZmlnLAogIGh0bWwsCiAgaW5mbGljdEJvcmVET00sCiAgaXNEZWJ1Z0VuYWJsZWQsCiAgcXVlcnlDb21wb25lbnQsCiAgcmVnaXN0ZXJDb21wb25lbnQsCiAgc2V0RGVidWdDb25maWcsCiAgd2ViQ29tcG9uZW50Cn07Cg==
`;
var beautify = import_js_beautify.default.html;
var DEFAULT_COMPONENTS_DIR = "components";
var DEFAULT_STATIC_DIR = "src";
var DEFAULT_STATIC_SERVE = "";
var BUILD_DIR = "build";
var serverStarted = false;
var numberOfRefreshes = 0;
function collectMultiValue(value, previous) {
  const next = Array.isArray(previous) ? [...previous] : [];
  next.push(value);
  return next;
}
var INIT_INDEX_HTML = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>boreDOM App</title>
  <style>
    /* CSS Layers: base < components < overrides */
    @layer base, components, overrides;

    @layer base {
      * { box-sizing: border-box; margin: 0; padding: 0; }
      body {
        font-family: system-ui, -apple-system, sans-serif;
        line-height: 1.5;
        min-height: 100vh;
      }
      button {
        cursor: pointer;
        font: inherit;
      }
    }

    @layer components {
      /* my-app component styles */
      my-app {
        display: block;
        padding: 2rem;
        text-align: center;
      }
      my-app h1 {
        margin-bottom: 1.5rem;
      }
      my-app .counter {
        display: flex;
        gap: 1rem;
        justify-content: center;
        align-items: center;
      }
      my-app .counter button {
        width: 3rem;
        height: 3rem;
        font-size: 1.5rem;
        border: 1px solid #ccc;
        border-radius: 0.5rem;
        background: #f5f5f5;
      }
      my-app .counter button:hover {
        background: #e5e5e5;
      }
      my-app .count {
        font-size: 2rem;
        min-width: 4rem;
        font-variant-numeric: tabular-nums;
      }
      my-app .hint {
        margin-top: 2rem;
        color: #666;
      }
    }

    @layer overrides {
      /* Page-specific overrides go here */
    }
  </style>
  <script type="module">
    import { inflictBoreDOM, webComponent } from "https://unpkg.com/@mr_hugo/boredom@0.26.1/dist/boreDOM.min.js"

    inflictBoreDOM(
      { count: 0 },
      {
        "my-app": webComponent(({ on }) => {
          on("increment", ({ state }) => state.count++)
          on("decrement", ({ state }) => state.count--)

          return ({ state, refs }) => {
            refs.count.textContent = state.count
          }
        })
      }
    )
  </script>
  <script src="http://localhost:31337"></script>
</head>
<body>
  <my-app></my-app>

  <template data-component="my-app">
    <h1>boreDOM App</h1>
    <div class="counter">
      <button data-dispatch="decrement">\u2212</button>
      <span class="count" data-ref="count">0</span>
      <button data-dispatch="increment">+</button>
    </div>
    <p class="hint">Edit this file. Claude can control this app via MCP.</p>
  </template>
</body>
</html>
`;
var INIT_CLAUDE_MD = `# boreDOM Project

This project uses boreDOM with MCP integration. Claude can directly control the running app.

**Event syntax - ONLY use this format:**
\`\`\`html
<button data-dispatch="eventName">Click</button>
\`\`\`

**These are WRONG (don't invent alternatives):**
- \`dispatch('event')\` \u2190 WRONG
- \`data-onclick-dispatches\` \u2190 WRONG
- \`dispatchEvent()\` \u2190 WRONG
- \`addEventListener()\` \u2190 WRONG (boreDOM handles this)

---

## STOP - Before You "Fix" Dynamic Components

If you think:
- "render function isn't triggering for dynamically created components"
- "I need to include data directly in the HTML string"
- "dynamically created components don't auto-initialize"

**YOU ARE WRONG.** Dynamic components FULLY WORK in boreDOM.

**Before changing your approach, DEBUG FIRST:**
1. Add \`console.log('RENDER', self.tagName, self.dataset.index)\` as FIRST line in render
2. Check browser console for the log
3. If log appears \u2192 render IS running, bug is elsewhere (check state values, refs)
4. If no log \u2192 check component registration and init/render syntax

**DO NOT:**
- Inline data directly into HTML strings (defeats reactivity)
- Replace \`refs.container.innerHTML\` with static HTML
- Add "fallback" code for "when render doesn't trigger"

**The pattern IS correct. Debug, don't work around.**

### Correct Pattern: Labels from Array

**State:**
\`\`\`javascript
const state = { pads: [{ label: "Kick" }, { label: "Snare" }, { label: "Hat" }] }
\`\`\`

**Parent creates children with data-index:**
\`\`\`javascript
"pad-grid": webComponent(() => {
  let initialized = false
  return ({ state, refs }) => {
    if (initialized) return
    initialized = true
    refs.container.innerHTML = state.pads.map((_, i) =>
      \`<pad-button data-index="\${i}"></pad-button>\`
    ).join("")
  }
})
\`\`\`

**Child reads index, accesses state for its data:**
\`\`\`javascript
"pad-button": webComponent(() => {
  return ({ state, refs, self }) => {
    const index = parseInt(self.dataset.index)
    const pad = state.pads[index]
    refs.label.textContent = pad.label  // \u2190 This WORKS. Render IS called.
  }
})
\`\`\`

**Child template:**
\`\`\`html
<template data-component="pad-button">
  <button><span data-ref="label"></span></button>
</template>
\`\`\`

**This pattern works because:**
1. Parent creates \`<pad-button data-index="0">\` via innerHTML
2. boreDOM auto-registers it and calls its render function
3. Child's render reads \`self.dataset.index\` to know which pad it is
4. Child accesses \`state.pads[index]\` to get its label
5. Label appears. No "fix" needed.

---

## Development Workflow - Progressive Enhancement

**Build in layers. Don't style broken code. Don't fix styled code.**

### Phase 1: Structure (get it rendering)
1. Create component template with basic HTML structure
2. Add \`data-ref\` for elements you'll update
3. Add \`data-dispatch="event"\` for interactive elements
4. Verify component appears in browser (reload, check for errors)

### Phase 2: Functionality (get it working)
1. Add event handlers with \`on('event', handler)\`
2. Wire up state mutations
3. Update refs/slots in render function
4. **TEST EACH INTERACTION** before moving on
5. Fix any bugs NOW, not later

### Phase 3: Styling (make it pretty)
1. Only start styling AFTER functionality works
2. Add CSS for layout, colors, typography
3. Don't change HTML structure while styling (breaks functionality)

**Why this order matters:**
- Styling broken code = wasted effort (you'll change the HTML)
- Fixing styled code = style breaks (you'll change the HTML)
- Testing early = small bugs, easy fixes
- Testing late = compound bugs, hard to debug

**After each phase: reload and verify before proceeding.**

## Component Architecture

**IMPORTANT: Break features into small, focused components.**

### When to create a new component:
- It represents a distinct UI element (card, button, form, list item)
- It will be repeated (list items, cards in a grid)
- It handles specific user interactions (a form, a menu)
- It manages a logical slice of the UI (header, sidebar, main content)

### Component hierarchy example:
\`\`\`
app-root
\u251C\u2500\u2500 app-header          (navigation, logo)
\u251C\u2500\u2500 task-list           (container, manages list)
\u2502   \u2514\u2500\u2500 task-item       (repeated for each task)
\u2502       \u2514\u2500\u2500 task-actions (edit/delete buttons)
\u2514\u2500\u2500 task-form           (add new tasks)
\`\`\`

### Bad: One monolithic component
\`\`\`javascript
// DON'T do this - everything in one component
"my-app": webComponent(({ on }) => {
  on("addTask", ...)
  on("deleteTask", ...)
  on("editTask", ...)
  on("toggleDone", ...)
  on("filter", ...)
  // 100+ lines of handlers and render logic
})
\`\`\`

### Good: Focused components
\`\`\`javascript
// Each component has ONE job
"task-item": webComponent(...)    // Display single task
"task-list": webComponent(...)    // Render list of task-items
"task-form": webComponent(...)    // Handle task creation
"task-filter": webComponent(...)  // Handle filtering
\`\`\`

## File Organization

**When index.html exceeds ~200 lines, split into separate files.**

### Structure for larger apps:
\`\`\`
project/
\u251C\u2500\u2500 index.html              # App shell only
\u251C\u2500\u2500 state.js                # Initial state + inflictBoreDOM call
\u251C\u2500\u2500 styles.css              # Global styles (@layer base)
\u251C\u2500\u2500 components/
\u2502   \u251C\u2500\u2500 task-list.html      # <template data-component="task-list">
\u2502   \u251C\u2500\u2500 task-list.js        # webComponent logic
\u2502   \u251C\u2500\u2500 task-list.css       # Component styles (@layer components)
\u2502   \u251C\u2500\u2500 task-item.html
\u2502   \u251C\u2500\u2500 task-item.js
\u2502   \u2514\u2500\u2500 task-item.css
\`\`\`

### index.html (shell only - no logic):
\`\`\`html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My App</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="components/task-list.css">
  <link rel="stylesheet" href="components/task-item.css">
</head>
<body>
  <app-root></app-root>

  <!-- Templates -->
  <template data-component="app-root">
    <main><task-list></task-list></main>
  </template>

  <!-- Scripts -->
  <script type="module" src="state.js"></script>
  <script src="http://localhost:31337"></script>
</body>
</html>
\`\`\`

### state.js (app initialization):
\`\`\`javascript
import { inflictBoreDOM, webComponent } from "https://unpkg.com/@mr_hugo/boredom@0.26.1/dist/boreDOM.min.js"
import taskList from "./components/task-list.js"
import taskItem from "./components/task-item.js"

const initialState = {
  tasks: [],
  filter: "all"
}

inflictBoreDOM(initialState, {
  "app-root": webComponent(() => () => {}),
  "task-list": taskList,
  "task-item": taskItem
})
\`\`\`

### components/task-item.html:
\`\`\`html
<template data-component="task-item">
  <div class="task">
    <span data-ref="name"></span>
    <button data-dispatch="delete">Delete</button>
  </div>
</template>
\`\`\`

### components/task-item.js:
\`\`\`javascript
import { webComponent } from "boredom"
export default webComponent(({ on }) => {
  on("delete", ({ state, detail }) => {
    state.tasks.splice(detail.index, 1)
  })
  return ({ refs, detail }) => {
    refs.name.textContent = detail.task.name
  }
})
\`\`\`

### Running the app:
\`\`\`bash
boredom serve              # Clean static server (recommended for MCP)
boredom serve --live       # With auto-reload on file changes
boredom serve -p 3000      # Custom port
\`\`\`

**Note:** \`boredom dev\` auto-injects scripts and transforms HTML.
Use \`boredom serve\` for transparent serving, add \`--live\` for auto-reload.

## Browser Control

**When the user provides a URL, navigate to it first before taking screenshots.**
Don't assume the browser is already on the correct page. Always navigate first:

\`\`\`
User: "server running on localhost:8880, change the button color"

1. Navigate to http://localhost:8880 (don't screenshot first!)
2. Take screenshot to see current state
3. Make changes
4. Trigger reload or re-navigate to verify
\`\`\`

## Browser Reload - Which Method to Use

**If you're controlling the browser via chrome-devtools MCP:**
\`\`\`
Use: navigate_page with type: "reload"
\`\`\`
This directly reloads the browser you're controlling. Simple and reliable.

**If user is viewing in their own browser (not controlled by you):**
\`\`\`bash
curl http://localhost:PORT/__trigger-reload
\`\`\`
This sends reload signal to browsers with live reload script connected.

**Decision rule:**
- Using chrome-devtools MCP? \u2192 \`navigate_page(type: "reload")\`
- User watching their own browser? \u2192 \`curl /__trigger-reload\`

Don't use both. Pick one based on the situation.

## Exports

Only two functions are exported from boreDOM:
\`\`\`javascript
import { inflictBoreDOM, webComponent } from "https://unpkg.com/@mr_hugo/boredom@0.26.1/dist/boreDOM.min.js"
\`\`\`

**DO NOT** try to import \`makeComponent\` - it's only available inside render functions.

## Component Structure

\`\`\`javascript
webComponent(({ on }) => {
  // INIT PHASE: runs once when component is created
  // - Setup event handlers here
  // - Do NOT access refs here (template not attached yet)
  on("click", ({ state }) => state.count++)

  // RENDER PHASE: runs on every state change AND on first render
  return ({ state, refs, slots, self }) => {
    if (!state) return
    // - Update DOM here
    // - refs ARE available here (template is attached)
    // - Read data attributes: self.dataset.index
    refs.display.textContent = state.count
    slots.list = state.items.map(i => \`<li>\${i.name}</li>\`).join("")
  }
})
\`\`\`

**Key insight:** The render function runs AFTER the template is attached, so refs work there. Don't try to access refs in init phase.

## Template Attributes

- \`data-ref="name"\` \u2192 Access element via \`refs.name\`
- \`<slot name="x">default</slot>\` \u2192 Set content via \`slots.x = "..."\`
- \`data-dispatch="eventName"\` \u2192 Trigger event handler
- \`data-dispatch="event1 event2"\` \u2192 Trigger multiple events

### refs vs slots - When to Use Each

**refs** = Read/write element properties (textContent, value, classList, style)
\`\`\`html
<span data-ref="count">0</span>
<input data-ref="input" type="text">
\`\`\`
\`\`\`javascript
refs.count.textContent = state.count      // \u2713 Set text
refs.input.value = state.query            // \u2713 Set input value
refs.count.classList.add("highlight")     // \u2713 Modify classes
\`\`\`

**slots** = Inject simple HTML content (text, basic markup)
\`\`\`html
<slot name="message">Default text</slot>
<slot name="status"></slot>
\`\`\`
\`\`\`javascript
slots.message = "<strong>Hello!</strong>" // \u2713 Simple HTML
slots.status = state.isLoading ? "Loading..." : "Ready"
\`\`\`

**For component lists, use refs.innerHTML:**
\`\`\`html
<div data-ref="items"></div>
\`\`\`
\`\`\`javascript
refs.items.innerHTML = state.tasks.map((t, i) =>
  \`<task-item data-index="\${i}"></task-item>\`
).join("")
\`\`\`

**Summary:**
- **Slots** (\`<slot name="x">\`) = Simple text/HTML content \u2192 \`slots.x = "Hello"\`
- **Refs** (\`data-ref="x"\`) = Element access \u2192 \`refs.x.textContent\`, \`refs.x.classList\`, \`refs.x.innerHTML\`
- **Component lists** = Use refs.innerHTML with HTML strings (NOT slots, NOT makeComponent)

## State Mutations

\`\`\`javascript
// Only mutate state in event handlers, never in render
on("addUser", ({ state }) => {
  state.count++
  state.users.push({ id: 1, name: "Alice" })
})
\`\`\`

## MCP Workflow

**Standard workflow when user provides a URL:**
1. **Navigate first** - \`navigate_page\` to the URL (never screenshot before navigating)
2. **Get context** - Use \`boredom_get_context\` to understand app state (NOT screenshots)
3. **Read files** - Understand the code structure
4. **Edit the source files** - Use Edit/Write tools to modify index.html, CSS, JS files
5. **Reload** - \`curl http://localhost:PORT/__trigger-reload\` or navigate again
6. **Verify** - Screenshot only to confirm visual changes

**Prefer boreDOM MCP tools over screenshots:**
- \`boredom_get_context\` \u2192 Get app state, components, errors (structured data)
- \`boredom_get_focus\` \u2192 Get current error context
- Screenshots \u2192 Only for visual verification after changes

**Why use boreDOM tools instead of screenshots?**
- Structured data about state, not pixels
- See actual variable values, component structure, errors
- Faster and more accurate than visual inspection

**IMPORTANT - File edits vs runtime changes:**
- **Edit source files** (index.html, *.js, *.css) for persistent changes
- Runtime JavaScript execution (browser console, boreDOM.llm.apply) is temporary
- Changes made via runtime APIs are lost on page refresh
- Always modify the actual files so changes survive reload
- **Don't use boredom_apply_code for debugging** - just fix the source files directly

**CSS changes don't need screenshot verification:**
- Edit the CSS file
- Trigger reload: \`curl http://localhost:PORT/__trigger-reload\`
- Done. Trust the reload. CSS is applied.
- Only screenshot if user asks "how does it look?" or you need to verify layout

**Don't:**
- Take screenshots to understand app state (use boredom_get_context instead)
- Take screenshots to verify CSS changes (trust the reload)
- Use runtime JavaScript execution for permanent changes (won't persist!)
- Take screenshots before navigating to the provided URL
- Assume the browser is already showing the right page
- Forget to reload after editing files

## Common Patterns

### Rendering Lists of Child Components

**CRITICAL: Always use the \`initialized\` flag when creating dynamic components!**
Without it, parent re-renders destroy and recreate all children, breaking their state.

**Use refs.innerHTML for component lists** (most reliable approach):

\`\`\`html
<!-- Parent template -->
<template data-component="item-list">
  <div data-ref="container"></div>
</template>
\`\`\`

\`\`\`javascript
"item-list": webComponent(() => {
  let initialized = false
  return ({ state, refs }) => {
    if (!state) return
    if (initialized) return  // Only render once
    initialized = true

    // Set innerHTML on ref - custom elements get their templates applied
    refs.container.innerHTML = state.items.map((item, i) =>
      \`<item-card data-index="\${i}"></item-card>\`
    ).join("")
  }
})
\`\`\`

**Key points:**
- Use \`data-ref="container"\` not \`<slot>\` for dynamic component lists
- Use \`initialized\` flag to prevent re-rendering on every state change
- Don't use \`document.createElement\` - it bypasses template binding

**IMPORTANT: Dynamic components FULLY WORK!**
When you set \`refs.container.innerHTML = '<my-component></my-component>'\`:
1. Browser creates the custom element
2. boreDOM registers it and applies the template
3. Component's init function runs (event handlers registered)
4. Component's render function runs (DOM updated)
5. \`data-dispatch="event"\` handlers work automatically

**Don't "fix" dynamic components by assuming they're broken.** If something isn't working:
1. **ADD CONSOLE.LOG to debug** - don't guess!
   \`\`\`javascript
   return ({ state, refs, self }) => {
     console.log('render running', self.dataset.index, state)
     // ... rest of render
   }
   \`\`\`
2. Check if render runs (if no log, check init function syntax)
3. Check if state has expected values
4. Check if refs are defined
5. The dynamic creation pattern IS correct - don't work around it

**Child component pattern** - reads data from parent via data attributes:
\`\`\`html
<template data-component="item-card">
  <div class="card">
    <span data-ref="name"></span>
    <button data-dispatch="delete">X</button>
  </div>
</template>
\`\`\`
\`\`\`javascript
"item-card": webComponent(({ on }) => {
  on("delete", ({ state, self }) => {
    const index = parseInt(self.dataset.index)
    state.items.splice(index, 1)
  })
  return ({ state, refs, self }) => {
    if (!state) return
    const index = parseInt(self.dataset.index)
    const item = state.items[index]
    if (item) refs.name.textContent = item.name
  }
})
\`\`\`

### Always Guard State

Start every render function with a state check:
\`\`\`javascript
return ({ state, refs, slots }) => {
  if (!state) return  // ALWAYS do this first

  // Now safe to use state
  refs.count.textContent = state.count
}
\`\`\`

**Child-to-parent communication**: Children trigger events via \`data-dispatch="eventName"\`, parents handle them with \`on('eventName', handler)\`.
Events bubble up, so parent can catch child events.

**Simple HTML lists** (for plain elements, not boreDOM components):
\`\`\`javascript
// Use slots for simple HTML lists (li, div, span, etc.)
slots.list = state.items.map(i => \`<li>\${i.name}</li>\`).join("")
\`\`\`

**Guard null values:**
\`\`\`javascript
slots.list = (state.items || []).map(i => \`<li>\${i.name}</li>\`).join("")
\`\`\`

**Conditional rendering:**
\`\`\`javascript
slots.content = state.loading
  ? "<p>Loading...</p>"
  : state.items.map(i => \`<div>\${i.name}</div>\`).join("")
\`\`\`

## Important Rules

### DO:
- Always check \`if (!state) return\` at start of render
- Use \`state\` parameter name in event handlers for mutations
- Use refs.innerHTML with HTML strings for component lists
- Create separate templates for repeated/list items

### DON'T:
- Don't use \`dispatchEvent\` or \`dispatch()\` - use \`data-dispatch="eventName"\` syntax
- Don't use \`document.createElement\` for boreDOM components - use refs.innerHTML
- Don't use \`boredom_apply_code\` for debugging - edit source files directly
- Don't access refs in init phase - use them in render function
- Don't mutate state in render functions (only in event handlers)
- Don't forget the hyphen in component names (\`my-component\`, not \`mycomponent\`)
- Don't use makeComponent in string templates (returns HTMLElement, not string)
- Don't store DOM elements in reactive state
- Don't manually add event listeners - innerHTML binds \`data-dispatch="event"\` automatically
- Don't replace dynamic components with static ones - dynamic creation WORKS
- Don't forget \`initialized\` flag when creating components via innerHTML
- Don't assume "render isn't running" - add console.log to verify before changing approach
- Don't use \`window.state\` - it doesn't exist! State is only available in event handlers and render

## Accessing State from Global Event Handlers

\`window.state\` does NOT exist. To access state from global keyboard handlers:

**Option 1: Capture return value from inflictBoreDOM**
\`\`\`javascript
const state = await inflictBoreDOM({...}, {...})
document.addEventListener('keydown', (e) => {
  state.activePad = index  // Works - state is the returned proxy
})
\`\`\`

**Option 2: Handle keyboard inside component init (recommended)**
\`\`\`javascript
"mpc-app": webComponent(({ on }) => {
  document.addEventListener('keydown', (e) => {
    // Dispatch event that component can catch
    window.dispatchEvent(new CustomEvent('key-press', { detail: { key: e.key } }))
  })

  on('key-press', ({ state, detail }) => {
    state.activePad = keyToIndex[detail.key]  // state available here
  })
  return ...
})
\`\`\`

## CSS Best Practices

Use CSS layers for predictable specificity. Order: base < components < overrides.

\`\`\`css
@layer base, components, overrides;

@layer base {
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: system-ui, sans-serif; }
}

@layer components {
  /* Each component gets its own section */
  my-component {
    display: block;
  }
  my-component .title {
    font-size: 1.5rem;
  }
}

@layer overrides {
  /* Page-specific overrides - no !important needed */
}
\`\`\`

**Rules:**
- Style components by tag name: \`user-card { }\` not \`.user-card { }\`
- Use classes for internal elements: \`user-card .name { }\`
- Keep styles in the same file as templates (single HTML file)
- Unlayered styles override layered styles automatically
`;
var INIT_MCP_JSON = `{
  "mcpServers": {
    "boredom": {
      "command": "npx",
      "args": ["-y", "boredom-mcp"]
    }
  }
}
`;
async function initProject(targetDir) {
  const dir = import_path.default.resolve(targetDir || ".");
  console.log(`Initializing boreDOM project in ${dir}...`);
  const indexPath = import_path.default.join(dir, "index.html");
  const claudePath = import_path.default.join(dir, "CLAUDE.md");
  const mcpPath = import_path.default.join(dir, ".mcp.json");
  const existingFiles = [];
  if (await import_fs_extra.default.pathExists(indexPath)) existingFiles.push("index.html");
  if (await import_fs_extra.default.pathExists(claudePath)) existingFiles.push("CLAUDE.md");
  if (await import_fs_extra.default.pathExists(mcpPath)) existingFiles.push(".mcp.json");
  if (existingFiles.length > 0) {
    console.log("\x1B[33m%s\x1B[0m", `Warning: These files already exist and will be skipped: ${existingFiles.join(", ")}`);
  }
  await import_fs_extra.default.ensureDir(dir);
  if (!existingFiles.includes("index.html")) {
    await import_fs_extra.default.writeFile(indexPath, INIT_INDEX_HTML);
    console.log("  Created index.html");
  }
  if (!existingFiles.includes("CLAUDE.md")) {
    await import_fs_extra.default.writeFile(claudePath, INIT_CLAUDE_MD);
    console.log("  Created CLAUDE.md");
  }
  if (!existingFiles.includes(".mcp.json")) {
    await import_fs_extra.default.writeFile(mcpPath, INIT_MCP_JSON);
    console.log("  Created .mcp.json");
  }
  console.log("");
  console.log("\x1B[32m%s\x1B[0m", "Done! Next steps:");
  console.log("");
  console.log("  1. Open index.html in your browser");
  console.log("  2. Start Claude Code in this directory");
  console.log("  3. Ask Claude to modify your app");
  console.log("");
}
var isTestMode = Boolean(process.env.BOREDOM_CLI_TEST_MODE);
import_commander.program.name("boredom").description("boreDOM CLI - dev server and project scaffolding").version("0.26.1");
import_commander.program.command("init [directory]").description("Create a new boreDOM project with MCP support").action(async (directory) => {
  await initProject(directory);
  process.exit(0);
});
var LIVE_RELOAD_SCRIPT = `
<script>
(function() {
  const es = new EventSource("/__reload");
  es.onmessage = () => location.reload();
  es.onerror = () => setTimeout(() => location.reload(), 1000);
})();
</script>
</body>`;
import_commander.program.command("serve [directory]").description("Start a clean static server (no transformations)").option("-p, --port <port>", "Port to serve on", "8080").option("-l, --live", "Enable live reload on file changes").action(async (directory, opts) => {
  const dir = import_path.default.resolve(directory || ".");
  const port = parseInt(opts.port, 10);
  const liveReload = opts.live;
  const sseClients = /* @__PURE__ */ new Set();
  console.log(`Serving ${dir} on http://localhost:${port}`);
  if (liveReload) {
    console.log("Live reload enabled - browser will refresh on file changes");
  } else {
    console.log("Clean mode - files served as-is");
    console.log(`Reload API available: http://localhost:${port}/__trigger-reload`);
  }
  console.log("");
  const triggerReload = (reason = "manual") => {
    if (sseClients.size > 0) {
      console.log(`Reload triggered: ${reason} (${sseClients.size} client${sseClients.size === 1 ? "" : "s"})`);
      sseClients.forEach((client) => {
        client.write("data: reload\n\n");
      });
      return true;
    }
    return false;
  };
  const server = import_http.default.createServer((req, res) => {
    if (req.url === "/__reload") {
      res.writeHead(200, {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        "Connection": "keep-alive",
        "Access-Control-Allow-Origin": "*"
      });
      res.write("data: connected\n\n");
      sseClients.add(res);
      req.on("close", () => sseClients.delete(res));
      return;
    }
    if (req.url === "/__trigger-reload") {
      res.writeHead(200, {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*"
      });
      const reloaded = triggerReload("API call");
      res.end(JSON.stringify({ success: true, clients: sseClients.size, reloaded }));
      return;
    }
    if (req.url === "/__reload.js") {
      res.writeHead(200, {
        "Content-Type": "application/javascript",
        "Access-Control-Allow-Origin": "*"
      });
      res.end(`(function() {
  const es = new EventSource("/__reload");
  es.onmessage = () => location.reload();
  es.onerror = () => setTimeout(() => location.reload(), 1000);
})();`);
      return;
    }
    let urlPath = decodeURIComponent(req.url.split(/[?#]/)[0]);
    if (urlPath === "/" || urlPath.endsWith("/")) {
      urlPath = import_path.default.posix.join(urlPath, "index.html");
    }
    const filePath = import_path.default.join(dir, urlPath);
    import_fs_extra.default.pathExists(filePath).then(async (exists) => {
      if (!exists) {
        res.writeHead(404, { "Content-Type": "text/plain" });
        return res.end("Not Found");
      }
      const contentType = import_mime_types.default.lookup(filePath) || "application/octet-stream";
      if (liveReload && contentType === "text/html") {
        let content = await import_fs_extra.default.readFile(filePath, "utf-8");
        content = content.replace("</body>", LIVE_RELOAD_SCRIPT);
        res.writeHead(200, {
          "Content-Type": contentType,
          "Access-Control-Allow-Origin": "*"
        });
        return res.end(content);
      }
      res.writeHead(200, {
        "Content-Type": contentType,
        "Access-Control-Allow-Origin": "*"
      });
      import_fs_extra.default.createReadStream(filePath).pipe(res);
    }).catch(() => {
      res.writeHead(500, { "Content-Type": "text/plain" });
      res.end("Internal Server Error");
    });
  });
  server.listen(port, () => {
    console.log(`Ready: http://localhost:${port}`);
  });
  server.on("error", (e) => {
    if (e.code === "EADDRINUSE") {
      console.error(`Port ${port} is in use. Try: boredom serve -p ${port + 1}`);
      process.exit(1);
    }
  });
  if (liveReload) {
    const watcher = import_chokidar.default.watch(dir, {
      ignoreInitial: true,
      ignored: /(^|[\/\\])\../
      // ignore dotfiles
    });
    let reloadTimeout;
    watcher.on("all", (event, changedPath) => {
      if (reloadTimeout) clearTimeout(reloadTimeout);
      reloadTimeout = setTimeout(() => {
        triggerReload(`file changed: ${import_path.default.relative(dir, changedPath)}`);
      }, 100);
    });
  }
});
var devCommand = import_commander.program.command("dev", { isDefault: true }).description("Start dev server with auto-injection (use 'serve' for clean mode)").option("--index <path to file>", "Index file to serve", "index.html").option(
  "--html <folder>",
  "Folder containing HTML component files",
  DEFAULT_COMPONENTS_DIR
).option(
  "--static <folder>",
  "Folder containing static files to be copied as is",
  collectMultiValue,
  [DEFAULT_STATIC_DIR]
).option(
  "--components-serve <folder>",
  "Build subfolder used to serve processed components",
  DEFAULT_COMPONENTS_DIR
).option(
  "--static-serve <folder>",
  "Build subfolder used to serve static assets",
  DEFAULT_STATIC_SERVE
);
if (isTestMode) {
  import_commander.program.parse([], { from: "user" });
} else {
  import_commander.program.parse(process.argv);
}
var options = devCommand.opts();
function sanitizeServeInput(value) {
  const normalizedSlashes = value.replace(/\\+/g, "/").trim();
  if (!normalizedSlashes) {
    return { fsPath: "", urlPath: "" };
  }
  if (["/", "./"].includes(normalizedSlashes)) {
    return { fsPath: "", urlPath: "/" };
  }
  let working = normalizedSlashes;
  while (working.startsWith("./")) {
    working = working.slice(2);
  }
  const isAbsolute = working.startsWith("/");
  if (isAbsolute) {
    working = working.replace(/^\/+/, "");
  }
  working = working.replace(/\/+$/, "");
  const fsPath = working;
  if (!fsPath) {
    return { fsPath: "", urlPath: isAbsolute ? "/" : "" };
  }
  const urlPath = isAbsolute ? `/${fsPath}` : fsPath;
  return { fsPath, urlPath };
}
function normalizeServePath(input, fallback) {
  if (typeof input === "undefined" || input === null) {
    return sanitizeServeInput(fallback);
  }
  const trimmed = String(input).trim();
  if (!trimmed) {
    return sanitizeServeInput(fallback);
  }
  return sanitizeServeInput(trimmed);
}
function buildRelativeServePath(base, ...segments) {
  const cleanSegments = segments.filter(Boolean).map((segment) => {
    return segment.replace(/^\/+/, "").replace(/\/+$/, "");
  });
  const ensureModuleRelative = (candidate) => {
    if (!candidate) {
      return candidate;
    }
    if (candidate.startsWith("/") || candidate.startsWith("./") || candidate.startsWith("../")) {
      return candidate;
    }
    return `./${candidate}`;
  };
  if (!base || base === ".") {
    return ensureModuleRelative(cleanSegments.join("/"));
  }
  if (base === "/") {
    const joined = cleanSegments.join("/");
    return joined ? `/${joined}` : "/";
  }
  const cleanBase = base.replace(/\/+$/, "");
  return ensureModuleRelative([cleanBase, ...cleanSegments].join("/"));
}
var componentsServePath;
var staticServePath;
var componentsServeUrlPath;
var staticServeUrlPath;
function setServePaths(currentOptions = options) {
  const componentsPaths = normalizeServePath(
    currentOptions.componentsServe,
    "components"
  );
  const staticPaths = normalizeServePath(
    currentOptions.staticServe,
    DEFAULT_STATIC_SERVE
  );
  componentsServePath = componentsPaths.fsPath;
  componentsServeUrlPath = componentsPaths.urlPath;
  staticServePath = staticPaths.fsPath;
  staticServeUrlPath = staticPaths.urlPath;
  return {
    componentsServePath,
    componentsServeUrlPath,
    staticServePath,
    staticServeUrlPath
  };
}
function getServePaths() {
  return {
    componentsServePath,
    componentsServeUrlPath,
    staticServePath,
    staticServeUrlPath
  };
}
setServePaths();
async function copyStatic() {
  const staticFolders = Array.isArray(options.static) ? options.static : [options.static].filter(Boolean);
  if (staticFolders.length === 0) {
    return;
  }
  for (const folder of staticFolders) {
    const staticDir = import_path.default.resolve(folder);
    if (await import_fs_extra.default.pathExists(staticDir)) {
      await import_fs_extra.default.copy(staticDir, import_path.default.join(BUILD_DIR, staticServePath), {
        overwrite: true,
        errorOnExist: false
      });
      console.log(`Static folder copied from ${folder}.`);
    }
  }
}
async function copyBoreDOM() {
  return import_fs_extra.default.writeFile(import_path.default.join(BUILD_DIR, "boreDOM.js"), atob(boredom));
}
async function processComponents() {
  let components = {};
  if (options.html) {
    const htmlFolder = import_path.default.resolve(options.html);
    const htmlFiles = glob.sync("**/*.html", { cwd: htmlFolder });
    for (const file of htmlFiles) {
      const filePath = import_path.default.join(htmlFolder, file);
      const content = await import_fs_extra.default.readFile(filePath, "utf-8");
      const $ = cheerio.load(content, { decodeEntities: false });
      const template = $("template[data-component]");
      if (template.length) {
        const componentName = template.attr("data-component");
        const fullTemplate = $.html(template);
        const componentBuildDir = import_path.default.join(
          BUILD_DIR,
          componentsServePath,
          componentName
        );
        await import_fs_extra.default.ensureDir(componentBuildDir);
        const destHtmlPath = import_path.default.join(
          componentBuildDir,
          `${componentName}.html`
        );
        await import_fs_extra.default.copy(filePath, destHtmlPath);
        const componentDir = import_path.default.dirname(filePath);
        const jsMatch = glob.sync(`**/${componentName}.js`, {
          cwd: componentDir
        });
        const cssMatch = glob.sync(`**/${componentName}.css`, {
          cwd: componentDir
        });
        const hasJS = jsMatch.length > 0;
        if (jsMatch.length > 0) {
          const jsSrc = import_path.default.join(componentDir, jsMatch[0]);
          const destJsPath = import_path.default.join(
            componentBuildDir,
            `${componentName}.js`
          );
          await import_fs_extra.default.copy(jsSrc, destJsPath);
          console.log(`Copied ${componentName}.js to ${componentBuildDir}`);
        }
        const hasCSS = cssMatch.length > 0;
        if (cssMatch.length > 0) {
          const cssSrc = import_path.default.join(componentDir, cssMatch[0]);
          const destCssPath = import_path.default.join(
            componentBuildDir,
            `${componentName}.css`
          );
          await import_fs_extra.default.copy(cssSrc, destCssPath);
          console.log(`Copied ${componentName}.css to ${componentBuildDir}`);
        }
        components[componentName] = {
          templateTag: fullTemplate,
          hasJS,
          hasCSS
        };
      }
    }
  }
  return components;
}
async function updateIndex(components) {
  console.log(
    "Updated index.html with components:\n\n",
    JSON.stringify(components, null, 2)
  );
  const indexPath = import_path.default.resolve(options.index);
  let indexContent = await import_fs_extra.default.readFile(indexPath, "utf-8");
  const $ = cheerio.load(indexContent, { decodeEntities: false });
  $("head").prepend(
    `
  <script type="importmap">{ "imports": {      "@mr_hugo/boredom/dist/boreDOM.full.js": "./boreDOM.js",
       "boredom": "./boreDOM.js"
     } }</script>`
  );
  $("body").append(`
  <script src="boreDOM.js" type="module"></script>`);
  Object.keys(components).forEach((component) => {
    const componentScriptPath = buildRelativeServePath(
      componentsServeUrlPath,
      component,
      `${component}.js`
    );
    const existingComponentScript = $(`script[src*="${component}.js"]`).first();
    const componentCssPath = buildRelativeServePath(
      componentsServeUrlPath,
      component,
      `${component}.css`
    );
    if (components[component].hasJS) {
      if (existingComponentScript.length > 0) {
        existingComponentScript.attr("src", componentScriptPath);
        existingComponentScript.attr("type", "module");
      } else if ($(`script[src="${componentScriptPath}"]`).length === 0) {
        $("body").append(
          `
  <script src="${componentScriptPath}" type="module"></script>`
        );
      }
    }
    if (components[component].hasCSS) {
      const existingComponentStylesheet = $(`link[href*="${component}.css"]`).first();
      if (existingComponentStylesheet.length > 0) {
        existingComponentStylesheet.attr("href", componentCssPath);
      } else if ($(`link[href="${componentCssPath}"]`).length === 0) {
        $("head").append(
          `
  <link rel="stylesheet" href="${componentCssPath}">`
        );
      }
    }
    if ($(`template[data-component="${component}"]`).length === 0) {
      const templateMarkup = `
  ${components[component].templateTag}`;
      const firstScript = $("body > script").first();
      if (firstScript.length > 0) {
        firstScript.before(templateMarkup);
      } else {
        $("body").prepend(templateMarkup);
      }
      console.log(`Injected template for ${component}`);
    }
  });
  $("template[data-component]").each((i, el) => {
    const comp = $(el).attr("data-component");
    if (!components[comp]) {
      $(el).remove();
      console.log(`Removed unused template for ${comp}`);
    }
  });
  const prettyHtml = beautify($.html(), {
    indent_size: 2,
    space_in_empty_paren: true
  });
  const buildIndex = import_path.default.join(BUILD_DIR, "index.html");
  await import_fs_extra.default.outputFile(buildIndex, prettyHtml);
  console.log("Index updated with pretty printed HTML.");
}
async function startServer() {
  if (serverStarted) return;
  function serveFile(req, res, opts) {
    let urlPath = decodeURIComponent(req.url.split(/[?#]/)[0]);
    if (urlPath === "/" || urlPath.endsWith("/")) {
      urlPath = import_path.default.posix.join(urlPath, "index.html");
    }
    const filePath = import_path.default.join(BUILD_DIR, urlPath);
    import_fs_extra.default.pathExists(filePath).then((exists) => {
      if (!exists) {
        res.writeHead(404, { "Content-Type": "text/plain" });
        return res.end("Not Found");
      }
      const contentType = import_mime_types.default.lookup(filePath) || "application/octet-stream";
      res.writeHead(200, { "Content-Type": contentType });
      import_fs_extra.default.createReadStream(filePath).pipe(res);
    }).catch((err) => {
      res.writeHead(500, { "Content-Type": "text/plain" });
      res.end("Internal Server Error");
    });
  }
  const server = import_http.default.createServer((req, res) => {
    return serveFile(req, res, {
      cleanUrls: true,
      public: import_path.default.resolve(BUILD_DIR)
    });
  });
  let port = process.env.PORT || 8080;
  const serverHandler = () => {
    const { port: actualPort } = server.address();
    console.log(`Server running at http://localhost:${actualPort}`);
  };
  server.listen(port, serverHandler);
  server.on("error", (e) => {
    if (e.code === "EADDRINUSE") {
      console.log(
        "\x1B[33m%s\x1B[0m",
        `\u26A0\uFE0F Warning: Port ${port} in use, starting with a OS assigned port.`
      );
      setTimeout(() => {
        server.close();
        server.listen(0);
      }, 1e3);
    }
  });
  serverStarted = true;
}
async function build() {
  await import_fs_extra.default.remove(BUILD_DIR);
  await import_fs_extra.default.ensureDir(BUILD_DIR);
  await copyStatic();
  await copyBoreDOM();
  const components = await processComponents();
  await updateIndex(components);
}
async function watchFiles() {
  const pathsToWatch = [];
  if (options.index) {
    pathsToWatch.push(import_path.default.resolve(options.index));
  }
  if (options.html) {
    pathsToWatch.push(import_path.default.resolve(options.html));
  }
  const staticFolders = Array.isArray(options.static) ? options.static : [options.static].filter(Boolean);
  for (const folder of staticFolders) {
    const staticDir = import_path.default.resolve(folder);
    if (await import_fs_extra.default.pathExists(staticDir)) {
      pathsToWatch.push(staticDir);
    }
  }
  console.log("Watching for file changes in:", pathsToWatch);
  const watcher = import_chokidar.default.watch(pathsToWatch, { ignoreInitial: true });
  let rebuildTimeout;
  watcher.on("all", (event, filePath) => {
    console.log(`Detected ${event} on ${filePath}. Scheduling rebuild...`);
    if (rebuildTimeout) clearTimeout(rebuildTimeout);
    rebuildTimeout = setTimeout(() => {
      build().then(() => {
        console.log(
          `#${++numberOfRefreshes} - ${(/* @__PURE__ */ new Date()).toISOString()} - Build refreshed.`
        );
      }).catch((err) => console.error("Error during rebuild:", err));
    }, 100);
  });
}
async function main(cmdOptions) {
  const opts = cmdOptions || options;
  console.log("The file used as the base for HTML is:", opts.index);
  const indexPath = import_path.default.join(process.cwd(), opts.index);
  import_fs_extra.default.ensureFile(indexPath, (err) => {
    if (err) {
      console.log(
        "\x1B[31m%s\x1B[0m",
        `\u274C Error: The file "${indexPath}" was not found.
Please specify a location for it with "--index"`
      );
      process.exit(1);
    }
  });
  await build();
  startServer();
  await watchFiles();
}
var args = process.argv.slice(2);
var isInitCommand = args[0] === "init";
var isServeCommand = args[0] === "serve";
if (!isTestMode && !isInitCommand && !isServeCommand) {
  main().catch((err) => {
    console.error(err);
    process.exit(1);
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BUILD_DIR,
  build,
  buildRelativeServePath,
  copyBoreDOM,
  getServePaths,
  normalizeServePath,
  options,
  processComponents,
  setServePaths,
  updateIndex
});
