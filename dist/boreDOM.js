#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// boreDOMCLI/generated_cli.js
var generated_cli_exports = {};
__export(generated_cli_exports, {
  BUILD_DIR: () => BUILD_DIR,
  build: () => build,
  buildRelativeServePath: () => buildRelativeServePath,
  copyBoreDOM: () => copyBoreDOM,
  getServePaths: () => getServePaths,
  normalizeServePath: () => normalizeServePath,
  options: () => options,
  processComponents: () => processComponents,
  setServePaths: () => setServePaths,
  updateIndex: () => updateIndex
});
module.exports = __toCommonJS(generated_cli_exports);
var import_fs_extra = __toESM(require("fs-extra"));
var import_mime_types = __toESM(require("mime-types"));
var import_path = __toESM(require("path"));
var glob = __toESM(require("glob"));
var cheerio = __toESM(require("cheerio"));
var import_commander = require("commander");
var import_http = __toESM(require("http"));
var import_finalhandler = __toESM(require("finalhandler"));
var import_js_beautify = __toESM(require("js-beautify"));
var import_chokidar = __toESM(require("chokidar"));
var import_serve_handler = __toESM(require("serve-handler"));
var boredom = `
Ly8gc3JjL2RvbS50cwp2YXIgZHluYW1pY0ltcG9ydFNjcmlwdHMgPSBhc3luYyAobmFtZXMpID0+IHsKICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpOwogIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHsKICAgIGNvbnN0IHNjcmlwdExvY2F0aW9uID0gcXVlcnkoYHNjcmlwdFtzcmMqPSIke25hbWVzW2ldfSJdYCk/LmdldEF0dHJpYnV0ZSgKICAgICAgInNyYyIKICAgICk7CiAgICBsZXQgZiA9IG51bGw7CiAgICBpZiAoc2NyaXB0TG9jYXRpb24pIHsKICAgICAgdHJ5IHsKICAgICAgICBjb25zdCBleHBvcnRzID0gYXdhaXQgaW1wb3J0KHNjcmlwdExvY2F0aW9uKTsKICAgICAgICBmb3IgKGNvbnN0IGV4cG9ydGVkIG9mIE9iamVjdC5rZXlzKGV4cG9ydHMpKSB7CiAgICAgICAgICBmID0gZXhwb3J0c1tleHBvcnRlZF07CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgcmVzdWx0LnNldChuYW1lc1tpXSwgZik7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBjb25zb2xlLmVycm9yKGBVbmFibGUgdG8gaW1wb3J0ICIke3NjcmlwdExvY2F0aW9ufSJgLCBlKTsKICAgICAgfQogICAgfQogIH0KICByZXR1cm4gcmVzdWx0Owp9Owp2YXIgc2VhcmNoRm9yQ29tcG9uZW50cyA9ICgpID0+IHsKICByZXR1cm4gQXJyYXkuZnJvbShxdWVyeUFsbCgidGVtcGxhdGVbZGF0YS1jb21wb25lbnRdIikpLmZpbHRlcigoZWxlbSkgPT4gZWxlbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KS5tYXAoKHQpID0+IHsKICAgIGNvbnN0IHJlc3VsdCA9IHsKICAgICAgbmFtZTogIiIsCiAgICAgIGF0dHJpYnV0ZXM6IFtdCiAgICB9OwogICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gdC5kYXRhc2V0KSB7CiAgICAgIGlmIChhdHRyaWJ1dGUgPT09ICJjb21wb25lbnQiKSB7CiAgICAgICAgcmVzdWx0Lm5hbWUgPSB0LmRhdGFzZXRbYXR0cmlidXRlXSA/PyAiIjsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXN1bHQuYXR0cmlidXRlcy5wdXNoKFsKICAgICAgICAgIGRlY2FtZWxpemUoYXR0cmlidXRlKSwKICAgICAgICAgIHQuZGF0YXNldFthdHRyaWJ1dGVdID8/ICIiCiAgICAgICAgXSk7CiAgICAgIH0KICAgIH0KICAgIGlmIChyZXN1bHQubmFtZSA9PT0gIiIpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKAogICAgICAgIGBBIDx0ZW1wbGF0ZT4gd2FzIGZvdW5kIHdpdGggYW4gaW52YWxpZCBkYXRhLWNvbXBvbmVudDogIiR7dC5kYXRhc2V0LmNvbXBvbmVudH0iYAogICAgICApOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9KS5tYXAoKHsgbmFtZSwgYXR0cmlidXRlcyB9KSA9PiB7CiAgICBjb21wb25lbnQobmFtZSwgeyBhdHRyaWJ1dGVzIH0pOwogICAgcmV0dXJuIG5hbWU7CiAgfSk7Cn07CnZhciBjcmVhdGVDb21wb25lbnQgPSAobmFtZSwgdXBkYXRlKSA9PiB7CiAgY29uc3QgZWxlbWVudCA9IGNyZWF0ZShuYW1lKTsKICBpZiAoIWlzQm9yZWQoZWxlbWVudCkpIHsKICAgIGNvbnN0IGVycm9yID0gYFRoZSB0YWcgbmFtZSAiJHtuYW1lfSIgaXMgbm90IGEgQm9yZURPTSAgY29tcG9uZW50LgogICAgICAKImNyZWF0ZUNvbXBvbmVudCIgb25seSBhY2NlcHRzIHRhZy1uYW1lcyB3aXRoIG1hdGNoaW5nIDx0ZW1wbGF0ZT4gdGFncyB0aGF0IGhhdmUgYSBkYXRhLWNvbXBvbmVudCBhdHRyaWJ1dGUgaW4gdGhlbS5gOwogICAgY29uc29sZS5lcnJvcihlcnJvcik7CiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpOwogIH0KICBpZiAodXBkYXRlKSB7CiAgICBlbGVtZW50LnJlbmRlckNhbGxiYWNrID0gdXBkYXRlOwogIH0KICByZXR1cm4gZWxlbWVudDsKfTsKdmFyIHF1ZXJ5Q29tcG9uZW50ID0gKHEpID0+IHsKICBjb25zdCBlbGVtID0gcXVlcnkocSk7CiAgaWYgKGVsZW0gPT09IG51bGwgfHwgIWlzQm9yZWQoZWxlbSkpIHsKICAgIHJldHVybiB2b2lkIDA7CiAgfQogIHJldHVybiBlbGVtOwp9Owp2YXIgcXVlcnkgPSAocXVlcnkyKSA9PiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5Mik7CnZhciBxdWVyeUFsbCA9IChxdWVyeTIpID0+IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkyKTsKdmFyIGNyZWF0ZSA9ICh0YWdOYW1lLCBjaGlsZHJlbikgPT4gewogIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpOwogIGlmIChjaGlsZHJlbiAmJiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPiAwKSB7CiAgICBjaGlsZHJlbi5tYXAoKGMpID0+IGUuYXBwZW5kQ2hpbGQoYykpOwogIH0KICByZXR1cm4gZTsKfTsKdmFyIGRpc3BhdGNoID0gKG5hbWUsIGRldGFpbCkgPT4gewogIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAibG9hZGluZyIpIHsKICAgIGFkZEV2ZW50TGlzdGVuZXIoCiAgICAgICJET01Db250ZW50TG9hZGVkIiwKICAgICAgKCkgPT4gZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQobmFtZSwgeyBkZXRhaWwgfSkpCiAgICApOwogIH0gZWxzZSB7CiAgICBkaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChuYW1lLCB7IGRldGFpbCB9KSk7CiAgfQp9Owp2YXIgaXNPYmplY3QgPSAodCkgPT4gdHlwZW9mIHQgPT09ICJvYmplY3QiOwp2YXIgaXNGdW5jdGlvbiA9ICh0KSA9PiB0eXBlb2YgdCA9PT0gImZ1bmN0aW9uIjsKdmFyIGlzQm9yZWQgPSAodCkgPT4gaXNPYmplY3QodCkgJiYgImlzQm9yZWQiIGluIHQgJiYgQm9vbGVhbih0LmlzQm9yZWQpOwp2YXIgZGVjYW1lbGl6ZSA9IChzdHIpID0+IHsKICBpZiAoc3RyID09PSAiIiB8fCAhc3RyLnNwbGl0KCIiKS5zb21lKChjaGFyKSA9PiBjaGFyICE9PSBjaGFyLnRvTG93ZXJDYXNlKCkpKSB7CiAgICByZXR1cm4gc3RyOwogIH0KICBsZXQgcmVzdWx0ID0gIiI7CiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHsKICAgIGNvbnN0IGNoYXIgPSBzdHJbaV07CiAgICBpZiAoY2hhciA9PT0gY2hhci50b1VwcGVyQ2FzZSgpICYmIGkgIT09IDApIHsKICAgICAgcmVzdWx0ICs9ICItIjsKICAgIH0KICAgIHJlc3VsdCArPSBjaGFyLnRvTG93ZXJDYXNlKCk7CiAgfQogIHJldHVybiByZXN1bHQ7Cn07CnZhciBpc1N0YXJ0c1dpdGhPbiA9IChzKSA9PiBzLnN0YXJ0c1dpdGgoIm9uIik7CnZhciBpc1N0YXJ0c1dpdGhRdWVyaWVkT24gPSAocykgPT4gcy5zdGFydHNXaXRoKCJxdWVyaWVkT24iKTsKdmFyIGdldEV2ZW50TmFtZSA9IChzKSA9PiB7CiAgaWYgKGlzU3RhcnRzV2l0aE9uKHMpKSB7CiAgICByZXR1cm4gcy5zbGljZSgyKS50b0xvd2VyQ2FzZSgpOwogIH0KICByZXR1cm4gcy5zbGljZSg5KS50b0xvd2VyQ2FzZSgpOwp9Owp2YXIgQm9yZWQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHsKfTsKdmFyIGNvbXBvbmVudCA9ICh0YWcsIHByb3BzID0ge30pID0+IHsKICBpZiAoY3VzdG9tRWxlbWVudHMuZ2V0KHRhZykpIHJldHVybjsKICBjdXN0b21FbGVtZW50cy5kZWZpbmUoCiAgICB0YWcsCiAgICBjbGFzcyBleHRlbmRzIEJvcmVkIHsKICAgICAgLy8gU3BlY2lmeSBvYnNlcnZlZCBhdHRyaWJ1dGVzIHNvIHRoYXQKICAgICAgLy8gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIHdpbGwgd29yawogICAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsKICAgICAgICBpZiAodHlwZW9mIHByb3BzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9PT0gIm9iamVjdCIpIHsKICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhwcm9wcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spOwogICAgICAgIH0KICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgc3VwZXIoKTsKICAgICAgfQogICAgICAvKioKICAgICAgICogVXNlZnVsIHRvIGtub3cgaWYgYSBnaXZlbiBIVE1MRWxlbWVudCBpcyBhIEJvcmVkIGNvbXBvbmVudC4KICAgICAgICogQHNlZSBgaXNCb3JlZCgpYCB0eXBlZ3VhcmQKICAgICAgICovCiAgICAgIGlzQm9yZWQgPSB0cnVlOwogICAgICB0cmF2ZXJzZShmLCB7IHRyYXZlcnNlU2hhZG93Um9vdCwgcXVlcnk6IHF1ZXJ5MiB9ID0ge30pIHsKICAgICAgICBBcnJheS5mcm9tKAogICAgICAgICAgdHJhdmVyc2VTaGFkb3dSb290ID8gdGhpcy5zaGFkb3dSb290Py5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5MiA/PyAiKiIpID8/IFtdIDogW10KICAgICAgICApLmNvbmNhdChBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbChxdWVyeTIgPz8gIioiKSkpLmZpbHRlcigobikgPT4gbiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KS5mb3JFYWNoKGYpOwogICAgICB9CiAgICAgIC8qKgogICAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGN1c3RvbSBldmVudCBuYW1lcyBmcm9tIGEgc3RyaW5nIHRoYXQgaXMgc2hhcGVkIGxpa2U6CiAgICAgICAqIGAiZGlzcGF0Y2goJ2V2ZW50MScsICdldmVudDInLCAuLi4pImAKICAgICAgICoKICAgICAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiB0cmF2ZXJzaW5nIGZvciBldmVudCBoYW5kbGVycyB0byBiZSByZXBsYWNlZAogICAgICAgKiB3aXRoIGN1c3RvbSBkaXNwYXRjaGVycy4KICAgICAgICogQHJldHVybnMgYW4gYXJyYXkgb2Ygc3RyaW5ncwogICAgICAgKi8KICAgICAgLyoqIEV4dHJhY3RzIGV2ZW50IG5hbWVzIGZyb20gc3RyaW5ncyBsaWtlICJkaXNwYXRjaCgnYScsJ2InKSIgKi8KICAgICAgI3BhcnNlQ3VzdG9tRXZlbnROYW1lcyhzdHIpIHsKICAgICAgICByZXR1cm4gc3RyLnNwbGl0KCInIikuZmlsdGVyKAogICAgICAgICAgKHMpID0+IHMubGVuZ3RoID4gMiAmJiAhKHMuaW5jbHVkZXMoIigiKSB8fCBzLmluY2x1ZGVzKCIsIikgfHwgcy5pbmNsdWRlcygiKSIpKQogICAgICAgICk7CiAgICAgIH0KICAgICAgLyoqCiAgICAgICAqIFJlcGxhY2VzIGlubGluZSBvbiogYXR0cmlidXRlcyB3aXRoaW4gdGhlIGNvbXBvbmVudCBET00gd2l0aCByZWFsCiAgICAgICAgKiBsaXN0ZW5lcnMgdGhhdCBkaXNwYXRjaCBjdXN0b20gZXZlbnRzIHVzaW5nIGRpc3BhdGNoKCkuCiAgICAgICAqLwogICAgICAjY3JlYXRlRGlzcGF0Y2hlcnMoKSB7CiAgICAgICAgbGV0IGhvc3Q7CiAgICAgICAgdGhpcy50cmF2ZXJzZSgobm9kZSkgPT4gewogICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgewogICAgICAgICAgICBjb25zdCBpc1dlYkNvbXBvbmVudCA9IGN1c3RvbUVsZW1lbnRzLmdldCgKICAgICAgICAgICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKQogICAgICAgICAgICApOwogICAgICAgICAgICBpZiAoaXNXZWJDb21wb25lbnQpIGhvc3QgPSBub2RlOwogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tpXTsKICAgICAgICAgICAgICBpZiAoaXNTdGFydHNXaXRoT24oYXR0cmlidXRlLm5hbWUpKSB7CiAgICAgICAgICAgICAgICBjb25zdCBldmVudE5hbWVzID0gdGhpcy4jcGFyc2VDdXN0b21FdmVudE5hbWVzKGF0dHJpYnV0ZS52YWx1ZSk7CiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lcy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZXMuZm9yRWFjaCgoY3VzdG9tRXZlbnROYW1lKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKAogICAgICAgICAgICAgICAgICAgICAgZ2V0RXZlbnROYW1lKGF0dHJpYnV0ZS5uYW1lKSwKICAgICAgICAgICAgICAgICAgICAgIChlKSA9PiBkaXNwYXRjaChjdXN0b21FdmVudE5hbWUsIHsKICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGUsCiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoZXI6IG5vZGUsCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcywKICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMucGFyZW50RWxlbWVudCA/IEFycmF5LmZyb20odGhpcy5wYXJlbnRFbGVtZW50LmNoaWxkcmVuKS5pbmRleE9mKAogICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMKICAgICAgICAgICAgICAgICAgICAgICAgKSA6IC0xCiAgICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoCiAgICAgICAgICAgICAgICAgIGBkYXRhLSR7YXR0cmlidXRlLm5hbWV9LWRpc3BhdGNoZXNgLAogICAgICAgICAgICAgICAgICBldmVudE5hbWVzLmpvaW4oKQogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZS5uYW1lKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCB7IHRyYXZlcnNlU2hhZG93Um9vdDogdHJ1ZSB9KTsKICAgICAgfQogICAgICBpc0luaXRpYWxpemVkID0gZmFsc2U7CiAgICAgICNpbml0KCkgewogICAgICAgIGxldCB0ZW1wbGF0ZSA9IHF1ZXJ5KGBbZGF0YS1jb21wb25lbnQ9IiR7dGFnfSJdYCkgPz8gY3JlYXRlKCJ0ZW1wbGF0ZSIpOwogICAgICAgIGNvbnN0IGlzVGVtcGxhdGVTaGFkb3dSb290ID0gdGVtcGxhdGUuZ2V0QXR0cmlidXRlKCJzaGFkb3dyb290bW9kZSIpOwogICAgICAgIGNvbnN0IGlzU2hhZG93Um9vdE5lZWRlZCA9IHByb3BzLnN0eWxlIHx8IHByb3BzLnNoYWRvdyB8fCBpc1RlbXBsYXRlU2hhZG93Um9vdDsKICAgICAgICBpZiAoaXNTaGFkb3dSb290TmVlZGVkKSB7CiAgICAgICAgICBjb25zdCBzaGFkb3dSb290TW9kZSA9IHByb3BzLnNoYWRvd3Jvb3Rtb2RlID8/IGlzVGVtcGxhdGVTaGFkb3dSb290ID8/ICJvcGVuIjsKICAgICAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6IHNoYWRvd1Jvb3RNb2RlIH0pOwogICAgICAgICAgaWYgKHByb3BzLnN0eWxlKSB7CiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gY3JlYXRlKCJzdHlsZSIpOwogICAgICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHByb3BzLnN0eWxlOwogICAgICAgICAgICBzaGFkb3dSb290LmFwcGVuZENoaWxkKHN0eWxlKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChwcm9wcy5zaGFkb3cpIHsKICAgICAgICAgICAgY29uc3QgdG1wID0gY3JlYXRlKCJ0ZW1wbGF0ZSIpOwogICAgICAgICAgICB0bXAuaW5uZXJIVE1MID0gcHJvcHMuc2hhZG93OwogICAgICAgICAgICBzaGFkb3dSb290LmFwcGVuZENoaWxkKHRtcC5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7CiAgICAgICAgICB9IGVsc2UgaWYgKGlzVGVtcGxhdGVTaGFkb3dSb290KSB7CiAgICAgICAgICAgIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAodGVtcGxhdGUgJiYgIWlzVGVtcGxhdGVTaGFkb3dSb290KSB7CiAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTsKICAgICAgICB9CiAgICAgICAgaWYgKHByb3BzLm9uU2xvdENoYW5nZSkgewogICAgICAgICAgdGhpcy50cmF2ZXJzZSgoZWxlbSkgPT4gewogICAgICAgICAgICBpZiAoIShlbGVtIGluc3RhbmNlb2YgSFRNTFNsb3RFbGVtZW50KSkgcmV0dXJuOwogICAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoInNsb3RjaGFuZ2UiLCAoZSkgPT4gcHJvcHMub25TbG90Q2hhbmdlPy4oZSkpOwogICAgICAgICAgfSwgeyB0cmF2ZXJzZVNoYWRvd1Jvb3Q6IHRydWUgfSk7CiAgICAgICAgfQogICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3BzLm9uQ2xpY2spKSB7CiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoImNsaWNrIiwgcHJvcHMub25DbGljayk7CiAgICAgICAgfQogICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkgewogICAgICAgICAgaWYgKGlzU3RhcnRzV2l0aE9uKGtleSkpIHsKICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkgY29udGludWU7CiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihnZXRFdmVudE5hbWUoa2V5KSwgdmFsdWUpOwogICAgICAgICAgfSBlbHNlIGlmIChpc1N0YXJ0c1dpdGhRdWVyaWVkT24oa2V5KSkgewogICAgICAgICAgICBjb25zdCBxdWVyaWVzID0gdmFsdWU7CiAgICAgICAgICAgIGlmICghaXNPYmplY3QocXVlcmllcykpIGNvbnRpbnVlOwogICAgICAgICAgICBjb25zdCBldmVudE5hbWUgPSBnZXRFdmVudE5hbWUoa2V5KTsKICAgICAgICAgICAgZm9yIChjb25zdCBbcXVlcnkyLCBoYW5kbGVyXSBvZiBPYmplY3QuZW50cmllcyhxdWVyaWVzKSkgewogICAgICAgICAgICAgIHRoaXMudHJhdmVyc2UoKG5vZGUpID0+IHsKICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpOwogICAgICAgICAgICAgIH0sIHsgdHJhdmVyc2VTaGFkb3dSb290OiB0cnVlLCBxdWVyeTogcXVlcnkyIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChwcm9wcy5hdHRyaWJ1dGVzICYmIEFycmF5LmlzQXJyYXkocHJvcHMuYXR0cmlidXRlcykpIHsKICAgICAgICAgIHByb3BzLmF0dHJpYnV0ZXMubWFwKAogICAgICAgICAgICAoW2F0dHIsIHZhbHVlXSkgPT4gdGhpcy5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICB0aGlzLiNjcmVhdGVEaXNwYXRjaGVycygpOwogICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7CiAgICAgIH0KICAgICAgLyoqCiAgICAgICAqIFVzZXItcHJvdmlkZWQgcmVuZGVyZXIgaXMgYXNzaWduZWQgaGVyZSBieSBjcmVhdGVDb21wb25lbnQuCiAgICAgICAqIENhbGxlZCBvbiBjb25uZWN0IGFuZCB3aGVuZXZlciBzdGF0ZSB0cmlnZ2VycyBzdWJzY3JpcHRpb25zLgogICAgICAgKi8KICAgICAgcmVuZGVyQ2FsbGJhY2sgPSAoXykgPT4gewogICAgICB9OwogICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHsKICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgdGhpcy4jaW5pdCgpOwogICAgICAgIHRoaXMucmVuZGVyQ2FsbGJhY2sodGhpcyk7CiAgICAgICAgcHJvcHMuY29ubmVjdGVkQ2FsbGJhY2s/Lih0aGlzKTsKICAgICAgfQogICAgICBzbG90cyA9IGNyZWF0ZVNsb3RzQWNjZXNzb3IodGhpcyk7CiAgICAgIC8qCiAgICAgICAgICAgICNjcmVhdGVTbG90cygpIHsKICAgICAgICAgICAgICBjb25zdCBzbG90cyA9IEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCJzbG90IikpOwogICAgICAgICAgICAgIGNvbnN0IHdlYkNvbXBvbmVudCA9IHRoaXM7CiAgICAgIAogICAgICAgICAgICAgIHNsb3RzLmZvckVhY2goKHNsb3QpID0+IHsKICAgICAgICAgICAgICAgIGNvbnN0IHNsb3ROYW1lID0gc2xvdC5nZXRBdHRyaWJ1dGUoIm5hbWUiKTsKICAgICAgICAgICAgICAgIGlmICghc2xvdE5hbWUpIHJldHVybjsKICAgICAgCiAgICAgICAgICAgICAgICBjb25zdCBjYW1lbGl6ZWRTbG90TmFtZSA9IGNhbWVsaXplKHNsb3ROYW1lKTsKICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3ZWJDb21wb25lbnQuc2xvdHMsIGNhbWVsaXplZFNsb3ROYW1lLCB7CiAgICAgICAgICAgICAgICAgIGdldCgpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2ViQ29tcG9uZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXNsb3Q9IiR7c2xvdE5hbWV9Il1gKTsKICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7CiAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW0gPSB2YWx1ZTsKICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgewogICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0QXR0cmlidXRlKCJkYXRhLXNsb3QiLCBzbG90TmFtZSk7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gY3JlYXRlKCJzcGFuIik7CiAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgiZGF0YS1zbG90Iiwgc2xvdE5hbWUpOwogICAgICAgICAgICAgICAgICAgICAgZWxlbS5pbm5lclRleHQgPSB2YWx1ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgIAogICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU2xvdCA9IHRoaXNbY2FtZWxpemVkU2xvdE5hbWVdOwogICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1Nsb3QpIHsKICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nU2xvdC5wYXJlbnRFbGVtZW50LnJlcGxhY2VDaGlsZChlbGVtLCBleGlzdGluZ1Nsb3QpOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBzbG90LnBhcmVudEVsZW1lbnQ/LnJlcGxhY2VDaGlsZChlbGVtLCBzbG90KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgICAgICAqLwogICAgICB1cGRhdGVTbG90KHNsb3ROYW1lLCBjb250ZW50LCB3aXRoaW5UYWcpIHsKICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHdpdGhpblRhZyk7CiAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgic2xvdCIsIHNsb3ROYW1lKTsKICAgICAgfQogICAgICAvKgogICAgICAgICAgICAjY3JlYXRlUHJvcGVydGllcygpIHsKICAgICAgICAgICAgICBjb25zdCBlbGVtZW50c0ZvdW5kID0gZG9jdW1lbnQuZXZhbHVhdGUoCiAgICAgICAgICAgICAgICAiLy8qW2NvbnRhaW5zKHRleHQoKSwndGhpcy4nKV0iLAogICAgICAgICAgICAgICAgZG9jdW1lbnQsCiAgICAgICAgICAgICAgICBudWxsLAogICAgICAgICAgICAgICAgWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEUsCiAgICAgICAgICAgICAgICBudWxsLAogICAgICAgICAgICAgICk7CiAgICAgIAogICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gbnVsbDsKICAgICAgICAgICAgICB3aGlsZSAoZWxlbWVudCA9IGVsZW1lbnRzRm91bmQuaXRlcmF0ZU5leHQoKSkgewogICAgICAgICAgICAgICAgY29uc29sZS5sb2coIkZvdW5kICIsIGVsZW1lbnQpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICAqLwogICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHsKICAgICAgICBjb25zb2xlLmxvZygiZGlzY29ubmVjdGVkICIgKyB0aGlzLnRhZ05hbWUpOwogICAgICAgIHByb3BzLmRpc2Nvbm5lY3RlZENhbGxiYWNrPy4odGhpcyk7CiAgICAgIH0KICAgICAgYWRvcHRlZENhbGxiYWNrKCkgewogICAgICAgIGNvbnNvbGUubG9nKCJhZG9wdGVkICIgKyB0aGlzLnRhZ05hbWUpOwogICAgICAgIHByb3BzLmFkb3B0ZWRDYWxsYmFjaz8uKHRoaXMpOwogICAgICB9CiAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHsKICAgICAgICBpZiAoIXByb3BzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaykgcmV0dXJuOwogICAgICAgIHByb3BzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja1tuYW1lXSh7CiAgICAgICAgICBlbGVtZW50OiB0aGlzLAogICAgICAgICAgbmFtZSwKICAgICAgICAgIG9sZFZhbHVlLAogICAgICAgICAgbmV3VmFsdWUKICAgICAgICB9KTsKICAgICAgfQogICAgfQogICk7Cn07CgovLyBzcmMvdXRpbHMvYWNjZXNzLnRzCmZ1bmN0aW9uIGFjY2VzcyhwYXRoLCBvYmopIHsKICBsZXQgcmVzdWx0ID0gb2JqOwogIGlmIChvYmogPT09IG51bGwpIHJldHVybiByZXN1bHQ7CiAgcGF0aC5mb3JFYWNoKChhdHRyaWJ1dGUpID0+IHsKICAgIHJlc3VsdCA9IHJlc3VsdFthdHRyaWJ1dGVdOwogIH0pOwogIHJldHVybiByZXN1bHQ7Cn0KCi8vIHNyYy91dGlscy9mbGF0dGVuLnRzCmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBpZ25vcmUgPSBbXSkgewogIGNvbnN0IHN0YWNrID0gW3sKICAgIHBhdGg6IFtdLAogICAgb2JqCiAgfV07CiAgY29uc3QgcmVzdWx0ID0gW107CiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHsKICAgIGNvbnN0IHsgcGF0aCwgb2JqOiBvYmoyIH0gPSBzdGFjay5wb3AoKTsKICAgIGZvciAoY29uc3Qga2V5IGluIG9iajIpIHsKICAgICAgaWYgKGlnbm9yZS5pbmNsdWRlcyhrZXkpKSBjb250aW51ZTsKICAgICAgY29uc3QgdmFsdWUgPSBvYmoyW2tleV07CiAgICAgIGNvbnN0IG5ld1BhdGggPSBwYXRoLmNvbmNhdChrZXkpOwogICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAib2JqZWN0IiAmJiB2YWx1ZSAhPT0gbnVsbCkgewogICAgICAgIHN0YWNrLnB1c2goewogICAgICAgICAgcGF0aDogbmV3UGF0aCwKICAgICAgICAgIG9iajogdmFsdWUKICAgICAgICB9KTsKICAgICAgfQogICAgICByZXN1bHQucHVzaCh7IHBhdGg6IG5ld1BhdGgsIHZhbHVlIH0pOwogICAgfQogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovLyBzcmMvdXRpbHMvaXNQb2pvLnRzCmZ1bmN0aW9uIGlzUE9KTyhhcmcpIHsKICBpZiAoYXJnID09IG51bGwgfHwgdHlwZW9mIGFyZyAhPT0gIm9iamVjdCIpIHsKICAgIHJldHVybiBmYWxzZTsKICB9CiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXJnKTsKICBpZiAocHJvdG8gPT0gbnVsbCkgewogICAgcmV0dXJuIHRydWU7CiAgfQogIHJldHVybiBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZTsKfQoKLy8gc3JjL2JvcmUudHMKZnVuY3Rpb24gY3JlYXRlRXZlbnRzSGFuZGxlcihjLCBhcHAsIGRldGFpbCkgewogIHJldHVybiAoZXZlbnROYW1lLCBoYW5kbGVyKSA9PiB7CiAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgKGUpID0+IHsKICAgICAgbGV0IHRhcmdldCA9IGU/LmRldGFpbD8uZXZlbnQuY3VycmVudFRhcmdldDsKICAgICAgbGV0IGVtaXRlckVsZW0gPSB2b2lkIDA7CiAgICAgIHdoaWxlICh0YXJnZXQpIHsKICAgICAgICBpZiAodGFyZ2V0ID09PSBjKSB7CiAgICAgICAgICBoYW5kbGVyKHsgc3RhdGU6IGFwcCwgZTogZS5kZXRhaWwsIGRldGFpbCB9KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7CiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGFyZ2V0ID0gdm9pZCAwOwogICAgICAgIH0KICAgICAgfQogICAgfSk7CiAgfTsKfQpmdW5jdGlvbiBjcmVhdGVSZWZzQWNjZXNzb3IoYykgewogIHJldHVybiBuZXcgUHJveHkoe30sIHsKICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7CiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKAogICAgICAgIGBSZWYgIiR7U3RyaW5nKHByb3ApfSIgbm90IGZvdW5kIGluIDwke2MudGFnTmFtZX0+YAogICAgICApOwogICAgICBpZiAodHlwZW9mIHByb3AgPT09ICJzdHJpbmciKSB7CiAgICAgICAgY29uc3Qgbm9kZUxpc3QgPSBjLnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXJlZj0iJHtwcm9wfSJdYCk7CiAgICAgICAgaWYgKCFub2RlTGlzdCkgdGhyb3cgZXJyb3I7CiAgICAgICAgY29uc3QgcmVmcyA9IEFycmF5LmZyb20obm9kZUxpc3QpLmZpbHRlcigKICAgICAgICAgIChyZWYpID0+IHJlZiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50CiAgICAgICAgKTsKICAgICAgICBpZiAocmVmcy5sZW5ndGggPT09IDApIHRocm93IGVycm9yOwogICAgICAgIGlmIChyZWZzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHJlZnNbMF07CiAgICAgICAgcmV0dXJuIHJlZnM7CiAgICAgIH0KICAgIH0KICB9KTsKfQpmdW5jdGlvbiBjcmVhdGVTbG90c0FjY2Vzc29yKGMpIHsKICByZXR1cm4gbmV3IFByb3h5KHt9LCB7CiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNpZXZlcikgewogICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcigKICAgICAgICBgU2xvdCAiJHtTdHJpbmcocHJvcCl9IiBub3QgZm91bmQgaW4gPCR7Yy50YWdOYW1lfT5gCiAgICAgICk7CiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gInN0cmluZyIpIHsKICAgICAgICBjb25zdCBub2RlTGlzdCA9IGMucXVlcnlTZWxlY3RvckFsbChgc2xvdFtuYW1lPSIke3Byb3B9Il1gKTsKICAgICAgICBpZiAoIW5vZGVMaXN0KSB0aHJvdyBlcnJvcjsKICAgICAgICBjb25zdCByZWZzID0gQXJyYXkuZnJvbShub2RlTGlzdCkuZmlsdGVyKAogICAgICAgICAgKHJlZikgPT4gcmVmIGluc3RhbmNlb2YgSFRNTFNsb3RFbGVtZW50CiAgICAgICAgKTsKICAgICAgICBpZiAocmVmcy5sZW5ndGggPT09IDApIHRocm93IGVycm9yOwogICAgICAgIGlmIChyZWZzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHJlZnNbMF07CiAgICAgICAgcmV0dXJuIHJlZnM7CiAgICAgIH0KICAgIH0sCiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkgewogICAgICBpZiAodHlwZW9mIHByb3AgIT09ICJzdHJpbmciKSByZXR1cm4gZmFsc2U7CiAgICAgIGxldCBlbGVtID0gdmFsdWU7CiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7CiAgICAgICAgdmFsdWUuc2V0QXR0cmlidXRlKCJkYXRhLXNsb3QiLCBwcm9wKTsKICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICJzdHJpbmciKSB7CiAgICAgICAgZWxlbSA9IGNyZWF0ZSgic3BhbiIpOwogICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCJkYXRhLXNsb3QiLCBwcm9wKTsKICAgICAgICBlbGVtLmlubmVyVGV4dCA9IHZhbHVlOwogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3Igc2xvdCAke3Byb3B9IGluIDwke2MudGFnTmFtZX0+YCk7CiAgICAgIH0KICAgICAgY29uc3QgZXhpc3RpbmdTbG90cyA9IEFycmF5LmZyb20oCiAgICAgICAgYy5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1zbG90PSIke3Byb3B9Il1gKQogICAgICApOwogICAgICBpZiAoZXhpc3RpbmdTbG90cy5sZW5ndGggPiAwKSB7CiAgICAgICAgZXhpc3RpbmdTbG90cy5mb3JFYWNoKChzKSA9PiBzLnBhcmVudEVsZW1lbnQ/LnJlcGxhY2VDaGlsZChlbGVtLCBzKSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3Qgc2xvdHMgPSBBcnJheS5mcm9tKGMucXVlcnlTZWxlY3RvckFsbChgc2xvdFtuYW1lPSIke3Byb3B9Il1gKSk7CiAgICAgICAgc2xvdHMuZm9yRWFjaCgocykgPT4gcy5wYXJlbnRFbGVtZW50Py5yZXBsYWNlQ2hpbGQoZWxlbSwgcykpOwogICAgICB9CiAgICAgIHJldHVybiB0cnVlOwogICAgfQogIH0pOwp9CmZ1bmN0aW9uIGNyZWF0ZVN0YXRlQWNjZXNzb3Ioc3RhdGUsIGxvZywgYWNjdW0pIHsKICBjb25zdCBjdXJyZW50ID0gYWNjdW0gfHwgeyB0YXJnZXRzOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgcGF0aDogW10gfTsKICBpZiAoc3RhdGUgPT09IHZvaWQgMCkgcmV0dXJuIHZvaWQgMDsKICByZXR1cm4gbmV3IFByb3h5KHN0YXRlLCB7CiAgICAvLyBTdGF0ZSBhY2Nlc3NvcnMgYXJlIHJlYWQtb25seToKICAgIHNldCh0YXJnZXQsIHByb3AsIG5ld1ZhbHVlKSB7CiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gInN0cmluZyIpIHsKICAgICAgICBjb25zb2xlLmVycm9yKAogICAgICAgICAgYFN0YXRlIGlzIHJlYWQtb25seSBmb3Igd2ViIGNvbXBvbmVudHMuIFVuYWJsZSB0byBzZXQgJyR7cHJvcH0nLmAKICAgICAgICApOwogICAgICB9CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0sCiAgICAvLyBSZWN1cnNpdmVseSBidWlsZCBhIHByb3h5IGZvciBlYWNoIHN0YXRlIHByb3AgYmVpbmcgcmVhZDoKICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7CiAgICAgIGNvbnN0IHZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7CiAgICAgIGNvbnN0IGlzUHJvdG8gPSBwcm9wID09PSAiX19wcm90b19fIjsKICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAic3RyaW5nIiAmJiAhaXNQcm90bykgewogICAgICAgIGlmICghY3VycmVudC50YXJnZXRzLmhhcyh0YXJnZXQpKSB7CiAgICAgICAgICBjdXJyZW50LnRhcmdldHMuc2V0KHRhcmdldCwgY3VycmVudC5wYXRoLmpvaW4oIi4iKSk7CiAgICAgICAgICBjdXJyZW50LnBhdGgucHVzaChwcm9wKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKGlzUHJvdG8gfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQT0pPKHZhbHVlKSkgewogICAgICAgIHJldHVybiBjcmVhdGVTdGF0ZUFjY2Vzc29yKHZhbHVlLCBsb2csIGN1cnJlbnQpOwogICAgICB9CiAgICAgIGxldCBwYXRoID0gY3VycmVudC50YXJnZXRzLmdldCh0YXJnZXQpID8/ICIiOwogICAgICBpZiAodHlwZW9mIHBhdGggPT09ICJzdHJpbmciICYmIHR5cGVvZiBwcm9wID09PSAic3RyaW5nIikgewogICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHsKICAgICAgICAgIHBhdGg7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHBhdGggKz0gcGF0aCAhPT0gIiIgPyBgLiR7cHJvcH1gIDogcHJvcDsKICAgICAgICB9CiAgICAgICAgaWYgKGxvZy5pbmRleE9mKHBhdGgpID09PSAtMSkgewogICAgICAgICAgbG9nLnB1c2gocGF0aCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGN1cnJlbnQucGF0aC5sZW5ndGggPSAwOwogICAgICBjdXJyZW50LnBhdGgucHVzaChwYXRoKTsKICAgICAgcmV0dXJuIHZhbHVlOwogICAgfQogIH0pOwp9CmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmliZXJzRGlzcGF0Y2hlcihzdGF0ZSkgewogIHJldHVybiAoKSA9PiB7CiAgICBjb25zdCB1cGRhdGVzID0gc3RhdGUuaW50ZXJuYWwudXBkYXRlczsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXBkYXRlcy5wYXRoLmxlbmd0aDsgaSsrKSB7CiAgICAgIGNvbnN0IHBhdGggPSB1cGRhdGVzLnBhdGhbaV07CiAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IHVwZGF0ZXMuc3Vic2NyaWJlcnMuZ2V0KHBhdGguc2xpY2UocGF0aC5pbmRleE9mKCIuIikgKyAxKSkgPz8gW107CiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZnVuY3Rpb25zLmxlbmd0aDsgaisrKSB7CiAgICAgICAgZnVuY3Rpb25zW2pdKHN0YXRlLmFwcCk7CiAgICAgIH0KICAgIH0KICAgIHVwZGF0ZXMucGF0aCA9IFtdOwogICAgdXBkYXRlcy52YWx1ZSA9IFtdOwogICAgdXBkYXRlcy5yYWYgPSB2b2lkIDA7CiAgfTsKfQpmdW5jdGlvbiBwcm94aWZ5KGJvcmVkb20pIHsKICBjb25zdCBydW50aW1lID0gYm9yZWRvbS5pbnRlcm5hbDsKICBjb25zdCBzdGF0ZSA9IGJvcmVkb207CiAgaWYgKHN0YXRlID09PSB2b2lkIDApIHJldHVybiBib3JlZG9tOwogIGNvbnN0IG9iamVjdHNXaXRoUHJveGllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpOwogIGZsYXR0ZW4oYm9yZWRvbSwgWyJpbnRlcm5hbCJdKS5mb3JFYWNoKCh7IHBhdGgsIHZhbHVlIH0pID0+IHsKICAgIGNvbnN0IG5lZWRzUHJveHkgPSBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BPSk8odmFsdWUpICYmICFvYmplY3RzV2l0aFByb3hpZXMuaGFzKHZhbHVlKTsKICAgIGlmIChuZWVkc1Byb3h5KSB7CiAgICAgIGNvbnN0IGRvdHRlZFBhdGggPSBwYXRoLmpvaW4oIi4iKTsKICAgICAgY29uc3QgcGFyZW50ID0gYWNjZXNzKHBhdGguc2xpY2UoMCwgLTEpLCBzdGF0ZSk7CiAgICAgIGNvbnN0IGlzUm9vdCA9IHBhcmVudCA9PT0gdmFsdWU7CiAgICAgIGlmIChpc1Jvb3QpIHJldHVybjsKICAgICAgcGFyZW50W3BhdGguYXQoLTEpXSA9IG5ldyBQcm94eSh2YWx1ZSwgewogICAgICAgIHNldCh0YXJnZXQsIHByb3AsIG5ld1ZhbHVlKSB7CiAgICAgICAgICBjb25zdCBpc0NoYW5nZWQgPSB0YXJnZXRbcHJvcF0gIT09IG5ld1ZhbHVlOwogICAgICAgICAgaWYgKCFpc0NoYW5nZWQpIHJldHVybiB0cnVlOwogICAgICAgICAgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCBuZXdWYWx1ZSk7CiAgICAgICAgICBpZiAodHlwZW9mIHByb3AgIT09ICJzdHJpbmciKSByZXR1cm4gdHJ1ZTsKICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgewogICAgICAgICAgICBydW50aW1lLnVwZGF0ZXMucGF0aC5wdXNoKGAke2RvdHRlZFBhdGh9YCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBydW50aW1lLnVwZGF0ZXMucGF0aC5wdXNoKGAke2RvdHRlZFBhdGh9LiR7cHJvcH1gKTsKICAgICAgICAgIH0KICAgICAgICAgIHJ1bnRpbWUudXBkYXRlcy52YWx1ZS5wdXNoKHRhcmdldCk7CiAgICAgICAgICBpZiAoIXJ1bnRpbWUudXBkYXRlcy5yYWYpIHsKICAgICAgICAgICAgcnVudGltZS51cGRhdGVzLnJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgKICAgICAgICAgICAgICBjcmVhdGVTdWJzY3JpYmVyc0Rpc3BhdGNoZXIoYm9yZWRvbSkKICAgICAgICAgICAgKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIG9iamVjdHNXaXRoUHJveGllcy5hZGQodmFsdWUpOwogICAgfQogIH0pOwogIHJldHVybiBib3JlZG9tOwp9CmZ1bmN0aW9uIHJ1bkNvbXBvbmVudHNJbml0aWFsaXplcihzdGF0ZSkgewogIGNvbnN0IHRhZ3NJbkRvbSA9IHN0YXRlLmludGVybmFsLmN1c3RvbVRhZ3MuZmlsdGVyKAogICAgKHRhZykgPT4gKAogICAgICAvLyBBIHRhZyBpcyBjb25zaWRlcmVkIHByZXNlbnQgaWYgYXQgbGVhc3Qgb25lIGluc3RhbmNlIGV4aXN0cyBpbiB0aGUgRE9NCiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFnKSAhPT0gbnVsbAogICAgKQogICk7CiAgY29uc3QgY29tcG9uZW50cyA9IHN0YXRlLmludGVybmFsLmNvbXBvbmVudHM7CiAgZm9yIChjb25zdCBbdGFnTmFtZSwgY29kZV0gb2YgY29tcG9uZW50cy5lbnRyaWVzKCkpIHsKICAgIGlmIChjb2RlID09PSBudWxsIHx8ICF0YWdzSW5Eb20uaW5jbHVkZXModGFnTmFtZSkpIGNvbnRpbnVlOwogICAgY29uc3QgZWxlbWVudHMgPSBBcnJheS5mcm9tKAogICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhZ05hbWUpCiAgICApLmZpbHRlcigoZWwpID0+IGlzQm9yZWQoZWwpKTsKICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHsKICAgICAgY29udGludWU7CiAgICB9CiAgICBlbGVtZW50cy5mb3JFYWNoKChjb21wb25lbnRDbGFzcywgaW5kZXgpID0+IHsKICAgICAgY29kZShzdGF0ZSwgeyBpbmRleCwgbmFtZTogdGFnTmFtZSwgZGF0YTogdm9pZCAwIH0pKAogICAgICAgIGNvbXBvbmVudENsYXNzCiAgICAgICk7CiAgICB9KTsKICB9CiAgcmV0dXJuOwp9CmZ1bmN0aW9uIGNyZWF0ZUFuZFJ1bkNvZGUobmFtZSwgc3RhdGUsIGRldGFpbCkgewogIGNvbnN0IGNvZGUgPSBzdGF0ZS5pbnRlcm5hbC5jb21wb25lbnRzLmdldChuYW1lKTsKICBpZiAoY29kZSkgewogICAgY29uc3QgaW5mbyA9IHsgLi4uZGV0YWlsLCB0YWdOYW1lOiBuYW1lIH07CiAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KG5hbWUsIGNvZGUoc3RhdGUsIGluZm8pKTsKICB9CiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChuYW1lKTsKfQoKLy8gc3JjL2luZGV4LnRzCmFzeW5jIGZ1bmN0aW9uIGluZmxpY3RCb3JlRE9NKHN0YXRlLCBjb21wb25lbnRzTG9naWMpIHsKICBjb25zdCByZWdpc3RlcmVkTmFtZXMgPSBzZWFyY2hGb3JDb21wb25lbnRzKCk7CiAgY29uc3QgY29tcG9uZW50c0NvZGUgPSBhd2FpdCBkeW5hbWljSW1wb3J0U2NyaXB0cyhyZWdpc3RlcmVkTmFtZXMpOwogIGlmIChjb21wb25lbnRzTG9naWMpIHsKICAgIGZvciAoY29uc3QgdGFnTmFtZSBvZiBPYmplY3Qua2V5cyhjb21wb25lbnRzTG9naWMpKSB7CiAgICAgIGNvbXBvbmVudHNDb2RlLnNldCh0YWdOYW1lLCBjb21wb25lbnRzTG9naWNbdGFnTmFtZV0pOwogICAgfQogIH0KICBjb25zdCBpbml0aWFsU3RhdGUgPSB7CiAgICBhcHA6IHN0YXRlLAogICAgaW50ZXJuYWw6IHsKICAgICAgY3VzdG9tVGFnczogcmVnaXN0ZXJlZE5hbWVzLAogICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzQ29kZSwKICAgICAgdXBkYXRlczogewogICAgICAgIHBhdGg6IFtdLAogICAgICAgIHZhbHVlOiBbXSwKICAgICAgICByYWY6IHZvaWQgMCwKICAgICAgICBzdWJzY3JpYmVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKQogICAgICB9CiAgICB9CiAgfTsKICBjb25zdCBwcm94aWZpZWRTdGF0ZSA9IHByb3hpZnkoaW5pdGlhbFN0YXRlKTsKICBydW5Db21wb25lbnRzSW5pdGlhbGl6ZXIocHJveGlmaWVkU3RhdGUpOwogIHJldHVybiBwcm94aWZpZWRTdGF0ZS5hcHA7Cn0KZnVuY3Rpb24gd2ViQ29tcG9uZW50KGluaXRGdW5jdGlvbikgewogIGxldCBpc0luaXRpYWxpemVkID0gbnVsbDsKICBsZXQgcmVuZGVyRnVuY3Rpb247CiAgcmV0dXJuIChhcHBTdGF0ZSwgZGV0YWlsKSA9PiAoYykgPT4gewogICAgY29uc3QgeyBpbnRlcm5hbCwgYXBwIH0gPSBhcHBTdGF0ZTsKICAgIGxldCBsb2cgPSBbXTsKICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlU3RhdGVBY2Nlc3NvcihhcHAsIGxvZyk7CiAgICBjb25zdCByZWZzID0gY3JlYXRlUmVmc0FjY2Vzc29yKGMpOwogICAgY29uc3Qgc2xvdHMgPSBjcmVhdGVTbG90c0FjY2Vzc29yKGMpOwogICAgY29uc3Qgb24gPSBjcmVhdGVFdmVudHNIYW5kbGVyKGMsIGFwcCwgZGV0YWlsKTsKICAgIGlmIChpc0luaXRpYWxpemVkICE9PSBjKSB7CiAgICAgIGNvbnN0IHVwZGF0ZVN1YnNjcmliZXJzID0gYXN5bmMgKCkgPT4gewogICAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gaW50ZXJuYWwudXBkYXRlcy5zdWJzY3JpYmVyczsKICAgICAgICBmb3IgKGxldCBwYXRoIG9mIGxvZykgewogICAgICAgICAgY29uc3QgZnVuY3Rpb25zID0gc3Vic2NyaWJlcnMuZ2V0KHBhdGgpOwogICAgICAgICAgaWYgKGZ1bmN0aW9ucykgewogICAgICAgICAgICBpZiAoIWZ1bmN0aW9ucy5pbmNsdWRlcyhyZW5kZXJGdW5jdGlvbikpIHsKICAgICAgICAgICAgICBmdW5jdGlvbnMucHVzaChyZW5kZXJGdW5jdGlvbik7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN1YnNjcmliZXJzLnNldChwYXRoLCBbcmVuZGVyRnVuY3Rpb25dKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICAgIGNvbnN0IHVzZXJEZWZpbmVkUmVuZGVyZXIgPSBpbml0RnVuY3Rpb24oewogICAgICAgIGRldGFpbCwKICAgICAgICBzdGF0ZSwKICAgICAgICByZWZzLAogICAgICAgIG9uLAogICAgICAgIHNlbGY6IGMKICAgICAgfSk7CiAgICAgIHJlbmRlckZ1bmN0aW9uID0gKHN0YXRlMikgPT4gewogICAgICAgIHVzZXJEZWZpbmVkUmVuZGVyZXIoewogICAgICAgICAgc3RhdGU6IHN0YXRlMiwKICAgICAgICAgIHJlZnMsCiAgICAgICAgICBzbG90cywKICAgICAgICAgIHNlbGY6IGMsCiAgICAgICAgICBkZXRhaWwsCiAgICAgICAgICBtYWtlQ29tcG9uZW50OiAodGFnLCBvcHRzKSA9PiB7CiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBbmRSdW5Db2RlKHRhZywgYXBwU3RhdGUsIG9wdHM/LmRldGFpbCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgdXBkYXRlU3Vic2NyaWJlcnMoKTsKICAgICAgfTsKICAgIH0KICAgIHJlbmRlckZ1bmN0aW9uKHN0YXRlKTsKICAgIGlzSW5pdGlhbGl6ZWQgPSBjOwogIH07Cn0KZXhwb3J0IHsKICBpbmZsaWN0Qm9yZURPTSwKICBxdWVyeUNvbXBvbmVudCwKICB3ZWJDb21wb25lbnQKfTsK
`;
var beautify = import_js_beautify.default.html;
var BUILD_DIR = "build";
var serverStarted = false;
var numberOfRefreshes = 0;
console.log("## boreDOM CLI options");
console.log(
  "## ",
  "--index <path to default html>",
  "The base HTML file to serve",
  "defaults to ./index.html"
);
console.log(
  "## ",
  "--html <folder>",
  "Folder containing HTML component files",
  'defaults to "./components"'
);
console.log(
  "## ",
  "--static <folder>",
  "Static files folder, all files in here are copied as is",
  'defaults to "./public"'
);
import_commander.program.option("--index <path to file>", "Index file to serve", "index.html").option(
  "--html <folder>",
  "Folder containing HTML component files",
  "components"
).option(
  "--static <folder>",
  "Folder containing static files to be copied as is",
  "public"
).option(
  "--components-serve <folder>",
  "Build subfolder used to serve processed components",
  "components"
).option(
  "--static-serve <folder>",
  "Build subfolder used to serve static assets",
  "static"
);
var isTestMode = Boolean(process.env.BOREDOM_CLI_TEST_MODE);
if (isTestMode) {
  import_commander.program.parse([], { from: "user" });
} else {
  import_commander.program.parse(process.argv);
}
var options = import_commander.program.opts();
function sanitizeServeInput(value) {
  const normalizedSlashes = value.replace(/\\+/g, "/").trim();
  if (!normalizedSlashes) {
    return { fsPath: "", urlPath: "" };
  }
  if (["/", "./"].includes(normalizedSlashes)) {
    return { fsPath: "", urlPath: "/" };
  }
  let working = normalizedSlashes;
  while (working.startsWith("./")) {
    working = working.slice(2);
  }
  const isAbsolute = working.startsWith("/");
  if (isAbsolute) {
    working = working.replace(/^\/+/, "");
  }
  working = working.replace(/\/+$/, "");
  const fsPath = working;
  if (!fsPath) {
    return { fsPath: "", urlPath: isAbsolute ? "/" : "" };
  }
  const urlPath = isAbsolute ? `/${fsPath}` : fsPath;
  return { fsPath, urlPath };
}
function normalizeServePath(input, fallback) {
  if (typeof input === "undefined" || input === null) {
    return sanitizeServeInput(fallback);
  }
  const trimmed = String(input).trim();
  if (!trimmed) {
    return sanitizeServeInput(fallback);
  }
  return sanitizeServeInput(trimmed);
}
function buildRelativeServePath(base, ...segments) {
  const cleanSegments = segments.filter(Boolean).map((segment) => {
    return segment.replace(/^\/+/, "").replace(/\/+$/, "");
  });
  if (!base || base === ".") {
    return cleanSegments.join("/");
  }
  if (base === "/") {
    const joined = cleanSegments.join("/");
    return joined ? `/${joined}` : "/";
  }
  const cleanBase = base.replace(/\/+$/, "");
  return [cleanBase, ...cleanSegments].join("/");
}
var componentsServePath;
var staticServePath;
var componentsServeUrlPath;
var staticServeUrlPath;
function setServePaths(currentOptions = options) {
  const componentsPaths = normalizeServePath(
    currentOptions.componentsServe,
    "components"
  );
  const staticPaths = normalizeServePath(currentOptions.staticServe, "static");
  componentsServePath = componentsPaths.fsPath;
  componentsServeUrlPath = componentsPaths.urlPath;
  staticServePath = staticPaths.fsPath;
  staticServeUrlPath = staticPaths.urlPath;
  return {
    componentsServePath,
    componentsServeUrlPath,
    staticServePath,
    staticServeUrlPath
  };
}
function getServePaths() {
  return {
    componentsServePath,
    componentsServeUrlPath,
    staticServePath,
    staticServeUrlPath
  };
}
setServePaths();
async function copyStatic() {
  const staticDir = import_path.default.resolve(options.static);
  if (await import_fs_extra.default.pathExists(staticDir)) {
    await import_fs_extra.default.copy(staticDir, import_path.default.join(BUILD_DIR, staticServePath));
    console.log("Static folder copied.");
  }
}
async function copyBoreDOM() {
  return import_fs_extra.default.writeFile(import_path.default.join(BUILD_DIR, "boreDOM.js"), atob(boredom));
}
async function processComponents() {
  let components = {};
  if (options.html) {
    const htmlFolder = import_path.default.resolve(options.html);
    const htmlFiles = glob.sync("**/*.html", { cwd: htmlFolder });
    for (const file of htmlFiles) {
      const filePath = import_path.default.join(htmlFolder, file);
      const content = await import_fs_extra.default.readFile(filePath, "utf-8");
      const $ = cheerio.load(content, { decodeEntities: false });
      const template = $("template[data-component]");
      if (template.length) {
        const componentName = template.attr("data-component");
        const fullTemplate = $.html(template);
        const componentBuildDir = import_path.default.join(
          BUILD_DIR,
          componentsServePath,
          componentName
        );
        await import_fs_extra.default.ensureDir(componentBuildDir);
        const destHtmlPath = import_path.default.join(
          componentBuildDir,
          `${componentName}.html`
        );
        await import_fs_extra.default.copy(filePath, destHtmlPath);
        const componentDir = import_path.default.dirname(filePath);
        const jsMatch = glob.sync(`**/${componentName}.js`, {
          cwd: componentDir
        });
        const cssMatch = glob.sync(`**/${componentName}.css`, {
          cwd: componentDir
        });
        const hasJS = jsMatch.length > 0;
        if (jsMatch.length > 0) {
          const jsSrc = import_path.default.join(componentDir, jsMatch[0]);
          const destJsPath = import_path.default.join(
            componentBuildDir,
            `${componentName}.js`
          );
          await import_fs_extra.default.copy(jsSrc, destJsPath);
          console.log(`Copied ${componentName}.js to ${componentBuildDir}`);
        }
        const hasCSS = cssMatch.length > 0;
        if (cssMatch.length > 0) {
          const cssSrc = import_path.default.join(componentDir, cssMatch[0]);
          const destCssPath = import_path.default.join(
            componentBuildDir,
            `${componentName}.css`
          );
          await import_fs_extra.default.copy(cssSrc, destCssPath);
          console.log(`Copied ${componentName}.css to ${componentBuildDir}`);
        }
        components[componentName] = {
          templateTag: fullTemplate,
          hasJS,
          hasCSS
        };
      }
    }
  }
  return components;
}
async function updateIndex(components) {
  console.log(
    "Updated index.html with components:\n\n",
    JSON.stringify(components, null, 2)
  );
  const indexPath = import_path.default.resolve(options.index);
  let indexContent = await import_fs_extra.default.readFile(indexPath, "utf-8");
  const $ = cheerio.load(indexContent, { decodeEntities: false });
  $("head").prepend(
    `
  <script type="importmap">{ "imports": {      "@mr_hugo/boredom/dist/boreDOM.full.js": "./boreDOM.js",
       "boredom": "./boreDOM.js"
     } }</script>`
  );
  $("body").append(`
  <script src="boreDOM.js" type="module"></script>`);
  Object.keys(components).forEach((component) => {
    const componentScriptPath = buildRelativeServePath(
      componentsServeUrlPath,
      component,
      `${component}.js`
    );
    const componentCssPath = buildRelativeServePath(
      componentsServeUrlPath,
      component,
      `${component}.css`
    );
    if (components[component].hasJS && $(`script[src="${componentScriptPath}"]`).length === 0) {
      $("body").append(
        `
  <script src="${componentScriptPath}" type="module"></script>`
      );
    }
    if (components[component].hasCSS && $(`link[href="${componentCssPath}"]`).length === 0) {
      $("head").append(
        `
  <link rel="stylesheet" href="${componentCssPath}">`
      );
    }
    if ($(`template[data-component="${component}"]`).length === 0) {
      $("body").append(`
  ${components[component].templateTag}`);
      console.log(`Injected template for ${component}`);
    }
  });
  $("template[data-component]").each((i, el) => {
    const comp = $(el).attr("data-component");
    if (!components[comp]) {
      $(el).remove();
      console.log(`Removed unused template for ${comp}`);
    }
  });
  const prettyHtml = beautify($.html(), {
    indent_size: 2,
    space_in_empty_paren: true
  });
  const buildIndex = import_path.default.join(BUILD_DIR, "index.html");
  await import_fs_extra.default.outputFile(buildIndex, prettyHtml);
  console.log("Index updated with pretty printed HTML.");
}
async function startServer() {
  if (serverStarted) return;
  function serveFile(req, res, opts) {
    let urlPath = decodeURIComponent(req.url.split(/[?#]/)[0]);
    if (urlPath === "/" || urlPath.endsWith("/")) {
      urlPath = import_path.default.posix.join(urlPath, "index.html");
    }
    const filePath = import_path.default.join(BUILD_DIR, urlPath);
    import_fs_extra.default.pathExists(filePath).then((exists) => {
      if (!exists) {
        res.writeHead(404, { "Content-Type": "text/plain" });
        return res.end("Not Found");
      }
      const contentType = import_mime_types.default.lookup(filePath) || "application/octet-stream";
      res.writeHead(200, { "Content-Type": contentType });
      import_fs_extra.default.createReadStream(filePath).pipe(res);
    }).catch((err) => {
      res.writeHead(500, { "Content-Type": "text/plain" });
      res.end("Internal Server Error");
    });
  }
  const server = import_http.default.createServer((req, res) => {
    return serveFile(req, res, {
      cleanUrls: true,
      public: import_path.default.resolve(BUILD_DIR)
    });
  });
  let port = process.env.PORT || 8080;
  const serverHandler = () => {
    const { port: actualPort } = server.address();
    console.log(`Server running at http://localhost:${actualPort}`);
  };
  server.listen(port, serverHandler);
  server.on("error", (e) => {
    if (e.code === "EADDRINUSE") {
      console.log(
        "\x1B[33m%s\x1B[0m",
        `\u26A0\uFE0F Warning: Port ${port} in use, starting with a OS assigned port.`
      );
      setTimeout(() => {
        server.close();
        server.listen(0);
      }, 1e3);
    }
  });
  serverStarted = true;
}
async function build() {
  await import_fs_extra.default.remove(BUILD_DIR);
  await import_fs_extra.default.ensureDir(BUILD_DIR);
  await copyStatic();
  await copyBoreDOM();
  const components = await processComponents();
  await updateIndex(components);
}
async function watchFiles() {
  const pathsToWatch = [];
  if (options.index) {
    pathsToWatch.push(import_path.default.resolve(options.index));
  }
  if (options.html) {
    pathsToWatch.push(import_path.default.resolve(options.html));
  }
  const staticDir = import_path.default.resolve(options.static);
  if (await import_fs_extra.default.pathExists(staticDir)) {
    pathsToWatch.push(staticDir);
  }
  console.log("Watching for file changes in:", pathsToWatch);
  const watcher = import_chokidar.default.watch(pathsToWatch, { ignoreInitial: true });
  let rebuildTimeout;
  watcher.on("all", (event, filePath) => {
    console.log(`Detected ${event} on ${filePath}. Scheduling rebuild...`);
    if (rebuildTimeout) clearTimeout(rebuildTimeout);
    rebuildTimeout = setTimeout(() => {
      build().then(() => {
        console.log(
          `#${++numberOfRefreshes} - ${(/* @__PURE__ */ new Date()).toISOString()} - Build refreshed.`
        );
      }).catch((err) => console.error("Error during rebuild:", err));
    }, 100);
  });
}
async function main() {
  console.log("The file used as the base for HTML is:", options.index);
  const indexPath = import_path.default.join(process.cwd(), options.index);
  import_fs_extra.default.ensureFile(indexPath, (err) => {
    if (err) {
      console.log(
        "\x1B[31m%s\x1B[0m",
        `\u274C Error: The file "${indexPath}" was not found.
Please specify a location for it with "--index"`
      );
      process.exit(1);
    }
  });
  await build();
  startServer();
  await watchFiles();
}
if (!isTestMode) {
  main().catch((err) => {
    console.error(err);
    process.exit(1);
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BUILD_DIR,
  build,
  buildRelativeServePath,
  copyBoreDOM,
  getServePaths,
  normalizeServePath,
  options,
  processComponents,
  setServePaths,
  updateIndex
});
