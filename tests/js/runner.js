"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/mocha@10.8.2/node_modules/mocha/mocha.js
  var require_mocha = __commonJS({
    "node_modules/.pnpm/mocha@10.8.2/node_modules/mocha/mocha.js"(exports, module2) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.mocha = factory());
      })(exports, (function() {
        "use strict";
        var global$2 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
        var global$1 = typeof global$2 !== "undefined" ? global$2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
        function defaultSetTimout$1() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout$1() {
          throw new Error("clearTimeout has not been defined");
        }
        var cachedSetTimeout$1 = defaultSetTimout$1;
        var cachedClearTimeout$1 = defaultClearTimeout$1;
        if (typeof global$1.setTimeout === "function") {
          cachedSetTimeout$1 = setTimeout;
        }
        if (typeof global$1.clearTimeout === "function") {
          cachedClearTimeout$1 = clearTimeout;
        }
        function runTimeout$1(fun) {
          if (cachedSetTimeout$1 === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout$1 === defaultSetTimout$1 || !cachedSetTimeout$1) && setTimeout) {
            cachedSetTimeout$1 = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout$1(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout$1.call(null, fun, 0);
            } catch (e2) {
              return cachedSetTimeout$1.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout$1(marker) {
          if (cachedClearTimeout$1 === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout$1 === defaultClearTimeout$1 || !cachedClearTimeout$1) && clearTimeout) {
            cachedClearTimeout$1 = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout$1(marker);
          } catch (e) {
            try {
              return cachedClearTimeout$1.call(null, marker);
            } catch (e2) {
              return cachedClearTimeout$1.call(this, marker);
            }
          }
        }
        var queue$1 = [];
        var draining$1 = false;
        var currentQueue$1;
        var queueIndex$1 = -1;
        function cleanUpNextTick$1() {
          if (!draining$1 || !currentQueue$1) {
            return;
          }
          draining$1 = false;
          if (currentQueue$1.length) {
            queue$1 = currentQueue$1.concat(queue$1);
          } else {
            queueIndex$1 = -1;
          }
          if (queue$1.length) {
            drainQueue$1();
          }
        }
        function drainQueue$1() {
          if (draining$1) {
            return;
          }
          var timeout2 = runTimeout$1(cleanUpNextTick$1);
          draining$1 = true;
          var len = queue$1.length;
          while (len) {
            currentQueue$1 = queue$1;
            queue$1 = [];
            while (++queueIndex$1 < len) {
              if (currentQueue$1) {
                currentQueue$1[queueIndex$1].run();
              }
            }
            queueIndex$1 = -1;
            len = queue$1.length;
          }
          currentQueue$1 = null;
          draining$1 = false;
          runClearTimeout$1(timeout2);
        }
        function nextTick$1(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue$1.push(new Item$1(fun, args));
          if (queue$1.length === 1 && !draining$1) {
            runTimeout$1(drainQueue$1);
          }
        }
        function Item$1(fun, array2) {
          this.fun = fun;
          this.array = array2;
        }
        Item$1.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        var title$1 = "browser";
        var platform$1 = "browser";
        var browser$4 = true;
        var env$1 = {};
        var argv$1 = [];
        var version$2 = "";
        var versions$1 = {};
        var release$1 = {};
        var config$1 = {};
        function noop$1() {
        }
        var on$1 = noop$1;
        var addListener$1 = noop$1;
        var once$1 = noop$1;
        var off$1 = noop$1;
        var removeListener$1 = noop$1;
        var removeAllListeners$1 = noop$1;
        var emit$1 = noop$1;
        function binding$1(name2) {
          throw new Error("process.binding is not supported");
        }
        function cwd$1() {
          return "/";
        }
        function chdir$1(dir) {
          throw new Error("process.chdir is not supported");
        }
        function umask$1() {
          return 0;
        }
        var performance$1 = global$1.performance || {};
        var performanceNow$1 = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function() {
          return (/* @__PURE__ */ new Date()).getTime();
        };
        function hrtime$1(previousTimestamp) {
          var clocktime = performanceNow$1.call(performance$1) * 1e-3;
          var seconds = Math.floor(clocktime);
          var nanoseconds = Math.floor(clocktime % 1 * 1e9);
          if (previousTimestamp) {
            seconds = seconds - previousTimestamp[0];
            nanoseconds = nanoseconds - previousTimestamp[1];
            if (nanoseconds < 0) {
              seconds--;
              nanoseconds += 1e9;
            }
          }
          return [seconds, nanoseconds];
        }
        var startTime$1 = /* @__PURE__ */ new Date();
        function uptime$1() {
          var currentTime = /* @__PURE__ */ new Date();
          var dif = currentTime - startTime$1;
          return dif / 1e3;
        }
        var process2 = {
          nextTick: nextTick$1,
          title: title$1,
          browser: browser$4,
          env: env$1,
          argv: argv$1,
          version: version$2,
          versions: versions$1,
          on: on$1,
          addListener: addListener$1,
          once: once$1,
          off: off$1,
          removeListener: removeListener$1,
          removeAllListeners: removeAllListeners$1,
          emit: emit$1,
          binding: binding$1,
          cwd: cwd$1,
          chdir: chdir$1,
          umask: umask$1,
          hrtime: hrtime$1,
          platform: platform$1,
          release: release$1,
          config: config$1,
          uptime: uptime$1
        };
        var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
        function getAugmentedNamespace(n) {
          if (n.__esModule) return n;
          var a = Object.defineProperty({}, "__esModule", { value: true });
          Object.keys(n).forEach(function(k) {
            var d2 = Object.getOwnPropertyDescriptor(n, k);
            Object.defineProperty(a, k, d2.get ? d2 : {
              enumerable: true,
              get: function() {
                return n[k];
              }
            });
          });
          return a;
        }
        function commonjsRequire(path) {
          throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
        }
        var domain;
        function EventHandlers() {
        }
        EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
        function EventEmitter$2() {
          EventEmitter$2.init.call(this);
        }
        EventEmitter$2.EventEmitter = EventEmitter$2;
        EventEmitter$2.usingDomains = false;
        EventEmitter$2.prototype.domain = void 0;
        EventEmitter$2.prototype._events = void 0;
        EventEmitter$2.prototype._maxListeners = void 0;
        EventEmitter$2.defaultMaxListeners = 10;
        EventEmitter$2.init = function() {
          this.domain = null;
          if (EventEmitter$2.usingDomains) {
            if (domain.active) ;
          }
          if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          }
          this._maxListeners = this._maxListeners || void 0;
        };
        EventEmitter$2.prototype.setMaxListeners = function setMaxListeners(n) {
          if (typeof n !== "number" || n < 0 || isNaN(n))
            throw new TypeError('"n" argument must be a positive number');
          this._maxListeners = n;
          return this;
        };
        function $getMaxListeners(that) {
          if (that._maxListeners === void 0)
            return EventEmitter$2.defaultMaxListeners;
          return that._maxListeners;
        }
        EventEmitter$2.prototype.getMaxListeners = function getMaxListeners() {
          return $getMaxListeners(this);
        };
        function emitNone(handler, isFn, self2) {
          if (isFn)
            handler.call(self2);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              listeners[i].call(self2);
          }
        }
        function emitOne(handler, isFn, self2, arg1) {
          if (isFn)
            handler.call(self2, arg1);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              listeners[i].call(self2, arg1);
          }
        }
        function emitTwo(handler, isFn, self2, arg1, arg2) {
          if (isFn)
            handler.call(self2, arg1, arg2);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              listeners[i].call(self2, arg1, arg2);
          }
        }
        function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
          if (isFn)
            handler.call(self2, arg1, arg2, arg3);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              listeners[i].call(self2, arg1, arg2, arg3);
          }
        }
        function emitMany(handler, isFn, self2, args) {
          if (isFn)
            handler.apply(self2, args);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              listeners[i].apply(self2, args);
          }
        }
        EventEmitter$2.prototype.emit = function emit2(type3) {
          var er, handler, len, args, i, events, domain2;
          var doError = type3 === "error";
          events = this._events;
          if (events)
            doError = doError && events.error == null;
          else if (!doError)
            return false;
          domain2 = this.domain;
          if (doError) {
            er = arguments[1];
            if (domain2) {
              if (!er)
                er = new Error('Uncaught, unspecified "error" event');
              er.domainEmitter = this;
              er.domain = domain2;
              er.domainThrown = false;
              domain2.emit("error", er);
            } else if (er instanceof Error) {
              throw er;
            } else {
              var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
              err.context = er;
              throw err;
            }
            return false;
          }
          handler = events[type3];
          if (!handler)
            return false;
          var isFn = typeof handler === "function";
          len = arguments.length;
          switch (len) {
            // fast cases
            case 1:
              emitNone(handler, isFn, this);
              break;
            case 2:
              emitOne(handler, isFn, this, arguments[1]);
              break;
            case 3:
              emitTwo(handler, isFn, this, arguments[1], arguments[2]);
              break;
            case 4:
              emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
              break;
            // slower
            default:
              args = new Array(len - 1);
              for (i = 1; i < len; i++)
                args[i - 1] = arguments[i];
              emitMany(handler, isFn, this, args);
          }
          return true;
        };
        function _addListener(target, type3, listener, prepend) {
          var m2;
          var events;
          var existing;
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function');
          events = target._events;
          if (!events) {
            events = target._events = new EventHandlers();
            target._eventsCount = 0;
          } else {
            if (events.newListener) {
              target.emit(
                "newListener",
                type3,
                listener.listener ? listener.listener : listener
              );
              events = target._events;
            }
            existing = events[type3];
          }
          if (!existing) {
            existing = events[type3] = listener;
            ++target._eventsCount;
          } else {
            if (typeof existing === "function") {
              existing = events[type3] = prepend ? [listener, existing] : [existing, listener];
            } else {
              if (prepend) {
                existing.unshift(listener);
              } else {
                existing.push(listener);
              }
            }
            if (!existing.warned) {
              m2 = $getMaxListeners(target);
              if (m2 && m2 > 0 && existing.length > m2) {
                existing.warned = true;
                var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type3 + " listeners added. Use emitter.setMaxListeners() to increase limit");
                w2.name = "MaxListenersExceededWarning";
                w2.emitter = target;
                w2.type = type3;
                w2.count = existing.length;
                emitWarning$1(w2);
              }
            }
          }
          return target;
        }
        function emitWarning$1(e) {
          typeof console.warn === "function" ? console.warn(e) : console.log(e);
        }
        EventEmitter$2.prototype.addListener = function addListener2(type3, listener) {
          return _addListener(this, type3, listener, false);
        };
        EventEmitter$2.prototype.on = EventEmitter$2.prototype.addListener;
        EventEmitter$2.prototype.prependListener = function prependListener2(type3, listener) {
          return _addListener(this, type3, listener, true);
        };
        function _onceWrap(target, type3, listener) {
          var fired = false;
          function g() {
            target.removeListener(type3, g);
            if (!fired) {
              fired = true;
              listener.apply(target, arguments);
            }
          }
          g.listener = listener;
          return g;
        }
        EventEmitter$2.prototype.once = function once2(type3, listener) {
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function');
          this.on(type3, _onceWrap(this, type3, listener));
          return this;
        };
        EventEmitter$2.prototype.prependOnceListener = function prependOnceListener(type3, listener) {
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function');
          this.prependListener(type3, _onceWrap(this, type3, listener));
          return this;
        };
        EventEmitter$2.prototype.removeListener = function removeListener2(type3, listener) {
          var list2, events, position, i, originalListener;
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function');
          events = this._events;
          if (!events)
            return this;
          list2 = events[type3];
          if (!list2)
            return this;
          if (list2 === listener || list2.listener && list2.listener === listener) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else {
              delete events[type3];
              if (events.removeListener)
                this.emit("removeListener", type3, list2.listener || listener);
            }
          } else if (typeof list2 !== "function") {
            position = -1;
            for (i = list2.length; i-- > 0; ) {
              if (list2[i] === listener || list2[i].listener && list2[i].listener === listener) {
                originalListener = list2[i].listener;
                position = i;
                break;
              }
            }
            if (position < 0)
              return this;
            if (list2.length === 1) {
              list2[0] = void 0;
              if (--this._eventsCount === 0) {
                this._events = new EventHandlers();
                return this;
              } else {
                delete events[type3];
              }
            } else {
              spliceOne(list2, position);
            }
            if (events.removeListener)
              this.emit("removeListener", type3, originalListener || listener);
          }
          return this;
        };
        EventEmitter$2.prototype.off = function(type3, listener) {
          return this.removeListener(type3, listener);
        };
        EventEmitter$2.prototype.removeAllListeners = function removeAllListeners2(type3) {
          var listeners, events;
          events = this._events;
          if (!events)
            return this;
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = new EventHandlers();
              this._eventsCount = 0;
            } else if (events[type3]) {
              if (--this._eventsCount === 0)
                this._events = new EventHandlers();
              else
                delete events[type3];
            }
            return this;
          }
          if (arguments.length === 0) {
            var keys2 = Object.keys(events);
            for (var i = 0, key; i < keys2.length; ++i) {
              key = keys2[i];
              if (key === "removeListener") continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = new EventHandlers();
            this._eventsCount = 0;
            return this;
          }
          listeners = events[type3];
          if (typeof listeners === "function") {
            this.removeListener(type3, listeners);
          } else if (listeners) {
            do {
              this.removeListener(type3, listeners[listeners.length - 1]);
            } while (listeners[0]);
          }
          return this;
        };
        EventEmitter$2.prototype.listeners = function listeners(type3) {
          var evlistener;
          var ret;
          var events = this._events;
          if (!events)
            ret = [];
          else {
            evlistener = events[type3];
            if (!evlistener)
              ret = [];
            else if (typeof evlistener === "function")
              ret = [evlistener.listener || evlistener];
            else
              ret = unwrapListeners(evlistener);
          }
          return ret;
        };
        EventEmitter$2.listenerCount = function(emitter, type3) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type3);
          } else {
            return listenerCount$1.call(emitter, type3);
          }
        };
        EventEmitter$2.prototype.listenerCount = listenerCount$1;
        function listenerCount$1(type3) {
          var events = this._events;
          if (events) {
            var evlistener = events[type3];
            if (typeof evlistener === "function") {
              return 1;
            } else if (evlistener) {
              return evlistener.length;
            }
          }
          return 0;
        }
        EventEmitter$2.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };
        function spliceOne(list2, index) {
          for (var i = index, k = i + 1, n = list2.length; k < n; i += 1, k += 1)
            list2[i] = list2[k];
          list2.pop();
        }
        function arrayClone(arr, i) {
          var copy = new Array(i);
          while (i--)
            copy[i] = arr[i];
          return copy;
        }
        function unwrapListeners(arr) {
          var ret = new Array(arr.length);
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i];
          }
          return ret;
        }
        var _polyfillNode_events = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          "default": EventEmitter$2,
          EventEmitter: EventEmitter$2
        });
        var lookup$1 = [];
        var revLookup$1 = [];
        var Arr$1 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var inited$1 = false;
        function init$1() {
          inited$1 = true;
          var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          for (var i = 0, len = code.length; i < len; ++i) {
            lookup$1[i] = code[i];
            revLookup$1[code.charCodeAt(i)] = i;
          }
          revLookup$1["-".charCodeAt(0)] = 62;
          revLookup$1["_".charCodeAt(0)] = 63;
        }
        function toByteArray$1(b64) {
          if (!inited$1) {
            init$1();
          }
          var i, j, l, tmp, placeHolders, arr;
          var len = b64.length;
          if (len % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }
          placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
          arr = new Arr$1(len * 3 / 4 - placeHolders);
          l = placeHolders > 0 ? len - 4 : len;
          var L = 0;
          for (i = 0, j = 0; i < l; i += 4, j += 3) {
            tmp = revLookup$1[b64.charCodeAt(i)] << 18 | revLookup$1[b64.charCodeAt(i + 1)] << 12 | revLookup$1[b64.charCodeAt(i + 2)] << 6 | revLookup$1[b64.charCodeAt(i + 3)];
            arr[L++] = tmp >> 16 & 255;
            arr[L++] = tmp >> 8 & 255;
            arr[L++] = tmp & 255;
          }
          if (placeHolders === 2) {
            tmp = revLookup$1[b64.charCodeAt(i)] << 2 | revLookup$1[b64.charCodeAt(i + 1)] >> 4;
            arr[L++] = tmp & 255;
          } else if (placeHolders === 1) {
            tmp = revLookup$1[b64.charCodeAt(i)] << 10 | revLookup$1[b64.charCodeAt(i + 1)] << 4 | revLookup$1[b64.charCodeAt(i + 2)] >> 2;
            arr[L++] = tmp >> 8 & 255;
            arr[L++] = tmp & 255;
          }
          return arr;
        }
        function tripletToBase64$1(num) {
          return lookup$1[num >> 18 & 63] + lookup$1[num >> 12 & 63] + lookup$1[num >> 6 & 63] + lookup$1[num & 63];
        }
        function encodeChunk$1(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i = start; i < end; i += 3) {
            tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
            output.push(tripletToBase64$1(tmp));
          }
          return output.join("");
        }
        function fromByteArray$1(uint8) {
          if (!inited$1) {
            init$1();
          }
          var tmp;
          var len = uint8.length;
          var extraBytes = len % 3;
          var output = "";
          var parts = [];
          var maxChunkLength = 16383;
          for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
            parts.push(encodeChunk$1(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
          }
          if (extraBytes === 1) {
            tmp = uint8[len - 1];
            output += lookup$1[tmp >> 2];
            output += lookup$1[tmp << 4 & 63];
            output += "==";
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
            output += lookup$1[tmp >> 10];
            output += lookup$1[tmp >> 4 & 63];
            output += lookup$1[tmp << 2 & 63];
            output += "=";
          }
          parts.push(output);
          return parts.join("");
        }
        function read$1(buffer, offset, isLE, mLen, nBytes) {
          var e, m2;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d2 = isLE ? -1 : 1;
          var s2 = buffer[offset + i];
          i += d2;
          e = s2 & (1 << -nBits) - 1;
          s2 >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d2, nBits -= 8) {
          }
          m2 = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i], i += d2, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
          } else {
            m2 = m2 + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
        }
        function write$1(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m2, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d2 = isLE ? 1 : -1;
          var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m2 = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m2 = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m2 = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
          }
          e = e << mLen | m2;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d2, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d2] |= s2 * 128;
        }
        var toString$2 = {}.toString;
        var isArray$2 = Array.isArray || function(arr) {
          return toString$2.call(arr) == "[object Array]";
        };
        var INSPECT_MAX_BYTES$1 = 50;
        Buffer$1.TYPED_ARRAY_SUPPORT = global$2.TYPED_ARRAY_SUPPORT !== void 0 ? global$2.TYPED_ARRAY_SUPPORT : true;
        kMaxLength$1();
        function kMaxLength$1() {
          return Buffer$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
        }
        function createBuffer$1(that, length) {
          if (kMaxLength$1() < length) {
            throw new RangeError("Invalid typed array length");
          }
          if (Buffer$1.TYPED_ARRAY_SUPPORT) {
            that = new Uint8Array(length);
            that.__proto__ = Buffer$1.prototype;
          } else {
            if (that === null) {
              that = new Buffer$1(length);
            }
            that.length = length;
          }
          return that;
        }
        function Buffer$1(arg, encodingOrOffset, length) {
          if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
            return new Buffer$1(arg, encodingOrOffset, length);
          }
          if (typeof arg === "number") {
            if (typeof encodingOrOffset === "string") {
              throw new Error(
                "If encoding is specified then the first argument must be a string"
              );
            }
            return allocUnsafe$1(this, arg);
          }
          return from$1(this, arg, encodingOrOffset, length);
        }
        Buffer$1.poolSize = 8192;
        Buffer$1._augment = function(arr) {
          arr.__proto__ = Buffer$1.prototype;
          return arr;
        };
        function from$1(that, value, encodingOrOffset, length) {
          if (typeof value === "number") {
            throw new TypeError('"value" argument must not be a number');
          }
          if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
            return fromArrayBuffer$1(that, value, encodingOrOffset, length);
          }
          if (typeof value === "string") {
            return fromString$1(that, value, encodingOrOffset);
          }
          return fromObject$1(that, value);
        }
        Buffer$1.from = function(value, encodingOrOffset, length) {
          return from$1(null, value, encodingOrOffset, length);
        };
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          Buffer$1.prototype.__proto__ = Uint8Array.prototype;
          Buffer$1.__proto__ = Uint8Array;
        }
        function assertSize$1(size) {
          if (typeof size !== "number") {
            throw new TypeError('"size" argument must be a number');
          } else if (size < 0) {
            throw new RangeError('"size" argument must not be negative');
          }
        }
        function alloc$1(that, size, fill, encoding) {
          assertSize$1(size);
          if (size <= 0) {
            return createBuffer$1(that, size);
          }
          if (fill !== void 0) {
            return typeof encoding === "string" ? createBuffer$1(that, size).fill(fill, encoding) : createBuffer$1(that, size).fill(fill);
          }
          return createBuffer$1(that, size);
        }
        Buffer$1.alloc = function(size, fill, encoding) {
          return alloc$1(null, size, fill, encoding);
        };
        function allocUnsafe$1(that, size) {
          assertSize$1(size);
          that = createBuffer$1(that, size < 0 ? 0 : checked$1(size) | 0);
          if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
            for (var i = 0; i < size; ++i) {
              that[i] = 0;
            }
          }
          return that;
        }
        Buffer$1.allocUnsafe = function(size) {
          return allocUnsafe$1(null, size);
        };
        Buffer$1.allocUnsafeSlow = function(size) {
          return allocUnsafe$1(null, size);
        };
        function fromString$1(that, string, encoding) {
          if (typeof encoding !== "string" || encoding === "") {
            encoding = "utf8";
          }
          if (!Buffer$1.isEncoding(encoding)) {
            throw new TypeError('"encoding" must be a valid string encoding');
          }
          var length = byteLength$1(string, encoding) | 0;
          that = createBuffer$1(that, length);
          var actual = that.write(string, encoding);
          if (actual !== length) {
            that = that.slice(0, actual);
          }
          return that;
        }
        function fromArrayLike$1(that, array2) {
          var length = array2.length < 0 ? 0 : checked$1(array2.length) | 0;
          that = createBuffer$1(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array2[i] & 255;
          }
          return that;
        }
        function fromArrayBuffer$1(that, array2, byteOffset, length) {
          array2.byteLength;
          if (byteOffset < 0 || array2.byteLength < byteOffset) {
            throw new RangeError("'offset' is out of bounds");
          }
          if (array2.byteLength < byteOffset + (length || 0)) {
            throw new RangeError("'length' is out of bounds");
          }
          if (byteOffset === void 0 && length === void 0) {
            array2 = new Uint8Array(array2);
          } else if (length === void 0) {
            array2 = new Uint8Array(array2, byteOffset);
          } else {
            array2 = new Uint8Array(array2, byteOffset, length);
          }
          if (Buffer$1.TYPED_ARRAY_SUPPORT) {
            that = array2;
            that.__proto__ = Buffer$1.prototype;
          } else {
            that = fromArrayLike$1(that, array2);
          }
          return that;
        }
        function fromObject$1(that, obj) {
          if (internalIsBuffer$1(obj)) {
            var len = checked$1(obj.length) | 0;
            that = createBuffer$1(that, len);
            if (that.length === 0) {
              return that;
            }
            obj.copy(that, 0, 0, len);
            return that;
          }
          if (obj) {
            if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
              if (typeof obj.length !== "number" || isnan$1(obj.length)) {
                return createBuffer$1(that, 0);
              }
              return fromArrayLike$1(that, obj);
            }
            if (obj.type === "Buffer" && isArray$2(obj.data)) {
              return fromArrayLike$1(that, obj.data);
            }
          }
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }
        function checked$1(length) {
          if (length >= kMaxLength$1()) {
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength$1().toString(16) + " bytes");
          }
          return length | 0;
        }
        Buffer$1.isBuffer = isBuffer$2;
        function internalIsBuffer$1(b) {
          return !!(b != null && b._isBuffer);
        }
        Buffer$1.compare = function compare(a, b) {
          if (!internalIsBuffer$1(a) || !internalIsBuffer$1(b)) {
            throw new TypeError("Arguments must be Buffers");
          }
          if (a === b) return 0;
          var x = a.length;
          var y2 = b.length;
          for (var i = 0, len = Math.min(x, y2); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i];
              y2 = b[i];
              break;
            }
          }
          if (x < y2) return -1;
          if (y2 < x) return 1;
          return 0;
        };
        Buffer$1.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        };
        Buffer$1.concat = function concat(list2, length) {
          if (!isArray$2(list2)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          if (list2.length === 0) {
            return Buffer$1.alloc(0);
          }
          var i;
          if (length === void 0) {
            length = 0;
            for (i = 0; i < list2.length; ++i) {
              length += list2[i].length;
            }
          }
          var buffer = Buffer$1.allocUnsafe(length);
          var pos = 0;
          for (i = 0; i < list2.length; ++i) {
            var buf = list2[i];
            if (!internalIsBuffer$1(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            buf.copy(buffer, pos);
            pos += buf.length;
          }
          return buffer;
        };
        function byteLength$1(string, encoding) {
          if (internalIsBuffer$1(string)) {
            return string.length;
          }
          if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
            return string.byteLength;
          }
          if (typeof string !== "string") {
            string = "" + string;
          }
          var len = string.length;
          if (len === 0) return 0;
          var loweredCase = false;
          for (; ; ) {
            switch (encoding) {
              case "ascii":
              case "latin1":
              case "binary":
                return len;
              case "utf8":
              case "utf-8":
              case void 0:
                return utf8ToBytes$1(string).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return len * 2;
              case "hex":
                return len >>> 1;
              case "base64":
                return base64ToBytes$1(string).length;
              default:
                if (loweredCase) return utf8ToBytes$1(string).length;
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer$1.byteLength = byteLength$1;
        function slowToString$1(encoding, start, end) {
          var loweredCase = false;
          if (start === void 0 || start < 0) {
            start = 0;
          }
          if (start > this.length) {
            return "";
          }
          if (end === void 0 || end > this.length) {
            end = this.length;
          }
          if (end <= 0) {
            return "";
          }
          end >>>= 0;
          start >>>= 0;
          if (end <= start) {
            return "";
          }
          if (!encoding) encoding = "utf8";
          while (true) {
            switch (encoding) {
              case "hex":
                return hexSlice$1(this, start, end);
              case "utf8":
              case "utf-8":
                return utf8Slice$1(this, start, end);
              case "ascii":
                return asciiSlice$1(this, start, end);
              case "latin1":
              case "binary":
                return latin1Slice$1(this, start, end);
              case "base64":
                return base64Slice$1(this, start, end);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice$1(this, start, end);
              default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = (encoding + "").toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer$1.prototype._isBuffer = true;
        function swap$1(b, n, m2) {
          var i = b[n];
          b[n] = b[m2];
          b[m2] = i;
        }
        Buffer$1.prototype.swap16 = function swap16() {
          var len = this.length;
          if (len % 2 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          }
          for (var i = 0; i < len; i += 2) {
            swap$1(this, i, i + 1);
          }
          return this;
        };
        Buffer$1.prototype.swap32 = function swap32() {
          var len = this.length;
          if (len % 4 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          }
          for (var i = 0; i < len; i += 4) {
            swap$1(this, i, i + 3);
            swap$1(this, i + 1, i + 2);
          }
          return this;
        };
        Buffer$1.prototype.swap64 = function swap64() {
          var len = this.length;
          if (len % 8 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          }
          for (var i = 0; i < len; i += 8) {
            swap$1(this, i, i + 7);
            swap$1(this, i + 1, i + 6);
            swap$1(this, i + 2, i + 5);
            swap$1(this, i + 3, i + 4);
          }
          return this;
        };
        Buffer$1.prototype.toString = function toString3() {
          var length = this.length | 0;
          if (length === 0) return "";
          if (arguments.length === 0) return utf8Slice$1(this, 0, length);
          return slowToString$1.apply(this, arguments);
        };
        Buffer$1.prototype.equals = function equals(b) {
          if (!internalIsBuffer$1(b)) throw new TypeError("Argument must be a Buffer");
          if (this === b) return true;
          return Buffer$1.compare(this, b) === 0;
        };
        Buffer$1.prototype.inspect = function inspect4() {
          var str = "";
          var max = INSPECT_MAX_BYTES$1;
          if (this.length > 0) {
            str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
            if (this.length > max) str += " ... ";
          }
          return "<Buffer " + str + ">";
        };
        Buffer$1.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
          if (!internalIsBuffer$1(target)) {
            throw new TypeError("Argument must be a Buffer");
          }
          if (start === void 0) {
            start = 0;
          }
          if (end === void 0) {
            end = target ? target.length : 0;
          }
          if (thisStart === void 0) {
            thisStart = 0;
          }
          if (thisEnd === void 0) {
            thisEnd = this.length;
          }
          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
            throw new RangeError("out of range index");
          }
          if (thisStart >= thisEnd && start >= end) {
            return 0;
          }
          if (thisStart >= thisEnd) {
            return -1;
          }
          if (start >= end) {
            return 1;
          }
          start >>>= 0;
          end >>>= 0;
          thisStart >>>= 0;
          thisEnd >>>= 0;
          if (this === target) return 0;
          var x = thisEnd - thisStart;
          var y2 = end - start;
          var len = Math.min(x, y2);
          var thisCopy = this.slice(thisStart, thisEnd);
          var targetCopy = target.slice(start, end);
          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i];
              y2 = targetCopy[i];
              break;
            }
          }
          if (x < y2) return -1;
          if (y2 < x) return 1;
          return 0;
        };
        function bidirectionalIndexOf$1(buffer, val, byteOffset, encoding, dir) {
          if (buffer.length === 0) return -1;
          if (typeof byteOffset === "string") {
            encoding = byteOffset;
            byteOffset = 0;
          } else if (byteOffset > 2147483647) {
            byteOffset = 2147483647;
          } else if (byteOffset < -2147483648) {
            byteOffset = -2147483648;
          }
          byteOffset = +byteOffset;
          if (isNaN(byteOffset)) {
            byteOffset = dir ? 0 : buffer.length - 1;
          }
          if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
          if (byteOffset >= buffer.length) {
            if (dir) return -1;
            else byteOffset = buffer.length - 1;
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0;
            else return -1;
          }
          if (typeof val === "string") {
            val = Buffer$1.from(val, encoding);
          }
          if (internalIsBuffer$1(val)) {
            if (val.length === 0) {
              return -1;
            }
            return arrayIndexOf$1(buffer, val, byteOffset, encoding, dir);
          } else if (typeof val === "number") {
            val = val & 255;
            if (Buffer$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
              } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
              }
            }
            return arrayIndexOf$1(buffer, [val], byteOffset, encoding, dir);
          }
          throw new TypeError("val must be string, number or Buffer");
        }
        function arrayIndexOf$1(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1;
          var arrLength = arr.length;
          var valLength = val.length;
          if (encoding !== void 0) {
            encoding = String(encoding).toLowerCase();
            if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
              if (arr.length < 2 || val.length < 2) {
                return -1;
              }
              indexSize = 2;
              arrLength /= 2;
              valLength /= 2;
              byteOffset /= 2;
            }
          }
          function read2(buf, i2) {
            if (indexSize === 1) {
              return buf[i2];
            } else {
              return buf.readUInt16BE(i2 * indexSize);
            }
          }
          var i;
          if (dir) {
            var foundIndex = -1;
            for (i = byteOffset; i < arrLength; i++) {
              if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
              } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
              }
            }
          } else {
            if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
            for (i = byteOffset; i >= 0; i--) {
              var found = true;
              for (var j = 0; j < valLength; j++) {
                if (read2(arr, i + j) !== read2(val, j)) {
                  found = false;
                  break;
                }
              }
              if (found) return i;
            }
          }
          return -1;
        }
        Buffer$1.prototype.includes = function includes(val, byteOffset, encoding) {
          return this.indexOf(val, byteOffset, encoding) !== -1;
        };
        Buffer$1.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
          return bidirectionalIndexOf$1(this, val, byteOffset, encoding, true);
        };
        Buffer$1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf$1(this, val, byteOffset, encoding, false);
        };
        function hexWrite$1(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining;
            }
          }
          var strLen = string.length;
          if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
          if (length > strLen / 2) {
            length = strLen / 2;
          }
          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16);
            if (isNaN(parsed)) return i;
            buf[offset + i] = parsed;
          }
          return i;
        }
        function utf8Write$1(buf, string, offset, length) {
          return blitBuffer$1(utf8ToBytes$1(string, buf.length - offset), buf, offset, length);
        }
        function asciiWrite$1(buf, string, offset, length) {
          return blitBuffer$1(asciiToBytes$1(string), buf, offset, length);
        }
        function latin1Write$1(buf, string, offset, length) {
          return asciiWrite$1(buf, string, offset, length);
        }
        function base64Write$1(buf, string, offset, length) {
          return blitBuffer$1(base64ToBytes$1(string), buf, offset, length);
        }
        function ucs2Write$1(buf, string, offset, length) {
          return blitBuffer$1(utf16leToBytes$1(string, buf.length - offset), buf, offset, length);
        }
        Buffer$1.prototype.write = function write2(string, offset, length, encoding) {
          if (offset === void 0) {
            encoding = "utf8";
            length = this.length;
            offset = 0;
          } else if (length === void 0 && typeof offset === "string") {
            encoding = offset;
            length = this.length;
            offset = 0;
          } else if (isFinite(offset)) {
            offset = offset | 0;
            if (isFinite(length)) {
              length = length | 0;
              if (encoding === void 0) encoding = "utf8";
            } else {
              encoding = length;
              length = void 0;
            }
          } else {
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          }
          var remaining = this.length - offset;
          if (length === void 0 || length > remaining) length = remaining;
          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
            throw new RangeError("Attempt to write outside buffer bounds");
          }
          if (!encoding) encoding = "utf8";
          var loweredCase = false;
          for (; ; ) {
            switch (encoding) {
              case "hex":
                return hexWrite$1(this, string, offset, length);
              case "utf8":
              case "utf-8":
                return utf8Write$1(this, string, offset, length);
              case "ascii":
                return asciiWrite$1(this, string, offset, length);
              case "latin1":
              case "binary":
                return latin1Write$1(this, string, offset, length);
              case "base64":
                return base64Write$1(this, string, offset, length);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write$1(this, string, offset, length);
              default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        };
        Buffer$1.prototype.toJSON = function toJSON() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        };
        function base64Slice$1(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return fromByteArray$1(buf);
          } else {
            return fromByteArray$1(buf.slice(start, end));
          }
        }
        function utf8Slice$1(buf, start, end) {
          end = Math.min(buf.length, end);
          var res = [];
          var i = start;
          while (i < end) {
            var firstByte = buf[i];
            var codePoint = null;
            var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint;
              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 128) {
                    codePoint = firstByte;
                  }
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 192) === 128) {
                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                    if (tempCodePoint > 127) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                      codePoint = tempCodePoint;
                    }
                  }
              }
            }
            if (codePoint === null) {
              codePoint = 65533;
              bytesPerSequence = 1;
            } else if (codePoint > 65535) {
              codePoint -= 65536;
              res.push(codePoint >>> 10 & 1023 | 55296);
              codePoint = 56320 | codePoint & 1023;
            }
            res.push(codePoint);
            i += bytesPerSequence;
          }
          return decodeCodePointsArray$1(res);
        }
        var MAX_ARGUMENTS_LENGTH$1 = 4096;
        function decodeCodePointsArray$1(codePoints) {
          var len = codePoints.length;
          if (len <= MAX_ARGUMENTS_LENGTH$1) {
            return String.fromCharCode.apply(String, codePoints);
          }
          var res = "";
          var i = 0;
          while (i < len) {
            res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH$1)
            );
          }
          return res;
        }
        function asciiSlice$1(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 127);
          }
          return ret;
        }
        function latin1Slice$1(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i]);
          }
          return ret;
        }
        function hexSlice$1(buf, start, end) {
          var len = buf.length;
          if (!start || start < 0) start = 0;
          if (!end || end < 0 || end > len) end = len;
          var out = "";
          for (var i = start; i < end; ++i) {
            out += toHex$1(buf[i]);
          }
          return out;
        }
        function utf16leSlice$1(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = "";
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
          }
          return res;
        }
        Buffer$1.prototype.slice = function slice(start, end) {
          var len = this.length;
          start = ~~start;
          end = end === void 0 ? len : ~~end;
          if (start < 0) {
            start += len;
            if (start < 0) start = 0;
          } else if (start > len) {
            start = len;
          }
          if (end < 0) {
            end += len;
            if (end < 0) end = 0;
          } else if (end > len) {
            end = len;
          }
          if (end < start) end = start;
          var newBuf;
          if (Buffer$1.TYPED_ARRAY_SUPPORT) {
            newBuf = this.subarray(start, end);
            newBuf.__proto__ = Buffer$1.prototype;
          } else {
            var sliceLen = end - start;
            newBuf = new Buffer$1(sliceLen, void 0);
            for (var i = 0; i < sliceLen; ++i) {
              newBuf[i] = this[i + start];
            }
          }
          return newBuf;
        };
        function checkOffset$1(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
          if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
        }
        Buffer$1.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) checkOffset$1(offset, byteLength2, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength2 && (mul *= 256)) {
            val += this[offset + i] * mul;
          }
          return val;
        };
        Buffer$1.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) {
            checkOffset$1(offset, byteLength2, this.length);
          }
          var val = this[offset + --byteLength2];
          var mul = 1;
          while (byteLength2 > 0 && (mul *= 256)) {
            val += this[offset + --byteLength2] * mul;
          }
          return val;
        };
        Buffer$1.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 1, this.length);
          return this[offset];
        };
        Buffer$1.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 2, this.length);
          return this[offset] | this[offset + 1] << 8;
        };
        Buffer$1.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 2, this.length);
          return this[offset] << 8 | this[offset + 1];
        };
        Buffer$1.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 4, this.length);
          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
        };
        Buffer$1.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 4, this.length);
          return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };
        Buffer$1.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) checkOffset$1(offset, byteLength2, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength2 && (mul *= 256)) {
            val += this[offset + i] * mul;
          }
          mul *= 128;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
          return val;
        };
        Buffer$1.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) checkOffset$1(offset, byteLength2, this.length);
          var i = byteLength2;
          var mul = 1;
          var val = this[offset + --i];
          while (i > 0 && (mul *= 256)) {
            val += this[offset + --i] * mul;
          }
          mul *= 128;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
          return val;
        };
        Buffer$1.prototype.readInt8 = function readInt8(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 1, this.length);
          if (!(this[offset] & 128)) return this[offset];
          return (255 - this[offset] + 1) * -1;
        };
        Buffer$1.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 2, this.length);
          var val = this[offset] | this[offset + 1] << 8;
          return val & 32768 ? val | 4294901760 : val;
        };
        Buffer$1.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 2, this.length);
          var val = this[offset + 1] | this[offset] << 8;
          return val & 32768 ? val | 4294901760 : val;
        };
        Buffer$1.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 4, this.length);
          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };
        Buffer$1.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 4, this.length);
          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };
        Buffer$1.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 4, this.length);
          return read$1(this, offset, true, 23, 4);
        };
        Buffer$1.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 4, this.length);
          return read$1(this, offset, false, 23, 4);
        };
        Buffer$1.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 8, this.length);
          return read$1(this, offset, true, 52, 8);
        };
        Buffer$1.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          if (!noAssert) checkOffset$1(offset, 8, this.length);
          return read$1(this, offset, false, 52, 8);
        };
        function checkInt$1(buf, value, offset, ext, max, min2) {
          if (!internalIsBuffer$1(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (value > max || value < min2) throw new RangeError('"value" argument is out of bounds');
          if (offset + ext > buf.length) throw new RangeError("Index out of range");
        }
        Buffer$1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
            checkInt$1(this, value, offset, byteLength2, maxBytes, 0);
          }
          var mul = 1;
          var i = 0;
          this[offset] = value & 255;
          while (++i < byteLength2 && (mul *= 256)) {
            this[offset + i] = value / mul & 255;
          }
          return offset + byteLength2;
        };
        Buffer$1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
            checkInt$1(this, value, offset, byteLength2, maxBytes, 0);
          }
          var i = byteLength2 - 1;
          var mul = 1;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            this[offset + i] = value / mul & 255;
          }
          return offset + byteLength2;
        };
        Buffer$1.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt$1(this, value, offset, 1, 255, 0);
          if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          this[offset] = value & 255;
          return offset + 1;
        };
        function objectWriteUInt16$1(buf, value, offset, littleEndian) {
          if (value < 0) value = 65535 + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
            buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
          }
        }
        Buffer$1.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt$1(this, value, offset, 2, 65535, 0);
          if (Buffer$1.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16$1(this, value, offset, true);
          }
          return offset + 2;
        };
        Buffer$1.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt$1(this, value, offset, 2, 65535, 0);
          if (Buffer$1.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
          } else {
            objectWriteUInt16$1(this, value, offset, false);
          }
          return offset + 2;
        };
        function objectWriteUInt32$1(buf, value, offset, littleEndian) {
          if (value < 0) value = 4294967295 + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
            buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
          }
        }
        Buffer$1.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt$1(this, value, offset, 4, 4294967295, 0);
          if (Buffer$1.TYPED_ARRAY_SUPPORT) {
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 255;
          } else {
            objectWriteUInt32$1(this, value, offset, true);
          }
          return offset + 4;
        };
        Buffer$1.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt$1(this, value, offset, 4, 4294967295, 0);
          if (Buffer$1.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
          } else {
            objectWriteUInt32$1(this, value, offset, false);
          }
          return offset + 4;
        };
        Buffer$1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength2 - 1);
            checkInt$1(this, value, offset, byteLength2, limit - 1, -limit);
          }
          var i = 0;
          var mul = 1;
          var sub = 0;
          this[offset] = value & 255;
          while (++i < byteLength2 && (mul *= 256)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (value / mul >> 0) - sub & 255;
          }
          return offset + byteLength2;
        };
        Buffer$1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength2 - 1);
            checkInt$1(this, value, offset, byteLength2, limit - 1, -limit);
          }
          var i = byteLength2 - 1;
          var mul = 1;
          var sub = 0;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (value / mul >> 0) - sub & 255;
          }
          return offset + byteLength2;
        };
        Buffer$1.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt$1(this, value, offset, 1, 127, -128);
          if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          if (value < 0) value = 255 + value + 1;
          this[offset] = value & 255;
          return offset + 1;
        };
        Buffer$1.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt$1(this, value, offset, 2, 32767, -32768);
          if (Buffer$1.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16$1(this, value, offset, true);
          }
          return offset + 2;
        };
        Buffer$1.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt$1(this, value, offset, 2, 32767, -32768);
          if (Buffer$1.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
          } else {
            objectWriteUInt16$1(this, value, offset, false);
          }
          return offset + 2;
        };
        Buffer$1.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt$1(this, value, offset, 4, 2147483647, -2147483648);
          if (Buffer$1.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
          } else {
            objectWriteUInt32$1(this, value, offset, true);
          }
          return offset + 4;
        };
        Buffer$1.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt$1(this, value, offset, 4, 2147483647, -2147483648);
          if (value < 0) value = 4294967295 + value + 1;
          if (Buffer$1.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
          } else {
            objectWriteUInt32$1(this, value, offset, false);
          }
          return offset + 4;
        };
        function checkIEEE754$1(buf, value, offset, ext, max, min2) {
          if (offset + ext > buf.length) throw new RangeError("Index out of range");
          if (offset < 0) throw new RangeError("Index out of range");
        }
        function writeFloat$1(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754$1(buf, value, offset, 4);
          }
          write$1(buf, value, offset, littleEndian, 23, 4);
          return offset + 4;
        }
        Buffer$1.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat$1(this, value, offset, true, noAssert);
        };
        Buffer$1.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat$1(this, value, offset, false, noAssert);
        };
        function writeDouble$1(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754$1(buf, value, offset, 8);
          }
          write$1(buf, value, offset, littleEndian, 52, 8);
          return offset + 8;
        }
        Buffer$1.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble$1(this, value, offset, true, noAssert);
        };
        Buffer$1.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble$1(this, value, offset, false, noAssert);
        };
        Buffer$1.prototype.copy = function copy(target, targetStart, start, end) {
          if (!start) start = 0;
          if (!end && end !== 0) end = this.length;
          if (targetStart >= target.length) targetStart = target.length;
          if (!targetStart) targetStart = 0;
          if (end > 0 && end < start) end = start;
          if (end === start) return 0;
          if (target.length === 0 || this.length === 0) return 0;
          if (targetStart < 0) {
            throw new RangeError("targetStart out of bounds");
          }
          if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
          if (end < 0) throw new RangeError("sourceEnd out of bounds");
          if (end > this.length) end = this.length;
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start;
          }
          var len = end - start;
          var i;
          if (this === target && start < targetStart && targetStart < end) {
            for (i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start];
            }
          } else if (len < 1e3 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
            for (i = 0; i < len; ++i) {
              target[i + targetStart] = this[i + start];
            }
          } else {
            Uint8Array.prototype.set.call(
              target,
              this.subarray(start, start + len),
              targetStart
            );
          }
          return len;
        };
        Buffer$1.prototype.fill = function fill(val, start, end, encoding) {
          if (typeof val === "string") {
            if (typeof start === "string") {
              encoding = start;
              start = 0;
              end = this.length;
            } else if (typeof end === "string") {
              encoding = end;
              end = this.length;
            }
            if (val.length === 1) {
              var code = val.charCodeAt(0);
              if (code < 256) {
                val = code;
              }
            }
            if (encoding !== void 0 && typeof encoding !== "string") {
              throw new TypeError("encoding must be a string");
            }
            if (typeof encoding === "string" && !Buffer$1.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding);
            }
          } else if (typeof val === "number") {
            val = val & 255;
          }
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError("Out of range index");
          }
          if (end <= start) {
            return this;
          }
          start = start >>> 0;
          end = end === void 0 ? this.length : end >>> 0;
          if (!val) val = 0;
          var i;
          if (typeof val === "number") {
            for (i = start; i < end; ++i) {
              this[i] = val;
            }
          } else {
            var bytes = internalIsBuffer$1(val) ? val : utf8ToBytes$1(new Buffer$1(val, encoding).toString());
            var len = bytes.length;
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len];
            }
          }
          return this;
        };
        var INVALID_BASE64_RE$1 = /[^+\/0-9A-Za-z-_]/g;
        function base64clean$1(str) {
          str = stringtrim$1(str).replace(INVALID_BASE64_RE$1, "");
          if (str.length < 2) return "";
          while (str.length % 4 !== 0) {
            str = str + "=";
          }
          return str;
        }
        function stringtrim$1(str) {
          if (str.trim) return str.trim();
          return str.replace(/^\s+|\s+$/g, "");
        }
        function toHex$1(n) {
          if (n < 16) return "0" + n.toString(16);
          return n.toString(16);
        }
        function utf8ToBytes$1(string, units) {
          units = units || Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;
          var bytes = [];
          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i);
            if (codePoint > 55295 && codePoint < 57344) {
              if (!leadSurrogate) {
                if (codePoint > 56319) {
                  if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  continue;
                } else if (i + 1 === length) {
                  if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  continue;
                }
                leadSurrogate = codePoint;
                continue;
              }
              if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
              }
              codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
            } else if (leadSurrogate) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
            }
            leadSurrogate = null;
            if (codePoint < 128) {
              if ((units -= 1) < 0) break;
              bytes.push(codePoint);
            } else if (codePoint < 2048) {
              if ((units -= 2) < 0) break;
              bytes.push(
                codePoint >> 6 | 192,
                codePoint & 63 | 128
              );
            } else if (codePoint < 65536) {
              if ((units -= 3) < 0) break;
              bytes.push(
                codePoint >> 12 | 224,
                codePoint >> 6 & 63 | 128,
                codePoint & 63 | 128
              );
            } else if (codePoint < 1114112) {
              if ((units -= 4) < 0) break;
              bytes.push(
                codePoint >> 18 | 240,
                codePoint >> 12 & 63 | 128,
                codePoint >> 6 & 63 | 128,
                codePoint & 63 | 128
              );
            } else {
              throw new Error("Invalid code point");
            }
          }
          return bytes;
        }
        function asciiToBytes$1(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            byteArray.push(str.charCodeAt(i) & 255);
          }
          return byteArray;
        }
        function utf16leToBytes$1(str, units) {
          var c, hi, lo;
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break;
            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }
          return byteArray;
        }
        function base64ToBytes$1(str) {
          return toByteArray$1(base64clean$1(str));
        }
        function blitBuffer$1(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length) break;
            dst[i + offset] = src[i];
          }
          return i;
        }
        function isnan$1(val) {
          return val !== val;
        }
        function isBuffer$2(obj) {
          return obj != null && (!!obj._isBuffer || isFastBuffer$1(obj) || isSlowBuffer$1(obj));
        }
        function isFastBuffer$1(obj) {
          return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
        }
        function isSlowBuffer$1(obj) {
          return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer$1(obj.slice(0, 0));
        }
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        var cachedSetTimeout = defaultSetTimout;
        var cachedClearTimeout = defaultClearTimeout;
        if (typeof global$2.setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        }
        if (typeof global$2.clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        }
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e2) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e2) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout2 = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout2);
        }
        function nextTick(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        }
        function Item(fun, array2) {
          this.fun = fun;
          this.array = array2;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        var title = "browser";
        var platform = "browser";
        var browser$3 = true;
        var env = {};
        var argv = [];
        var version$1 = "";
        var versions = {};
        var release = {};
        var config3 = {};
        function noop() {
        }
        var on = noop;
        var addListener = noop;
        var once = noop;
        var off = noop;
        var removeListener = noop;
        var removeAllListeners = noop;
        var emit = noop;
        function binding(name2) {
          throw new Error("process.binding is not supported");
        }
        function cwd() {
          return "/";
        }
        function chdir(dir) {
          throw new Error("process.chdir is not supported");
        }
        function umask() {
          return 0;
        }
        var performance = global$2.performance || {};
        var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
          return (/* @__PURE__ */ new Date()).getTime();
        };
        function hrtime(previousTimestamp) {
          var clocktime = performanceNow.call(performance) * 1e-3;
          var seconds = Math.floor(clocktime);
          var nanoseconds = Math.floor(clocktime % 1 * 1e9);
          if (previousTimestamp) {
            seconds = seconds - previousTimestamp[0];
            nanoseconds = nanoseconds - previousTimestamp[1];
            if (nanoseconds < 0) {
              seconds--;
              nanoseconds += 1e9;
            }
          }
          return [seconds, nanoseconds];
        }
        var startTime = /* @__PURE__ */ new Date();
        function uptime() {
          var currentTime = /* @__PURE__ */ new Date();
          var dif = currentTime - startTime;
          return dif / 1e3;
        }
        var browser$1$1 = {
          nextTick,
          title,
          browser: browser$3,
          env,
          argv,
          version: version$1,
          versions,
          on,
          addListener,
          once,
          off,
          removeListener,
          removeAllListeners,
          emit,
          binding,
          cwd,
          chdir,
          umask,
          hrtime,
          platform,
          release,
          config: config3,
          uptime
        };
        var inherits$2;
        if (typeof Object.create === "function") {
          inherits$2 = function inherits2(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          };
        } else {
          inherits$2 = function inherits2(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }
        var inherits$3 = inherits$2;
        var formatRegExp = /%[sdj%]/g;
        function format$1(f) {
          if (!isString$1(f)) {
            var objects = [];
            for (var i = 0; i < arguments.length; i++) {
              objects.push(inspect3(arguments[i]));
            }
            return objects.join(" ");
          }
          var i = 1;
          var args = arguments;
          var len = args.length;
          var str = String(f).replace(formatRegExp, function(x2) {
            if (x2 === "%%") return "%";
            if (i >= len) return x2;
            switch (x2) {
              case "%s":
                return String(args[i++]);
              case "%d":
                return Number(args[i++]);
              case "%j":
                try {
                  return JSON.stringify(args[i++]);
                } catch (_) {
                  return "[Circular]";
                }
              default:
                return x2;
            }
          });
          for (var x = args[i]; i < len; x = args[++i]) {
            if (isNull(x) || !isObject2(x)) {
              str += " " + x;
            } else {
              str += " " + inspect3(x);
            }
          }
          return str;
        }
        function deprecate$1(fn, msg) {
          if (isUndefined(global$2.process)) {
            return function() {
              return deprecate$1(fn, msg).apply(this, arguments);
            };
          }
          if (browser$1$1.noDeprecation === true) {
            return fn;
          }
          var warned = false;
          function deprecated() {
            if (!warned) {
              if (browser$1$1.throwDeprecation) {
                throw new Error(msg);
              } else if (browser$1$1.traceDeprecation) {
                console.trace(msg);
              } else {
                console.error(msg);
              }
              warned = true;
            }
            return fn.apply(this, arguments);
          }
          return deprecated;
        }
        var debugs = {};
        var debugEnviron;
        function debuglog(set2) {
          if (isUndefined(debugEnviron))
            debugEnviron = browser$1$1.env.NODE_DEBUG || "";
          set2 = set2.toUpperCase();
          if (!debugs[set2]) {
            if (new RegExp("\\b" + set2 + "\\b", "i").test(debugEnviron)) {
              var pid = 0;
              debugs[set2] = function() {
                var msg = format$1.apply(null, arguments);
                console.error("%s %d: %s", set2, pid, msg);
              };
            } else {
              debugs[set2] = function() {
              };
            }
          }
          return debugs[set2];
        }
        function inspect3(obj, opts) {
          var ctx = {
            seen: [],
            stylize: stylizeNoColor
          };
          if (arguments.length >= 3) ctx.depth = arguments[2];
          if (arguments.length >= 4) ctx.colors = arguments[3];
          if (isBoolean(opts)) {
            ctx.showHidden = opts;
          } else if (opts) {
            _extend(ctx, opts);
          }
          if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
          if (isUndefined(ctx.depth)) ctx.depth = 2;
          if (isUndefined(ctx.colors)) ctx.colors = false;
          if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
          if (ctx.colors) ctx.stylize = stylizeWithColor;
          return formatValue2(ctx, obj, ctx.depth);
        }
        inspect3.colors = {
          "bold": [1, 22],
          "italic": [3, 23],
          "underline": [4, 24],
          "inverse": [7, 27],
          "white": [37, 39],
          "grey": [90, 39],
          "black": [30, 39],
          "blue": [34, 39],
          "cyan": [36, 39],
          "green": [32, 39],
          "magenta": [35, 39],
          "red": [31, 39],
          "yellow": [33, 39]
        };
        inspect3.styles = {
          "special": "cyan",
          "number": "yellow",
          "boolean": "yellow",
          "undefined": "grey",
          "null": "bold",
          "string": "green",
          "date": "magenta",
          // "name": intentionally not styling
          "regexp": "red"
        };
        function stylizeWithColor(str, styleType) {
          var style = inspect3.styles[styleType];
          if (style) {
            return "\x1B[" + inspect3.colors[style][0] + "m" + str + "\x1B[" + inspect3.colors[style][1] + "m";
          } else {
            return str;
          }
        }
        function stylizeNoColor(str, styleType) {
          return str;
        }
        function arrayToHash(array2) {
          var hash = {};
          array2.forEach(function(val, idx) {
            hash[val] = true;
          });
          return hash;
        }
        function formatValue2(ctx, value, recurseTimes) {
          if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
          value.inspect !== inspect3 && // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
            var ret = value.inspect(recurseTimes, ctx);
            if (!isString$1(ret)) {
              ret = formatValue2(ctx, ret, recurseTimes);
            }
            return ret;
          }
          var primitive = formatPrimitive(ctx, value);
          if (primitive) {
            return primitive;
          }
          var keys2 = Object.keys(value);
          var visibleKeys = arrayToHash(keys2);
          if (ctx.showHidden) {
            keys2 = Object.getOwnPropertyNames(value);
          }
          if (isError$1(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
            return formatError(value);
          }
          if (keys2.length === 0) {
            if (isFunction2(value)) {
              var name2 = value.name ? ": " + value.name : "";
              return ctx.stylize("[Function" + name2 + "]", "special");
            }
            if (isRegExp3(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
            }
            if (isDate(value)) {
              return ctx.stylize(Date.prototype.toString.call(value), "date");
            }
            if (isError$1(value)) {
              return formatError(value);
            }
          }
          var base2 = "", array2 = false, braces = ["{", "}"];
          if (isArray$1(value)) {
            array2 = true;
            braces = ["[", "]"];
          }
          if (isFunction2(value)) {
            var n = value.name ? ": " + value.name : "";
            base2 = " [Function" + n + "]";
          }
          if (isRegExp3(value)) {
            base2 = " " + RegExp.prototype.toString.call(value);
          }
          if (isDate(value)) {
            base2 = " " + Date.prototype.toUTCString.call(value);
          }
          if (isError$1(value)) {
            base2 = " " + formatError(value);
          }
          if (keys2.length === 0 && (!array2 || value.length == 0)) {
            return braces[0] + base2 + braces[1];
          }
          if (recurseTimes < 0) {
            if (isRegExp3(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
            } else {
              return ctx.stylize("[Object]", "special");
            }
          }
          ctx.seen.push(value);
          var output;
          if (array2) {
            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
          } else {
            output = keys2.map(function(key) {
              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2);
            });
          }
          ctx.seen.pop();
          return reduceToSingleString(output, base2, braces);
        }
        function formatPrimitive(ctx, value) {
          if (isUndefined(value))
            return ctx.stylize("undefined", "undefined");
          if (isString$1(value)) {
            var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return ctx.stylize(simple, "string");
          }
          if (isNumber(value))
            return ctx.stylize("" + value, "number");
          if (isBoolean(value))
            return ctx.stylize("" + value, "boolean");
          if (isNull(value))
            return ctx.stylize("null", "null");
        }
        function formatError(value) {
          return "[" + Error.prototype.toString.call(value) + "]";
        }
        function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
          var output = [];
          for (var i = 0, l = value.length; i < l; ++i) {
            if (hasOwnProperty(value, String(i))) {
              output.push(formatProperty(
                ctx,
                value,
                recurseTimes,
                visibleKeys,
                String(i),
                true
              ));
            } else {
              output.push("");
            }
          }
          keys2.forEach(function(key) {
            if (!key.match(/^\d+$/)) {
              output.push(formatProperty(
                ctx,
                value,
                recurseTimes,
                visibleKeys,
                key,
                true
              ));
            }
          });
          return output;
        }
        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2) {
          var name2, str, desc;
          desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
          if (desc.get) {
            if (desc.set) {
              str = ctx.stylize("[Getter/Setter]", "special");
            } else {
              str = ctx.stylize("[Getter]", "special");
            }
          } else {
            if (desc.set) {
              str = ctx.stylize("[Setter]", "special");
            }
          }
          if (!hasOwnProperty(visibleKeys, key)) {
            name2 = "[" + key + "]";
          }
          if (!str) {
            if (ctx.seen.indexOf(desc.value) < 0) {
              if (isNull(recurseTimes)) {
                str = formatValue2(ctx, desc.value, null);
              } else {
                str = formatValue2(ctx, desc.value, recurseTimes - 1);
              }
              if (str.indexOf("\n") > -1) {
                if (array2) {
                  str = str.split("\n").map(function(line2) {
                    return "  " + line2;
                  }).join("\n").substr(2);
                } else {
                  str = "\n" + str.split("\n").map(function(line2) {
                    return "   " + line2;
                  }).join("\n");
                }
              }
            } else {
              str = ctx.stylize("[Circular]", "special");
            }
          }
          if (isUndefined(name2)) {
            if (array2 && key.match(/^\d+$/)) {
              return str;
            }
            name2 = JSON.stringify("" + key);
            if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
              name2 = name2.substr(1, name2.length - 2);
              name2 = ctx.stylize(name2, "name");
            } else {
              name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
              name2 = ctx.stylize(name2, "string");
            }
          }
          return name2 + ": " + str;
        }
        function reduceToSingleString(output, base2, braces) {
          var length = output.reduce(function(prev, cur) {
            if (cur.indexOf("\n") >= 0) ;
            return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          if (length > 60) {
            return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
          }
          return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
        }
        function isArray$1(ar) {
          return Array.isArray(ar);
        }
        function isBoolean(arg) {
          return typeof arg === "boolean";
        }
        function isNull(arg) {
          return arg === null;
        }
        function isNullOrUndefined(arg) {
          return arg == null;
        }
        function isNumber(arg) {
          return typeof arg === "number";
        }
        function isString$1(arg) {
          return typeof arg === "string";
        }
        function isSymbol(arg) {
          return typeof arg === "symbol";
        }
        function isUndefined(arg) {
          return arg === void 0;
        }
        function isRegExp3(re) {
          return isObject2(re) && objectToString(re) === "[object RegExp]";
        }
        function isObject2(arg) {
          return typeof arg === "object" && arg !== null;
        }
        function isDate(d2) {
          return isObject2(d2) && objectToString(d2) === "[object Date]";
        }
        function isError$1(e) {
          return isObject2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
        }
        function isFunction2(arg) {
          return typeof arg === "function";
        }
        function isPrimitive2(arg) {
          return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
          typeof arg === "undefined";
        }
        function isBuffer$1(maybeBuf) {
          return Buffer$1.isBuffer(maybeBuf);
        }
        function objectToString(o) {
          return Object.prototype.toString.call(o);
        }
        function pad(n) {
          return n < 10 ? "0" + n.toString(10) : n.toString(10);
        }
        var months = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ];
        function timestamp() {
          var d2 = /* @__PURE__ */ new Date();
          var time = [
            pad(d2.getHours()),
            pad(d2.getMinutes()),
            pad(d2.getSeconds())
          ].join(":");
          return [d2.getDate(), months[d2.getMonth()], time].join(" ");
        }
        function log() {
          console.log("%s - %s", timestamp(), format$1.apply(null, arguments));
        }
        function _extend(origin, add) {
          if (!add || !isObject2(add)) return origin;
          var keys2 = Object.keys(add);
          var i = keys2.length;
          while (i--) {
            origin[keys2[i]] = add[keys2[i]];
          }
          return origin;
        }
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        var _polyfillNode_util = {
          inherits: inherits$3,
          _extend,
          log,
          isBuffer: isBuffer$1,
          isPrimitive: isPrimitive2,
          isFunction: isFunction2,
          isError: isError$1,
          isDate,
          isObject: isObject2,
          isRegExp: isRegExp3,
          isUndefined,
          isSymbol,
          isString: isString$1,
          isNumber,
          isNullOrUndefined,
          isNull,
          isBoolean,
          isArray: isArray$1,
          inspect: inspect3,
          deprecate: deprecate$1,
          format: format$1,
          debuglog
        };
        var _polyfillNode_util$1 = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          format: format$1,
          deprecate: deprecate$1,
          debuglog,
          inspect: inspect3,
          isArray: isArray$1,
          isBoolean,
          isNull,
          isNullOrUndefined,
          isNumber,
          isString: isString$1,
          isSymbol,
          isUndefined,
          isRegExp: isRegExp3,
          isObject: isObject2,
          isDate,
          isError: isError$1,
          isFunction: isFunction2,
          isPrimitive: isPrimitive2,
          isBuffer: isBuffer$1,
          log,
          inherits: inherits$3,
          _extend,
          "default": _polyfillNode_util
        });
        function BufferList() {
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        BufferList.prototype.push = function(v2) {
          var entry = { data: v2, next: null };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        };
        BufferList.prototype.unshift = function(v2) {
          var entry = { data: v2, next: this.head };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        };
        BufferList.prototype.shift = function() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        };
        BufferList.prototype.clear = function() {
          this.head = this.tail = null;
          this.length = 0;
        };
        BufferList.prototype.join = function(s2) {
          if (this.length === 0) return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s2 + p.data;
          }
          return ret;
        };
        BufferList.prototype.concat = function(n) {
          if (this.length === 0) return Buffer$1.alloc(0);
          if (this.length === 1) return this.head.data;
          var ret = Buffer$1.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            p.data.copy(ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        };
        var isBufferEncoding = Buffer$1.isEncoding || function(encoding) {
          switch (encoding && encoding.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        function assertEncoding(encoding) {
          if (encoding && !isBufferEncoding(encoding)) {
            throw new Error("Unknown encoding: " + encoding);
          }
        }
        function StringDecoder(encoding) {
          this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
          assertEncoding(encoding);
          switch (this.encoding) {
            case "utf8":
              this.surrogateSize = 3;
              break;
            case "ucs2":
            case "utf16le":
              this.surrogateSize = 2;
              this.detectIncompleteChar = utf16DetectIncompleteChar;
              break;
            case "base64":
              this.surrogateSize = 3;
              this.detectIncompleteChar = base64DetectIncompleteChar;
              break;
            default:
              this.write = passThroughWrite;
              return;
          }
          this.charBuffer = new Buffer$1(6);
          this.charReceived = 0;
          this.charLength = 0;
        }
        StringDecoder.prototype.write = function(buffer) {
          var charStr = "";
          while (this.charLength) {
            var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
            buffer.copy(this.charBuffer, this.charReceived, 0, available);
            this.charReceived += available;
            if (this.charReceived < this.charLength) {
              return "";
            }
            buffer = buffer.slice(available, buffer.length);
            charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
            var charCode = charStr.charCodeAt(charStr.length - 1);
            if (charCode >= 55296 && charCode <= 56319) {
              this.charLength += this.surrogateSize;
              charStr = "";
              continue;
            }
            this.charReceived = this.charLength = 0;
            if (buffer.length === 0) {
              return charStr;
            }
            break;
          }
          this.detectIncompleteChar(buffer);
          var end = buffer.length;
          if (this.charLength) {
            buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
            end -= this.charReceived;
          }
          charStr += buffer.toString(this.encoding, 0, end);
          var end = charStr.length - 1;
          var charCode = charStr.charCodeAt(end);
          if (charCode >= 55296 && charCode <= 56319) {
            var size = this.surrogateSize;
            this.charLength += size;
            this.charReceived += size;
            this.charBuffer.copy(this.charBuffer, size, 0, size);
            buffer.copy(this.charBuffer, 0, 0, size);
            return charStr.substring(0, end);
          }
          return charStr;
        };
        StringDecoder.prototype.detectIncompleteChar = function(buffer) {
          var i = buffer.length >= 3 ? 3 : buffer.length;
          for (; i > 0; i--) {
            var c = buffer[buffer.length - i];
            if (i == 1 && c >> 5 == 6) {
              this.charLength = 2;
              break;
            }
            if (i <= 2 && c >> 4 == 14) {
              this.charLength = 3;
              break;
            }
            if (i <= 3 && c >> 3 == 30) {
              this.charLength = 4;
              break;
            }
          }
          this.charReceived = i;
        };
        StringDecoder.prototype.end = function(buffer) {
          var res = "";
          if (buffer && buffer.length)
            res = this.write(buffer);
          if (this.charReceived) {
            var cr = this.charReceived;
            var buf = this.charBuffer;
            var enc = this.encoding;
            res += buf.slice(0, cr).toString(enc);
          }
          return res;
        };
        function passThroughWrite(buffer) {
          return buffer.toString(this.encoding);
        }
        function utf16DetectIncompleteChar(buffer) {
          this.charReceived = buffer.length % 2;
          this.charLength = this.charReceived ? 2 : 0;
        }
        function base64DetectIncompleteChar(buffer) {
          this.charReceived = buffer.length % 3;
          this.charLength = this.charReceived ? 3 : 0;
        }
        Readable.ReadableState = ReadableState;
        var debug$2 = debuglog("stream");
        inherits$3(Readable, EventEmitter$2);
        function prependListener(emitter, event, fn) {
          if (typeof emitter.prependListener === "function") {
            return emitter.prependListener(event, fn);
          } else {
            if (!emitter._events || !emitter._events[event])
              emitter.on(event, fn);
            else if (Array.isArray(emitter._events[event]))
              emitter._events[event].unshift(fn);
            else
              emitter._events[event] = [fn, emitter._events[event]];
          }
        }
        function listenerCount(emitter, type3) {
          return emitter.listeners(type3).length;
        }
        function ReadableState(options, stream) {
          options = options || {};
          this.objectMode = !!options.objectMode;
          if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
          var hwm = options.highWaterMark;
          var defaultHwm = this.objectMode ? 16 : 16 * 1024;
          this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
          this.highWaterMark = ~~this.highWaterMark;
          this.buffer = new BufferList();
          this.length = 0;
          this.pipes = null;
          this.pipesCount = 0;
          this.flowing = null;
          this.ended = false;
          this.endEmitted = false;
          this.reading = false;
          this.sync = true;
          this.needReadable = false;
          this.emittedReadable = false;
          this.readableListening = false;
          this.resumeScheduled = false;
          this.defaultEncoding = options.defaultEncoding || "utf8";
          this.ranOut = false;
          this.awaitDrain = 0;
          this.readingMore = false;
          this.decoder = null;
          this.encoding = null;
          if (options.encoding) {
            this.decoder = new StringDecoder(options.encoding);
            this.encoding = options.encoding;
          }
        }
        function Readable(options) {
          if (!(this instanceof Readable)) return new Readable(options);
          this._readableState = new ReadableState(options, this);
          this.readable = true;
          if (options && typeof options.read === "function") this._read = options.read;
          EventEmitter$2.call(this);
        }
        Readable.prototype.push = function(chunk, encoding) {
          var state = this._readableState;
          if (!state.objectMode && typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer$1.from(chunk, encoding);
              encoding = "";
            }
          }
          return readableAddChunk(this, state, chunk, encoding, false);
        };
        Readable.prototype.unshift = function(chunk) {
          var state = this._readableState;
          return readableAddChunk(this, state, chunk, "", true);
        };
        Readable.prototype.isPaused = function() {
          return this._readableState.flowing === false;
        };
        function readableAddChunk(stream, state, chunk, encoding, addToFront) {
          var er = chunkInvalid(state, chunk);
          if (er) {
            stream.emit("error", er);
          } else if (chunk === null) {
            state.reading = false;
            onEofChunk(stream, state);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (state.ended && !addToFront) {
              var e = new Error("stream.push() after EOF");
              stream.emit("error", e);
            } else if (state.endEmitted && addToFront) {
              var _e = new Error("stream.unshift() after end event");
              stream.emit("error", _e);
            } else {
              var skipAdd;
              if (state.decoder && !addToFront && !encoding) {
                chunk = state.decoder.write(chunk);
                skipAdd = !state.objectMode && chunk.length === 0;
              }
              if (!addToFront) state.reading = false;
              if (!skipAdd) {
                if (state.flowing && state.length === 0 && !state.sync) {
                  stream.emit("data", chunk);
                  stream.read(0);
                } else {
                  state.length += state.objectMode ? 1 : chunk.length;
                  if (addToFront) state.buffer.unshift(chunk);
                  else state.buffer.push(chunk);
                  if (state.needReadable) emitReadable(stream);
                }
              }
              maybeReadMore(stream, state);
            }
          } else if (!addToFront) {
            state.reading = false;
          }
          return needMoreData(state);
        }
        function needMoreData(state) {
          return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
        }
        Readable.prototype.setEncoding = function(enc) {
          this._readableState.decoder = new StringDecoder(enc);
          this._readableState.encoding = enc;
          return this;
        };
        var MAX_HWM = 8388608;
        function computeNewHighWaterMark(n) {
          if (n >= MAX_HWM) {
            n = MAX_HWM;
          } else {
            n--;
            n |= n >>> 1;
            n |= n >>> 2;
            n |= n >>> 4;
            n |= n >>> 8;
            n |= n >>> 16;
            n++;
          }
          return n;
        }
        function howMuchToRead(n, state) {
          if (n <= 0 || state.length === 0 && state.ended) return 0;
          if (state.objectMode) return 1;
          if (n !== n) {
            if (state.flowing && state.length) return state.buffer.head.data.length;
            else return state.length;
          }
          if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
          if (n <= state.length) return n;
          if (!state.ended) {
            state.needReadable = true;
            return 0;
          }
          return state.length;
        }
        Readable.prototype.read = function(n) {
          debug$2("read", n);
          n = parseInt(n, 10);
          var state = this._readableState;
          var nOrig = n;
          if (n !== 0) state.emittedReadable = false;
          if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
            debug$2("read: emitReadable", state.length, state.ended);
            if (state.length === 0 && state.ended) endReadable(this);
            else emitReadable(this);
            return null;
          }
          n = howMuchToRead(n, state);
          if (n === 0 && state.ended) {
            if (state.length === 0) endReadable(this);
            return null;
          }
          var doRead = state.needReadable;
          debug$2("need readable", doRead);
          if (state.length === 0 || state.length - n < state.highWaterMark) {
            doRead = true;
            debug$2("length less than watermark", doRead);
          }
          if (state.ended || state.reading) {
            doRead = false;
            debug$2("reading or ended", doRead);
          } else if (doRead) {
            debug$2("do read");
            state.reading = true;
            state.sync = true;
            if (state.length === 0) state.needReadable = true;
            this._read(state.highWaterMark);
            state.sync = false;
            if (!state.reading) n = howMuchToRead(nOrig, state);
          }
          var ret;
          if (n > 0) ret = fromList(n, state);
          else ret = null;
          if (ret === null) {
            state.needReadable = true;
            n = 0;
          } else {
            state.length -= n;
          }
          if (state.length === 0) {
            if (!state.ended) state.needReadable = true;
            if (nOrig !== n && state.ended) endReadable(this);
          }
          if (ret !== null) this.emit("data", ret);
          return ret;
        };
        function chunkInvalid(state, chunk) {
          var er = null;
          if (!Buffer$1.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
            er = new TypeError("Invalid non-string/buffer chunk");
          }
          return er;
        }
        function onEofChunk(stream, state) {
          if (state.ended) return;
          if (state.decoder) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) {
              state.buffer.push(chunk);
              state.length += state.objectMode ? 1 : chunk.length;
            }
          }
          state.ended = true;
          emitReadable(stream);
        }
        function emitReadable(stream) {
          var state = stream._readableState;
          state.needReadable = false;
          if (!state.emittedReadable) {
            debug$2("emitReadable", state.flowing);
            state.emittedReadable = true;
            if (state.sync) nextTick(emitReadable_, stream);
            else emitReadable_(stream);
          }
        }
        function emitReadable_(stream) {
          debug$2("emit readable");
          stream.emit("readable");
          flow(stream);
        }
        function maybeReadMore(stream, state) {
          if (!state.readingMore) {
            state.readingMore = true;
            nextTick(maybeReadMore_, stream, state);
          }
        }
        function maybeReadMore_(stream, state) {
          var len = state.length;
          while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
            debug$2("maybeReadMore read 0");
            stream.read(0);
            if (len === state.length)
              break;
            else len = state.length;
          }
          state.readingMore = false;
        }
        Readable.prototype._read = function(n) {
          this.emit("error", new Error("not implemented"));
        };
        Readable.prototype.pipe = function(dest, pipeOpts) {
          var src = this;
          var state = this._readableState;
          switch (state.pipesCount) {
            case 0:
              state.pipes = dest;
              break;
            case 1:
              state.pipes = [state.pipes, dest];
              break;
            default:
              state.pipes.push(dest);
              break;
          }
          state.pipesCount += 1;
          debug$2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
          var doEnd = !pipeOpts || pipeOpts.end !== false;
          var endFn = doEnd ? onend2 : cleanup;
          if (state.endEmitted) nextTick(endFn);
          else src.once("end", endFn);
          dest.on("unpipe", onunpipe);
          function onunpipe(readable) {
            debug$2("onunpipe");
            if (readable === src) {
              cleanup();
            }
          }
          function onend2() {
            debug$2("onend");
            dest.end();
          }
          var ondrain = pipeOnDrain(src);
          dest.on("drain", ondrain);
          var cleanedUp = false;
          function cleanup() {
            debug$2("cleanup");
            dest.removeListener("close", onclose);
            dest.removeListener("finish", onfinish);
            dest.removeListener("drain", ondrain);
            dest.removeListener("error", onerror);
            dest.removeListener("unpipe", onunpipe);
            src.removeListener("end", onend2);
            src.removeListener("end", cleanup);
            src.removeListener("data", ondata);
            cleanedUp = true;
            if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
          }
          var increasedAwaitDrain = false;
          src.on("data", ondata);
          function ondata(chunk) {
            debug$2("ondata");
            increasedAwaitDrain = false;
            var ret = dest.write(chunk);
            if (false === ret && !increasedAwaitDrain) {
              if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug$2("false write response, pause", src._readableState.awaitDrain);
                src._readableState.awaitDrain++;
                increasedAwaitDrain = true;
              }
              src.pause();
            }
          }
          function onerror(er) {
            debug$2("onerror", er);
            unpipe();
            dest.removeListener("error", onerror);
            if (listenerCount(dest, "error") === 0) dest.emit("error", er);
          }
          prependListener(dest, "error", onerror);
          function onclose() {
            dest.removeListener("finish", onfinish);
            unpipe();
          }
          dest.once("close", onclose);
          function onfinish() {
            debug$2("onfinish");
            dest.removeListener("close", onclose);
            unpipe();
          }
          dest.once("finish", onfinish);
          function unpipe() {
            debug$2("unpipe");
            src.unpipe(dest);
          }
          dest.emit("pipe", src);
          if (!state.flowing) {
            debug$2("pipe resume");
            src.resume();
          }
          return dest;
        };
        function pipeOnDrain(src) {
          return function() {
            var state = src._readableState;
            debug$2("pipeOnDrain", state.awaitDrain);
            if (state.awaitDrain) state.awaitDrain--;
            if (state.awaitDrain === 0 && src.listeners("data").length) {
              state.flowing = true;
              flow(src);
            }
          };
        }
        Readable.prototype.unpipe = function(dest) {
          var state = this._readableState;
          if (state.pipesCount === 0) return this;
          if (state.pipesCount === 1) {
            if (dest && dest !== state.pipes) return this;
            if (!dest) dest = state.pipes;
            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;
            if (dest) dest.emit("unpipe", this);
            return this;
          }
          if (!dest) {
            var dests = state.pipes;
            var len = state.pipesCount;
            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;
            for (var _i = 0; _i < len; _i++) {
              dests[_i].emit("unpipe", this);
            }
            return this;
          }
          var i = indexOf(state.pipes, dest);
          if (i === -1) return this;
          state.pipes.splice(i, 1);
          state.pipesCount -= 1;
          if (state.pipesCount === 1) state.pipes = state.pipes[0];
          dest.emit("unpipe", this);
          return this;
        };
        Readable.prototype.on = function(ev, fn) {
          var res = EventEmitter$2.prototype.on.call(this, ev, fn);
          if (ev === "data") {
            if (this._readableState.flowing !== false) this.resume();
          } else if (ev === "readable") {
            var state = this._readableState;
            if (!state.endEmitted && !state.readableListening) {
              state.readableListening = state.needReadable = true;
              state.emittedReadable = false;
              if (!state.reading) {
                nextTick(nReadingNextTick, this);
              } else if (state.length) {
                emitReadable(this);
              }
            }
          }
          return res;
        };
        Readable.prototype.addListener = Readable.prototype.on;
        function nReadingNextTick(self2) {
          debug$2("readable nexttick read 0");
          self2.read(0);
        }
        Readable.prototype.resume = function() {
          var state = this._readableState;
          if (!state.flowing) {
            debug$2("resume");
            state.flowing = true;
            resume(this, state);
          }
          return this;
        };
        function resume(stream, state) {
          if (!state.resumeScheduled) {
            state.resumeScheduled = true;
            nextTick(resume_, stream, state);
          }
        }
        function resume_(stream, state) {
          if (!state.reading) {
            debug$2("resume read 0");
            stream.read(0);
          }
          state.resumeScheduled = false;
          state.awaitDrain = 0;
          stream.emit("resume");
          flow(stream);
          if (state.flowing && !state.reading) stream.read(0);
        }
        Readable.prototype.pause = function() {
          debug$2("call pause flowing=%j", this._readableState.flowing);
          if (false !== this._readableState.flowing) {
            debug$2("pause");
            this._readableState.flowing = false;
            this.emit("pause");
          }
          return this;
        };
        function flow(stream) {
          var state = stream._readableState;
          debug$2("flow", state.flowing);
          while (state.flowing && stream.read() !== null) {
          }
        }
        Readable.prototype.wrap = function(stream) {
          var state = this._readableState;
          var paused = false;
          var self2 = this;
          stream.on("end", function() {
            debug$2("wrapped end");
            if (state.decoder && !state.ended) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) self2.push(chunk);
            }
            self2.push(null);
          });
          stream.on("data", function(chunk) {
            debug$2("wrapped data");
            if (state.decoder) chunk = state.decoder.write(chunk);
            if (state.objectMode && (chunk === null || chunk === void 0)) return;
            else if (!state.objectMode && (!chunk || !chunk.length)) return;
            var ret = self2.push(chunk);
            if (!ret) {
              paused = true;
              stream.pause();
            }
          });
          for (var i in stream) {
            if (this[i] === void 0 && typeof stream[i] === "function") {
              this[i] = /* @__PURE__ */ (function(method2) {
                return function() {
                  return stream[method2].apply(stream, arguments);
                };
              })(i);
            }
          }
          var events = ["error", "close", "destroy", "pause", "resume"];
          forEach(events, function(ev) {
            stream.on(ev, self2.emit.bind(self2, ev));
          });
          self2._read = function(n) {
            debug$2("wrapped _read", n);
            if (paused) {
              paused = false;
              stream.resume();
            }
          };
          return self2;
        };
        Readable._fromList = fromList;
        function fromList(n, state) {
          if (state.length === 0) return null;
          var ret;
          if (state.objectMode) ret = state.buffer.shift();
          else if (!n || n >= state.length) {
            if (state.decoder) ret = state.buffer.join("");
            else if (state.buffer.length === 1) ret = state.buffer.head.data;
            else ret = state.buffer.concat(state.length);
            state.buffer.clear();
          } else {
            ret = fromListPartial(n, state.buffer, state.decoder);
          }
          return ret;
        }
        function fromListPartial(n, list2, hasStrings) {
          var ret;
          if (n < list2.head.data.length) {
            ret = list2.head.data.slice(0, n);
            list2.head.data = list2.head.data.slice(n);
          } else if (n === list2.head.data.length) {
            ret = list2.shift();
          } else {
            ret = hasStrings ? copyFromBufferString(n, list2) : copyFromBuffer(n, list2);
          }
          return ret;
        }
        function copyFromBufferString(n, list2) {
          var p = list2.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) list2.head = p.next;
                else list2.head = list2.tail = null;
              } else {
                list2.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          list2.length -= c;
          return ret;
        }
        function copyFromBuffer(n, list2) {
          var ret = Buffer$1.allocUnsafe(n);
          var p = list2.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) list2.head = p.next;
                else list2.head = list2.tail = null;
              } else {
                list2.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          list2.length -= c;
          return ret;
        }
        function endReadable(stream) {
          var state = stream._readableState;
          if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
          if (!state.endEmitted) {
            state.ended = true;
            nextTick(endReadableNT, state, stream);
          }
        }
        function endReadableNT(state, stream) {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end");
          }
        }
        function forEach(xs, f) {
          for (var i = 0, l = xs.length; i < l; i++) {
            f(xs[i], i);
          }
        }
        function indexOf(xs, x) {
          for (var i = 0, l = xs.length; i < l; i++) {
            if (xs[i] === x) return i;
          }
          return -1;
        }
        Writable.WritableState = WritableState;
        inherits$3(Writable, EventEmitter$2);
        function nop() {
        }
        function WriteReq(chunk, encoding, cb) {
          this.chunk = chunk;
          this.encoding = encoding;
          this.callback = cb;
          this.next = null;
        }
        function WritableState(options, stream) {
          Object.defineProperty(this, "buffer", {
            get: deprecate$1(function() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
          });
          options = options || {};
          this.objectMode = !!options.objectMode;
          if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
          var hwm = options.highWaterMark;
          var defaultHwm = this.objectMode ? 16 : 16 * 1024;
          this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
          this.highWaterMark = ~~this.highWaterMark;
          this.needDrain = false;
          this.ending = false;
          this.ended = false;
          this.finished = false;
          var noDecode = options.decodeStrings === false;
          this.decodeStrings = !noDecode;
          this.defaultEncoding = options.defaultEncoding || "utf8";
          this.length = 0;
          this.writing = false;
          this.corked = 0;
          this.sync = true;
          this.bufferProcessing = false;
          this.onwrite = function(er) {
            onwrite(stream, er);
          };
          this.writecb = null;
          this.writelen = 0;
          this.bufferedRequest = null;
          this.lastBufferedRequest = null;
          this.pendingcb = 0;
          this.prefinished = false;
          this.errorEmitted = false;
          this.bufferedRequestCount = 0;
          this.corkedRequestsFree = new CorkedRequest(this);
        }
        WritableState.prototype.getBuffer = function writableStateGetBuffer() {
          var current = this.bufferedRequest;
          var out = [];
          while (current) {
            out.push(current);
            current = current.next;
          }
          return out;
        };
        function Writable(options) {
          if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
          this._writableState = new WritableState(options, this);
          this.writable = true;
          if (options) {
            if (typeof options.write === "function") this._write = options.write;
            if (typeof options.writev === "function") this._writev = options.writev;
          }
          EventEmitter$2.call(this);
        }
        Writable.prototype.pipe = function() {
          this.emit("error", new Error("Cannot pipe, not readable"));
        };
        function writeAfterEnd(stream, cb) {
          var er = new Error("write after end");
          stream.emit("error", er);
          nextTick(cb, er);
        }
        function validChunk(stream, state, chunk, cb) {
          var valid = true;
          var er = false;
          if (chunk === null) {
            er = new TypeError("May not write null values to stream");
          } else if (!Buffer$1.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
            er = new TypeError("Invalid non-string/buffer chunk");
          }
          if (er) {
            stream.emit("error", er);
            nextTick(cb, er);
            valid = false;
          }
          return valid;
        }
        Writable.prototype.write = function(chunk, encoding, cb) {
          var state = this._writableState;
          var ret = false;
          if (typeof encoding === "function") {
            cb = encoding;
            encoding = null;
          }
          if (Buffer$1.isBuffer(chunk)) encoding = "buffer";
          else if (!encoding) encoding = state.defaultEncoding;
          if (typeof cb !== "function") cb = nop;
          if (state.ended) writeAfterEnd(this, cb);
          else if (validChunk(this, state, chunk, cb)) {
            state.pendingcb++;
            ret = writeOrBuffer(this, state, chunk, encoding, cb);
          }
          return ret;
        };
        Writable.prototype.cork = function() {
          var state = this._writableState;
          state.corked++;
        };
        Writable.prototype.uncork = function() {
          var state = this._writableState;
          if (state.corked) {
            state.corked--;
            if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
          }
        };
        Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
          if (typeof encoding === "string") encoding = encoding.toLowerCase();
          if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
          this._writableState.defaultEncoding = encoding;
          return this;
        };
        function decodeChunk(state, chunk, encoding) {
          if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
            chunk = Buffer$1.from(chunk, encoding);
          }
          return chunk;
        }
        function writeOrBuffer(stream, state, chunk, encoding, cb) {
          chunk = decodeChunk(state, chunk, encoding);
          if (Buffer$1.isBuffer(chunk)) encoding = "buffer";
          var len = state.objectMode ? 1 : chunk.length;
          state.length += len;
          var ret = state.length < state.highWaterMark;
          if (!ret) state.needDrain = true;
          if (state.writing || state.corked) {
            var last = state.lastBufferedRequest;
            state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
            if (last) {
              last.next = state.lastBufferedRequest;
            } else {
              state.bufferedRequest = state.lastBufferedRequest;
            }
            state.bufferedRequestCount += 1;
          } else {
            doWrite(stream, state, false, len, chunk, encoding, cb);
          }
          return ret;
        }
        function doWrite(stream, state, writev, len, chunk, encoding, cb) {
          state.writelen = len;
          state.writecb = cb;
          state.writing = true;
          state.sync = true;
          if (writev) stream._writev(chunk, state.onwrite);
          else stream._write(chunk, encoding, state.onwrite);
          state.sync = false;
        }
        function onwriteError(stream, state, sync, er, cb) {
          --state.pendingcb;
          if (sync) nextTick(cb, er);
          else cb(er);
          stream._writableState.errorEmitted = true;
          stream.emit("error", er);
        }
        function onwriteStateUpdate(state) {
          state.writing = false;
          state.writecb = null;
          state.length -= state.writelen;
          state.writelen = 0;
        }
        function onwrite(stream, er) {
          var state = stream._writableState;
          var sync = state.sync;
          var cb = state.writecb;
          onwriteStateUpdate(state);
          if (er) onwriteError(stream, state, sync, er, cb);
          else {
            var finished = needFinish(state);
            if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
              clearBuffer(stream, state);
            }
            if (sync) {
              nextTick(afterWrite, stream, state, finished, cb);
            } else {
              afterWrite(stream, state, finished, cb);
            }
          }
        }
        function afterWrite(stream, state, finished, cb) {
          if (!finished) onwriteDrain(stream, state);
          state.pendingcb--;
          cb();
          finishMaybe(stream, state);
        }
        function onwriteDrain(stream, state) {
          if (state.length === 0 && state.needDrain) {
            state.needDrain = false;
            stream.emit("drain");
          }
        }
        function clearBuffer(stream, state) {
          state.bufferProcessing = true;
          var entry = state.bufferedRequest;
          if (stream._writev && entry && entry.next) {
            var l = state.bufferedRequestCount;
            var buffer = new Array(l);
            var holder = state.corkedRequestsFree;
            holder.entry = entry;
            var count = 0;
            while (entry) {
              buffer[count] = entry;
              entry = entry.next;
              count += 1;
            }
            doWrite(stream, state, true, state.length, buffer, "", holder.finish);
            state.pendingcb++;
            state.lastBufferedRequest = null;
            if (holder.next) {
              state.corkedRequestsFree = holder.next;
              holder.next = null;
            } else {
              state.corkedRequestsFree = new CorkedRequest(state);
            }
          } else {
            while (entry) {
              var chunk = entry.chunk;
              var encoding = entry.encoding;
              var cb = entry.callback;
              var len = state.objectMode ? 1 : chunk.length;
              doWrite(stream, state, false, len, chunk, encoding, cb);
              entry = entry.next;
              if (state.writing) {
                break;
              }
            }
            if (entry === null) state.lastBufferedRequest = null;
          }
          state.bufferedRequestCount = 0;
          state.bufferedRequest = entry;
          state.bufferProcessing = false;
        }
        Writable.prototype._write = function(chunk, encoding, cb) {
          cb(new Error("not implemented"));
        };
        Writable.prototype._writev = null;
        Writable.prototype.end = function(chunk, encoding, cb) {
          var state = this._writableState;
          if (typeof chunk === "function") {
            cb = chunk;
            chunk = null;
            encoding = null;
          } else if (typeof encoding === "function") {
            cb = encoding;
            encoding = null;
          }
          if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
          if (state.corked) {
            state.corked = 1;
            this.uncork();
          }
          if (!state.ending && !state.finished) endWritable(this, state, cb);
        };
        function needFinish(state) {
          return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
        }
        function prefinish(stream, state) {
          if (!state.prefinished) {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
        function finishMaybe(stream, state) {
          var need = needFinish(state);
          if (need) {
            if (state.pendingcb === 0) {
              prefinish(stream, state);
              state.finished = true;
              stream.emit("finish");
            } else {
              prefinish(stream, state);
            }
          }
          return need;
        }
        function endWritable(stream, state, cb) {
          state.ending = true;
          finishMaybe(stream, state);
          if (cb) {
            if (state.finished) nextTick(cb);
            else stream.once("finish", cb);
          }
          state.ended = true;
          stream.writable = false;
        }
        function CorkedRequest(state) {
          var _this = this;
          this.next = null;
          this.entry = null;
          this.finish = function(err) {
            var entry = _this.entry;
            _this.entry = null;
            while (entry) {
              var cb = entry.callback;
              state.pendingcb--;
              cb(err);
              entry = entry.next;
            }
            if (state.corkedRequestsFree) {
              state.corkedRequestsFree.next = _this;
            } else {
              state.corkedRequestsFree = _this;
            }
          };
        }
        inherits$3(Duplex, Readable);
        var keys = Object.keys(Writable.prototype);
        for (var v = 0; v < keys.length; v++) {
          var method = keys[v];
          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
        }
        function Duplex(options) {
          if (!(this instanceof Duplex)) return new Duplex(options);
          Readable.call(this, options);
          Writable.call(this, options);
          if (options && options.readable === false) this.readable = false;
          if (options && options.writable === false) this.writable = false;
          this.allowHalfOpen = true;
          if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
          this.once("end", onend);
        }
        function onend() {
          if (this.allowHalfOpen || this._writableState.ended) return;
          nextTick(onEndNT, this);
        }
        function onEndNT(self2) {
          self2.end();
        }
        inherits$3(Transform, Duplex);
        function TransformState(stream) {
          this.afterTransform = function(er, data) {
            return afterTransform(stream, er, data);
          };
          this.needTransform = false;
          this.transforming = false;
          this.writecb = null;
          this.writechunk = null;
          this.writeencoding = null;
        }
        function afterTransform(stream, er, data) {
          var ts = stream._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (!cb) return stream.emit("error", new Error("no writecb in Transform class"));
          ts.writechunk = null;
          ts.writecb = null;
          if (data !== null && data !== void 0) stream.push(data);
          cb(er);
          var rs = stream._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            stream._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform)) return new Transform(options);
          Duplex.call(this, options);
          this._transformState = new TransformState(this);
          var stream = this;
          this._readableState.needReadable = true;
          this._readableState.sync = false;
          if (options) {
            if (typeof options.transform === "function") this._transform = options.transform;
            if (typeof options.flush === "function") this._flush = options.flush;
          }
          this.once("prefinish", function() {
            if (typeof this._flush === "function") this._flush(function(er) {
              done(stream, er);
            });
            else done(stream);
          });
        }
        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };
        Transform.prototype._transform = function(chunk, encoding, cb) {
          throw new Error("Not implemented");
        };
        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
          }
        };
        Transform.prototype._read = function(n) {
          var ts = this._transformState;
          if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            ts.needTransform = true;
          }
        };
        function done(stream, er) {
          if (er) return stream.emit("error", er);
          var ws = stream._writableState;
          var ts = stream._transformState;
          if (ws.length) throw new Error("Calling transform done when ws.length != 0");
          if (ts.transforming) throw new Error("Calling transform done when still transforming");
          return stream.push(null);
        }
        inherits$3(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough)) return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk);
        };
        inherits$3(Stream, EventEmitter$2);
        Stream.Readable = Readable;
        Stream.Writable = Writable;
        Stream.Duplex = Duplex;
        Stream.Transform = Transform;
        Stream.PassThrough = PassThrough;
        Stream.Stream = Stream;
        function Stream() {
          EventEmitter$2.call(this);
        }
        Stream.prototype.pipe = function(dest, options) {
          var source = this;
          function ondata(chunk) {
            if (dest.writable) {
              if (false === dest.write(chunk) && source.pause) {
                source.pause();
              }
            }
          }
          source.on("data", ondata);
          function ondrain() {
            if (source.readable && source.resume) {
              source.resume();
            }
          }
          dest.on("drain", ondrain);
          if (!dest._isStdio && (!options || options.end !== false)) {
            source.on("end", onend2);
            source.on("close", onclose);
          }
          var didOnEnd = false;
          function onend2() {
            if (didOnEnd) return;
            didOnEnd = true;
            dest.end();
          }
          function onclose() {
            if (didOnEnd) return;
            didOnEnd = true;
            if (typeof dest.destroy === "function") dest.destroy();
          }
          function onerror(er) {
            cleanup();
            if (EventEmitter$2.listenerCount(this, "error") === 0) {
              throw er;
            }
          }
          source.on("error", onerror);
          dest.on("error", onerror);
          function cleanup() {
            source.removeListener("data", ondata);
            dest.removeListener("drain", ondrain);
            source.removeListener("end", onend2);
            source.removeListener("close", onclose);
            source.removeListener("error", onerror);
            dest.removeListener("error", onerror);
            source.removeListener("end", cleanup);
            source.removeListener("close", cleanup);
            dest.removeListener("close", cleanup);
          }
          source.on("end", cleanup);
          source.on("close", cleanup);
          dest.on("close", cleanup);
          dest.emit("pipe", source);
          return dest;
        };
        var _polyfillNode_stream = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          "default": Stream,
          Readable,
          Writable,
          Duplex,
          Transform,
          PassThrough,
          Stream
        });
        var require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_stream);
        var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_util$1);
        var WritableStream = require$$0$2.Writable;
        var inherits$1 = require$$0$1.inherits;
        var browserStdout = BrowserStdout;
        inherits$1(BrowserStdout, WritableStream);
        function BrowserStdout(opts) {
          if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts);
          opts = opts || {};
          WritableStream.call(this, opts);
          this.label = opts.label !== void 0 ? opts.label : "stdout";
        }
        BrowserStdout.prototype._write = function(chunks, encoding, cb) {
          var output = chunks.toString ? chunks.toString() : chunks;
          if (this.label === false) {
            console.log(output);
          } else {
            console.log(this.label + ":", output);
          }
          nextTick$1(cb);
        };
        var parseQuery$1 = function parseQuery2(qs) {
          return qs.replace("?", "").split("&").reduce(function(obj, pair) {
            var i = pair.indexOf("=");
            var key = pair.slice(0, i);
            var val = pair.slice(++i);
            obj[key] = decodeURIComponent(val.replace(/\+/g, "%20"));
            return obj;
          }, {});
        };
        function highlight(js) {
          return js.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\/\/(.*)/gm, '<span class="comment">//$1</span>').replace(/('.*?')/gm, '<span class="string">$1</span>').replace(/(\d+\.\d+)/gm, '<span class="number">$1</span>').replace(/(\d+)/gm, '<span class="number">$1</span>').replace(
            /\bnew[ \t]+(\w+)/gm,
            '<span class="keyword">new</span> <span class="init">$1</span>'
          ).replace(
            /\b(function|new|throw|return|var|if|else)\b/gm,
            '<span class="keyword">$1</span>'
          );
        }
        var highlightTags$1 = function highlightTags2(name2) {
          var code = document.getElementById("mocha").getElementsByTagName(name2);
          for (var i = 0, len = code.length; i < len; ++i) {
            code[i].innerHTML = highlight(code[i].innerHTML);
          }
        };
        var mocha$1 = { exports: {} };
        var escapeStringRegexp = (string) => {
          if (typeof string !== "string") {
            throw new TypeError("Expected a string");
          }
          return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        };
        function normalizeArray(parts, allowAboveRoot) {
          var up = 0;
          for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === ".") {
              parts.splice(i, 1);
            } else if (last === "..") {
              parts.splice(i, 1);
              up++;
            } else if (up) {
              parts.splice(i, 1);
              up--;
            }
          }
          if (allowAboveRoot) {
            for (; up--; up) {
              parts.unshift("..");
            }
          }
          return parts;
        }
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        var splitPath = function(filename) {
          return splitPathRe.exec(filename).slice(1);
        };
        function resolve() {
          var resolvedPath = "", resolvedAbsolute = false;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = i >= 0 ? arguments[i] : "/";
            if (typeof path !== "string") {
              throw new TypeError("Arguments to path.resolve must be strings");
            } else if (!path) {
              continue;
            }
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charAt(0) === "/";
          }
          resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
            return !!p;
          }), !resolvedAbsolute).join("/");
          return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
        }
        function normalize2(path) {
          var isPathAbsolute = isAbsolute(path), trailingSlash = substr(path, -1) === "/";
          path = normalizeArray(filter(path.split("/"), function(p) {
            return !!p;
          }), !isPathAbsolute).join("/");
          if (!path && !isPathAbsolute) {
            path = ".";
          }
          if (path && trailingSlash) {
            path += "/";
          }
          return (isPathAbsolute ? "/" : "") + path;
        }
        function isAbsolute(path) {
          return path.charAt(0) === "/";
        }
        function join() {
          var paths = Array.prototype.slice.call(arguments, 0);
          return normalize2(filter(paths, function(p, index) {
            if (typeof p !== "string") {
              throw new TypeError("Arguments to path.join must be strings");
            }
            return p;
          }).join("/"));
        }
        function relative(from2, to) {
          from2 = resolve(from2).substr(1);
          to = resolve(to).substr(1);
          function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
              if (arr[start] !== "") break;
            }
            var end = arr.length - 1;
            for (; end >= 0; end--) {
              if (arr[end] !== "") break;
            }
            if (start > end) return [];
            return arr.slice(start, end - start + 1);
          }
          var fromParts = trim(from2.split("/"));
          var toParts = trim(to.split("/"));
          var length = Math.min(fromParts.length, toParts.length);
          var samePartsLength = length;
          for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
              samePartsLength = i;
              break;
            }
          }
          var outputParts = [];
          for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push("..");
          }
          outputParts = outputParts.concat(toParts.slice(samePartsLength));
          return outputParts.join("/");
        }
        var sep = "/";
        var delimiter = ":";
        function dirname(path) {
          var result = splitPath(path), root = result[0], dir = result[1];
          if (!root && !dir) {
            return ".";
          }
          if (dir) {
            dir = dir.substr(0, dir.length - 1);
          }
          return root + dir;
        }
        function basename(path, ext) {
          var f = splitPath(path)[2];
          if (ext && f.substr(-1 * ext.length) === ext) {
            f = f.substr(0, f.length - ext.length);
          }
          return f;
        }
        function extname(path) {
          return splitPath(path)[3];
        }
        var _polyfillNode_path = {
          extname,
          basename,
          dirname,
          sep,
          delimiter,
          relative,
          join,
          isAbsolute,
          normalize: normalize2,
          resolve
        };
        function filter(xs, f) {
          if (xs.filter) return xs.filter(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            if (f(xs[i], i, xs)) res.push(xs[i]);
          }
          return res;
        }
        var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
          return str.substr(start, len);
        } : function(str, start, len) {
          if (start < 0) start = str.length + start;
          return str.substr(start, len);
        };
        var _polyfillNode_path$1 = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          resolve,
          normalize: normalize2,
          isAbsolute,
          join,
          relative,
          sep,
          delimiter,
          dirname,
          basename,
          extname,
          "default": _polyfillNode_path
        });
        var require$$1 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_path$1);
        var reporters = {};
        var base$1 = { exports: {} };
        var lib = {};
        var base = {};
        (function(exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2["default"] = Diff;
          function Diff() {
          }
          Diff.prototype = {
            /*istanbul ignore start*/
            /*istanbul ignore end*/
            diff: function diff2(oldString, newString) {
              var _options$timeout;
              var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              var callback = options.callback;
              if (typeof options === "function") {
                callback = options;
                options = {};
              }
              this.options = options;
              var self2 = this;
              function done2(value) {
                if (callback) {
                  setTimeout(function() {
                    callback(void 0, value);
                  }, 0);
                  return true;
                } else {
                  return value;
                }
              }
              oldString = this.castInput(oldString);
              newString = this.castInput(newString);
              oldString = this.removeEmpty(this.tokenize(oldString));
              newString = this.removeEmpty(this.tokenize(newString));
              var newLen = newString.length, oldLen = oldString.length;
              var editLength = 1;
              var maxEditLength = newLen + oldLen;
              if (options.maxEditLength) {
                maxEditLength = Math.min(maxEditLength, options.maxEditLength);
              }
              var maxExecutionTime = (
                /*istanbul ignore start*/
                (_options$timeout = /*istanbul ignore end*/
                options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity
              );
              var abortAfterTimestamp = Date.now() + maxExecutionTime;
              var bestPath = [{
                oldPos: -1,
                lastComponent: void 0
              }];
              var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);
              if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
                return done2([{
                  value: this.join(newString),
                  count: newString.length
                }]);
              }
              var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
              function execEditLength() {
                for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
                  var basePath = (
                    /*istanbul ignore start*/
                    void 0
                  );
                  var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
                  if (removePath) {
                    bestPath[diagonalPath - 1] = void 0;
                  }
                  var canAdd = false;
                  if (addPath) {
                    var addPathNewPos = addPath.oldPos - diagonalPath;
                    canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
                  }
                  var canRemove = removePath && removePath.oldPos + 1 < oldLen;
                  if (!canAdd && !canRemove) {
                    bestPath[diagonalPath] = void 0;
                    continue;
                  }
                  if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {
                    basePath = self2.addToPath(addPath, true, void 0, 0);
                  } else {
                    basePath = self2.addToPath(removePath, void 0, true, 1);
                  }
                  newPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
                  if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
                    return done2(buildValues(self2, basePath.lastComponent, newString, oldString, self2.useLongestToken));
                  } else {
                    bestPath[diagonalPath] = basePath;
                    if (basePath.oldPos + 1 >= oldLen) {
                      maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
                    }
                    if (newPos + 1 >= newLen) {
                      minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
                    }
                  }
                }
                editLength++;
              }
              if (callback) {
                (function exec() {
                  setTimeout(function() {
                    if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
                      return callback();
                    }
                    if (!execEditLength()) {
                      exec();
                    }
                  }, 0);
                })();
              } else {
                while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
                  var ret = execEditLength();
                  if (ret) {
                    return ret;
                  }
                }
              }
            },
            /*istanbul ignore start*/
            /*istanbul ignore end*/
            addToPath: function addToPath(path, added, removed, oldPosInc) {
              var last = path.lastComponent;
              if (last && last.added === added && last.removed === removed) {
                return {
                  oldPos: path.oldPos + oldPosInc,
                  lastComponent: {
                    count: last.count + 1,
                    added,
                    removed,
                    previousComponent: last.previousComponent
                  }
                };
              } else {
                return {
                  oldPos: path.oldPos + oldPosInc,
                  lastComponent: {
                    count: 1,
                    added,
                    removed,
                    previousComponent: last
                  }
                };
              }
            },
            /*istanbul ignore start*/
            /*istanbul ignore end*/
            extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
              var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
              while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
                newPos++;
                oldPos++;
                commonCount++;
              }
              if (commonCount) {
                basePath.lastComponent = {
                  count: commonCount,
                  previousComponent: basePath.lastComponent
                };
              }
              basePath.oldPos = oldPos;
              return newPos;
            },
            /*istanbul ignore start*/
            /*istanbul ignore end*/
            equals: function equals(left, right) {
              if (this.options.comparator) {
                return this.options.comparator(left, right);
              } else {
                return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
              }
            },
            /*istanbul ignore start*/
            /*istanbul ignore end*/
            removeEmpty: function removeEmpty(array2) {
              var ret = [];
              for (var i = 0; i < array2.length; i++) {
                if (array2[i]) {
                  ret.push(array2[i]);
                }
              }
              return ret;
            },
            /*istanbul ignore start*/
            /*istanbul ignore end*/
            castInput: function castInput(value) {
              return value;
            },
            /*istanbul ignore start*/
            /*istanbul ignore end*/
            tokenize: function tokenize(value) {
              return value.split("");
            },
            /*istanbul ignore start*/
            /*istanbul ignore end*/
            join: function join2(chars) {
              return chars.join("");
            }
          };
          function buildValues(diff2, lastComponent, newString, oldString, useLongestToken) {
            var components = [];
            var nextComponent;
            while (lastComponent) {
              components.push(lastComponent);
              nextComponent = lastComponent.previousComponent;
              delete lastComponent.previousComponent;
              lastComponent = nextComponent;
            }
            components.reverse();
            var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
            for (; componentPos < componentLen; componentPos++) {
              var component3 = components[componentPos];
              if (!component3.removed) {
                if (!component3.added && useLongestToken) {
                  var value = newString.slice(newPos, newPos + component3.count);
                  value = value.map(function(value2, i) {
                    var oldValue = oldString[oldPos + i];
                    return oldValue.length > value2.length ? oldValue : value2;
                  });
                  component3.value = diff2.join(value);
                } else {
                  component3.value = diff2.join(newString.slice(newPos, newPos + component3.count));
                }
                newPos += component3.count;
                if (!component3.added) {
                  oldPos += component3.count;
                }
              } else {
                component3.value = diff2.join(oldString.slice(oldPos, oldPos + component3.count));
                oldPos += component3.count;
                if (componentPos && components[componentPos - 1].added) {
                  var tmp = components[componentPos - 1];
                  components[componentPos - 1] = components[componentPos];
                  components[componentPos] = tmp;
                }
              }
            }
            var finalComponent = components[componentLen - 1];
            if (componentLen > 1 && typeof finalComponent.value === "string" && (finalComponent.added || finalComponent.removed) && diff2.equals("", finalComponent.value)) {
              components[componentLen - 2].value += finalComponent.value;
              components.pop();
            }
            return components;
          }
        })(base);
        var character = {};
        Object.defineProperty(character, "__esModule", {
          value: true
        });
        character.diffChars = diffChars;
        character.characterDiff = void 0;
        var _base$6 = _interopRequireDefault$7(base);
        function _interopRequireDefault$7(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        var characterDiff = new /*istanbul ignore start*/
        _base$6[
          /*istanbul ignore start*/
          "default"
          /*istanbul ignore end*/
        ]();
        character.characterDiff = characterDiff;
        function diffChars(oldStr, newStr, options) {
          return characterDiff.diff(oldStr, newStr, options);
        }
        var word = {};
        var params = {};
        Object.defineProperty(params, "__esModule", {
          value: true
        });
        params.generateOptions = generateOptions;
        function generateOptions(options, defaults) {
          if (typeof options === "function") {
            defaults.callback = options;
          } else if (options) {
            for (var name2 in options) {
              if (options.hasOwnProperty(name2)) {
                defaults[name2] = options[name2];
              }
            }
          }
          return defaults;
        }
        Object.defineProperty(word, "__esModule", {
          value: true
        });
        word.diffWords = diffWords;
        word.diffWordsWithSpace = diffWordsWithSpace;
        word.wordDiff = void 0;
        var _base$5 = _interopRequireDefault$6(base);
        var _params$1 = params;
        function _interopRequireDefault$6(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
        var reWhitespace = /\S/;
        var wordDiff = new /*istanbul ignore start*/
        _base$5[
          /*istanbul ignore start*/
          "default"
          /*istanbul ignore end*/
        ]();
        word.wordDiff = wordDiff;
        wordDiff.equals = function(left, right) {
          if (this.options.ignoreCase) {
            left = left.toLowerCase();
            right = right.toLowerCase();
          }
          return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
        };
        wordDiff.tokenize = function(value) {
          var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
          for (var i = 0; i < tokens.length - 1; i++) {
            if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
              tokens[i] += tokens[i + 2];
              tokens.splice(i + 1, 2);
              i--;
            }
          }
          return tokens;
        };
        function diffWords(oldStr, newStr, options) {
          options = /*istanbul ignore start*/
          /*istanbul ignore end*/
          /*istanbul ignore start*/
          (0, _params$1.generateOptions)(options, {
            ignoreWhitespace: true
          });
          return wordDiff.diff(oldStr, newStr, options);
        }
        function diffWordsWithSpace(oldStr, newStr, options) {
          return wordDiff.diff(oldStr, newStr, options);
        }
        var line = {};
        Object.defineProperty(line, "__esModule", {
          value: true
        });
        line.diffLines = diffLines;
        line.diffTrimmedLines = diffTrimmedLines;
        line.lineDiff = void 0;
        var _base$4 = _interopRequireDefault$5(base);
        var _params = params;
        function _interopRequireDefault$5(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        var lineDiff = new /*istanbul ignore start*/
        _base$4[
          /*istanbul ignore start*/
          "default"
          /*istanbul ignore end*/
        ]();
        line.lineDiff = lineDiff;
        lineDiff.tokenize = function(value) {
          if (this.options.stripTrailingCr) {
            value = value.replace(/\r\n/g, "\n");
          }
          var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
          if (!linesAndNewlines[linesAndNewlines.length - 1]) {
            linesAndNewlines.pop();
          }
          for (var i = 0; i < linesAndNewlines.length; i++) {
            var line2 = linesAndNewlines[i];
            if (i % 2 && !this.options.newlineIsToken) {
              retLines[retLines.length - 1] += line2;
            } else {
              if (this.options.ignoreWhitespace) {
                line2 = line2.trim();
              }
              retLines.push(line2);
            }
          }
          return retLines;
        };
        function diffLines(oldStr, newStr, callback) {
          return lineDiff.diff(oldStr, newStr, callback);
        }
        function diffTrimmedLines(oldStr, newStr, callback) {
          var options = (
            /*istanbul ignore start*/
            /*istanbul ignore end*/
            /*istanbul ignore start*/
            (0, _params.generateOptions)(callback, {
              ignoreWhitespace: true
            })
          );
          return lineDiff.diff(oldStr, newStr, options);
        }
        var sentence = {};
        Object.defineProperty(sentence, "__esModule", {
          value: true
        });
        sentence.diffSentences = diffSentences;
        sentence.sentenceDiff = void 0;
        var _base$3 = _interopRequireDefault$4(base);
        function _interopRequireDefault$4(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        var sentenceDiff = new /*istanbul ignore start*/
        _base$3[
          /*istanbul ignore start*/
          "default"
          /*istanbul ignore end*/
        ]();
        sentence.sentenceDiff = sentenceDiff;
        sentenceDiff.tokenize = function(value) {
          return value.split(/(\S.+?[.!?])(?=\s+|$)/);
        };
        function diffSentences(oldStr, newStr, callback) {
          return sentenceDiff.diff(oldStr, newStr, callback);
        }
        var css = {};
        Object.defineProperty(css, "__esModule", {
          value: true
        });
        css.diffCss = diffCss;
        css.cssDiff = void 0;
        var _base$2 = _interopRequireDefault$3(base);
        function _interopRequireDefault$3(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        var cssDiff = new /*istanbul ignore start*/
        _base$2[
          /*istanbul ignore start*/
          "default"
          /*istanbul ignore end*/
        ]();
        css.cssDiff = cssDiff;
        cssDiff.tokenize = function(value) {
          return value.split(/([{}:;,]|\s+)/);
        };
        function diffCss(oldStr, newStr, callback) {
          return cssDiff.diff(oldStr, newStr, callback);
        }
        var json$1 = {};
        Object.defineProperty(json$1, "__esModule", {
          value: true
        });
        json$1.diffJson = diffJson;
        json$1.canonicalize = canonicalize;
        json$1.jsonDiff = void 0;
        var _base$1 = _interopRequireDefault$2(base);
        var _line$1 = line;
        function _interopRequireDefault$2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _typeof3(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof3 = function _typeof4(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof3 = function _typeof4(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof3(obj);
        }
        var objectPrototypeToString = Object.prototype.toString;
        var jsonDiff = new /*istanbul ignore start*/
        _base$1[
          /*istanbul ignore start*/
          "default"
          /*istanbul ignore end*/
        ]();
        json$1.jsonDiff = jsonDiff;
        jsonDiff.useLongestToken = true;
        jsonDiff.tokenize = /*istanbul ignore start*/
        _line$1.lineDiff.tokenize;
        jsonDiff.castInput = function(value) {
          var _this$options = (
            /*istanbul ignore end*/
            this.options
          ), undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v2) {
            return (
              /*istanbul ignore end*/
              typeof v2 === "undefined" ? undefinedReplacement : v2
            );
          } : _this$options$stringi;
          return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
        };
        jsonDiff.equals = function(left, right) {
          return (
            /*istanbul ignore start*/
            _base$1[
              /*istanbul ignore start*/
              "default"
              /*istanbul ignore end*/
            ].prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"))
          );
        };
        function diffJson(oldObj, newObj, options) {
          return jsonDiff.diff(oldObj, newObj, options);
        }
        function canonicalize(obj, stack, replacementStack, replacer, key) {
          stack = stack || [];
          replacementStack = replacementStack || [];
          if (replacer) {
            obj = replacer(key, obj);
          }
          var i;
          for (i = 0; i < stack.length; i += 1) {
            if (stack[i] === obj) {
              return replacementStack[i];
            }
          }
          var canonicalizedObj;
          if ("[object Array]" === objectPrototypeToString.call(obj)) {
            stack.push(obj);
            canonicalizedObj = new Array(obj.length);
            replacementStack.push(canonicalizedObj);
            for (i = 0; i < obj.length; i += 1) {
              canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
            }
            stack.pop();
            replacementStack.pop();
            return canonicalizedObj;
          }
          if (obj && obj.toJSON) {
            obj = obj.toJSON();
          }
          if (
            /*istanbul ignore start*/
            _typeof3(
              /*istanbul ignore end*/
              obj
            ) === "object" && obj !== null
          ) {
            stack.push(obj);
            canonicalizedObj = {};
            replacementStack.push(canonicalizedObj);
            var sortedKeys = [], _key;
            for (_key in obj) {
              if (obj.hasOwnProperty(_key)) {
                sortedKeys.push(_key);
              }
            }
            sortedKeys.sort();
            for (i = 0; i < sortedKeys.length; i += 1) {
              _key = sortedKeys[i];
              canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
            }
            stack.pop();
            replacementStack.pop();
          } else {
            canonicalizedObj = obj;
          }
          return canonicalizedObj;
        }
        var array$1 = {};
        Object.defineProperty(array$1, "__esModule", {
          value: true
        });
        array$1.diffArrays = diffArrays;
        array$1.arrayDiff = void 0;
        var _base = _interopRequireDefault$1(base);
        function _interopRequireDefault$1(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        var arrayDiff = new /*istanbul ignore start*/
        _base[
          /*istanbul ignore start*/
          "default"
          /*istanbul ignore end*/
        ]();
        array$1.arrayDiff = arrayDiff;
        arrayDiff.tokenize = function(value) {
          return value.slice();
        };
        arrayDiff.join = arrayDiff.removeEmpty = function(value) {
          return value;
        };
        function diffArrays(oldArr, newArr, callback) {
          return arrayDiff.diff(oldArr, newArr, callback);
        }
        var apply2 = {};
        var parse$2 = {};
        Object.defineProperty(parse$2, "__esModule", {
          value: true
        });
        parse$2.parsePatch = parsePatch;
        function parsePatch(uniDiff) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/), delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [], list2 = [], i = 0;
          function parseIndex() {
            var index = {};
            list2.push(index);
            while (i < diffstr.length) {
              var line2 = diffstr[i];
              if (/^(\-\-\-|\+\+\+|@@)\s/.test(line2)) {
                break;
              }
              var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line2);
              if (header) {
                index.index = header[1];
              }
              i++;
            }
            parseFileHeader(index);
            parseFileHeader(index);
            index.hunks = [];
            while (i < diffstr.length) {
              var _line2 = diffstr[i];
              if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line2)) {
                break;
              } else if (/^@@/.test(_line2)) {
                index.hunks.push(parseHunk());
              } else if (_line2 && options.strict) {
                throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(_line2));
              } else {
                i++;
              }
            }
          }
          function parseFileHeader(index) {
            var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
            if (fileHeader) {
              var keyPrefix = fileHeader[1] === "---" ? "old" : "new";
              var data = fileHeader[2].split("	", 2);
              var fileName = data[0].replace(/\\\\/g, "\\");
              if (/^".*"$/.test(fileName)) {
                fileName = fileName.substr(1, fileName.length - 2);
              }
              index[keyPrefix + "FileName"] = fileName;
              index[keyPrefix + "Header"] = (data[1] || "").trim();
              i++;
            }
          }
          function parseHunk() {
            var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
            var hunk = {
              oldStart: +chunkHeader[1],
              oldLines: typeof chunkHeader[2] === "undefined" ? 1 : +chunkHeader[2],
              newStart: +chunkHeader[3],
              newLines: typeof chunkHeader[4] === "undefined" ? 1 : +chunkHeader[4],
              lines: [],
              linedelimiters: []
            };
            if (hunk.oldLines === 0) {
              hunk.oldStart += 1;
            }
            if (hunk.newLines === 0) {
              hunk.newStart += 1;
            }
            var addCount = 0, removeCount = 0;
            for (; i < diffstr.length; i++) {
              if (diffstr[i].indexOf("--- ") === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf("+++ ") === 0 && diffstr[i + 2].indexOf("@@") === 0) {
                break;
              }
              var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? " " : diffstr[i][0];
              if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
                hunk.lines.push(diffstr[i]);
                hunk.linedelimiters.push(delimiters[i] || "\n");
                if (operation === "+") {
                  addCount++;
                } else if (operation === "-") {
                  removeCount++;
                } else if (operation === " ") {
                  addCount++;
                  removeCount++;
                }
              } else {
                break;
              }
            }
            if (!addCount && hunk.newLines === 1) {
              hunk.newLines = 0;
            }
            if (!removeCount && hunk.oldLines === 1) {
              hunk.oldLines = 0;
            }
            if (options.strict) {
              if (addCount !== hunk.newLines) {
                throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
              }
              if (removeCount !== hunk.oldLines) {
                throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
              }
            }
            return hunk;
          }
          while (i < diffstr.length) {
            parseIndex();
          }
          return list2;
        }
        var distanceIterator = {};
        (function(exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2["default"] = _default;
          function _default(start, minLine, maxLine) {
            var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
            return function iterator() {
              if (wantForward && !forwardExhausted) {
                if (backwardExhausted) {
                  localOffset++;
                } else {
                  wantForward = false;
                }
                if (start + localOffset <= maxLine) {
                  return localOffset;
                }
                forwardExhausted = true;
              }
              if (!backwardExhausted) {
                if (!forwardExhausted) {
                  wantForward = true;
                }
                if (minLine <= start - localOffset) {
                  return -localOffset++;
                }
                backwardExhausted = true;
                return iterator();
              }
            };
          }
        })(distanceIterator);
        Object.defineProperty(apply2, "__esModule", {
          value: true
        });
        apply2.applyPatch = applyPatch2;
        apply2.applyPatches = applyPatches;
        var _parse$1 = parse$2;
        var _distanceIterator = _interopRequireDefault(distanceIterator);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function applyPatch2(source, uniDiff) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (typeof uniDiff === "string") {
            uniDiff = /*istanbul ignore start*/
            /*istanbul ignore end*/
            /*istanbul ignore start*/
            (0, _parse$1.parsePatch)(uniDiff);
          }
          if (Array.isArray(uniDiff)) {
            if (uniDiff.length > 1) {
              throw new Error("applyPatch only works with a single input.");
            }
            uniDiff = uniDiff[0];
          }
          var lines = source.split(/\r\n|[\n\v\f\r\x85]/), delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line3, operation2, patchContent) {
            return (
              /*istanbul ignore end*/
              line3 === patchContent
            );
          }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;
          function hunkFits(hunk2, toPos2) {
            for (var j2 = 0; j2 < hunk2.lines.length; j2++) {
              var line3 = hunk2.lines[j2], operation2 = line3.length > 0 ? line3[0] : " ", content2 = line3.length > 0 ? line3.substr(1) : line3;
              if (operation2 === " " || operation2 === "-") {
                if (!compareLine(toPos2 + 1, lines[toPos2], operation2, content2)) {
                  errorCount++;
                  if (errorCount > fuzzFactor) {
                    return false;
                  }
                }
                toPos2++;
              }
            }
            return true;
          }
          for (var i = 0; i < hunks.length; i++) {
            var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;
            var iterator = (
              /*istanbul ignore start*/
              /*istanbul ignore end*/
              /*istanbul ignore start*/
              (0, _distanceIterator[
                /*istanbul ignore start*/
                "default"
                /*istanbul ignore end*/
              ])(toPos, minLine, maxLine)
            );
            for (; localOffset !== void 0; localOffset = iterator()) {
              if (hunkFits(hunk, toPos + localOffset)) {
                hunk.offset = offset += localOffset;
                break;
              }
            }
            if (localOffset === void 0) {
              return false;
            }
            minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
          }
          var diffOffset = 0;
          for (var _i = 0; _i < hunks.length; _i++) {
            var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
            diffOffset += _hunk.newLines - _hunk.oldLines;
            for (var j = 0; j < _hunk.lines.length; j++) {
              var line2 = _hunk.lines[j], operation = line2.length > 0 ? line2[0] : " ", content = line2.length > 0 ? line2.substr(1) : line2, delimiter2 = _hunk.linedelimiters && _hunk.linedelimiters[j] || "\n";
              if (operation === " ") {
                _toPos++;
              } else if (operation === "-") {
                lines.splice(_toPos, 1);
                delimiters.splice(_toPos, 1);
              } else if (operation === "+") {
                lines.splice(_toPos, 0, content);
                delimiters.splice(_toPos, 0, delimiter2);
                _toPos++;
              } else if (operation === "\\") {
                var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
                if (previousOperation === "+") {
                  removeEOFNL = true;
                } else if (previousOperation === "-") {
                  addEOFNL = true;
                }
              }
            }
          }
          if (removeEOFNL) {
            while (!lines[lines.length - 1]) {
              lines.pop();
              delimiters.pop();
            }
          } else if (addEOFNL) {
            lines.push("");
            delimiters.push("\n");
          }
          for (var _k = 0; _k < lines.length - 1; _k++) {
            lines[_k] = lines[_k] + delimiters[_k];
          }
          return lines.join("");
        }
        function applyPatches(uniDiff, options) {
          if (typeof uniDiff === "string") {
            uniDiff = /*istanbul ignore start*/
            /*istanbul ignore end*/
            /*istanbul ignore start*/
            (0, _parse$1.parsePatch)(uniDiff);
          }
          var currentIndex = 0;
          function processIndex() {
            var index = uniDiff[currentIndex++];
            if (!index) {
              return options.complete();
            }
            options.loadFile(index, function(err, data) {
              if (err) {
                return options.complete(err);
              }
              var updatedContent = applyPatch2(data, index, options);
              options.patched(index, updatedContent, function(err2) {
                if (err2) {
                  return options.complete(err2);
                }
                processIndex();
              });
            });
          }
          processIndex();
        }
        var merge$1 = {};
        var create2 = {};
        Object.defineProperty(create2, "__esModule", {
          value: true
        });
        create2.structuredPatch = structuredPatch;
        create2.formatPatch = formatPatch;
        create2.createTwoFilesPatch = createTwoFilesPatch;
        create2.createPatch = createPatch;
        var _line = line;
        function _toConsumableArray$1(arr) {
          return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
        }
        function _nonIterableSpread$1() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _unsupportedIterableToArray$1(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
        }
        function _iterableToArray$1(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
        }
        function _arrayWithoutHoles$1(arr) {
          if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
        }
        function _arrayLikeToArray$1(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
          if (!options) {
            options = {};
          }
          if (typeof options.context === "undefined") {
            options.context = 4;
          }
          var diff2 = (
            /*istanbul ignore start*/
            /*istanbul ignore end*/
            /*istanbul ignore start*/
            (0, _line.diffLines)(oldStr, newStr, options)
          );
          if (!diff2) {
            return;
          }
          diff2.push({
            value: "",
            lines: []
          });
          function contextLines(lines) {
            return lines.map(function(entry) {
              return " " + entry;
            });
          }
          var hunks = [];
          var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
          var _loop = function _loop2(i2) {
            var current = diff2[i2], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
            current.lines = lines;
            if (current.added || current.removed) {
              var _curRange;
              if (!oldRangeStart) {
                var prev = diff2[i2 - 1];
                oldRangeStart = oldLine;
                newRangeStart = newLine;
                if (prev) {
                  curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
                  oldRangeStart -= curRange.length;
                  newRangeStart -= curRange.length;
                }
              }
              (_curRange = /*istanbul ignore end*/
              curRange).push.apply(
                /*istanbul ignore start*/
                _curRange,
                /*istanbul ignore start*/
                _toConsumableArray$1(
                  /*istanbul ignore end*/
                  lines.map(function(entry) {
                    return (current.added ? "+" : "-") + entry;
                  })
                )
              );
              if (current.added) {
                newLine += lines.length;
              } else {
                oldLine += lines.length;
              }
            } else {
              if (oldRangeStart) {
                if (lines.length <= options.context * 2 && i2 < diff2.length - 2) {
                  var _curRange2;
                  (_curRange2 = /*istanbul ignore end*/
                  curRange).push.apply(
                    /*istanbul ignore start*/
                    _curRange2,
                    /*istanbul ignore start*/
                    _toConsumableArray$1(
                      /*istanbul ignore end*/
                      contextLines(lines)
                    )
                  );
                } else {
                  var _curRange3;
                  var contextSize = Math.min(lines.length, options.context);
                  (_curRange3 = /*istanbul ignore end*/
                  curRange).push.apply(
                    /*istanbul ignore start*/
                    _curRange3,
                    /*istanbul ignore start*/
                    _toConsumableArray$1(
                      /*istanbul ignore end*/
                      contextLines(lines.slice(0, contextSize))
                    )
                  );
                  var hunk = {
                    oldStart: oldRangeStart,
                    oldLines: oldLine - oldRangeStart + contextSize,
                    newStart: newRangeStart,
                    newLines: newLine - newRangeStart + contextSize,
                    lines: curRange
                  };
                  if (i2 >= diff2.length - 2 && lines.length <= options.context) {
                    var oldEOFNewline = /\n$/.test(oldStr);
                    var newEOFNewline = /\n$/.test(newStr);
                    var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
                    if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {
                      curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file");
                    }
                    if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                      curRange.push("\\ No newline at end of file");
                    }
                  }
                  hunks.push(hunk);
                  oldRangeStart = 0;
                  newRangeStart = 0;
                  curRange = [];
                }
              }
              oldLine += lines.length;
              newLine += lines.length;
            }
          };
          for (var i = 0; i < diff2.length; i++) {
            _loop(
              /*istanbul ignore end*/
              i
            );
          }
          return {
            oldFileName,
            newFileName,
            oldHeader,
            newHeader,
            hunks
          };
        }
        function formatPatch(diff2) {
          if (Array.isArray(diff2)) {
            return diff2.map(formatPatch).join("\n");
          }
          var ret = [];
          if (diff2.oldFileName == diff2.newFileName) {
            ret.push("Index: " + diff2.oldFileName);
          }
          ret.push("===================================================================");
          ret.push("--- " + diff2.oldFileName + (typeof diff2.oldHeader === "undefined" ? "" : "	" + diff2.oldHeader));
          ret.push("+++ " + diff2.newFileName + (typeof diff2.newHeader === "undefined" ? "" : "	" + diff2.newHeader));
          for (var i = 0; i < diff2.hunks.length; i++) {
            var hunk = diff2.hunks[i];
            if (hunk.oldLines === 0) {
              hunk.oldStart -= 1;
            }
            if (hunk.newLines === 0) {
              hunk.newStart -= 1;
            }
            ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
            ret.push.apply(ret, hunk.lines);
          }
          return ret.join("\n") + "\n";
        }
        function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
          return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
        }
        function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
          return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
        }
        var array = {};
        Object.defineProperty(array, "__esModule", {
          value: true
        });
        array.arrayEqual = arrayEqual;
        array.arrayStartsWith = arrayStartsWith;
        function arrayEqual(a, b) {
          if (a.length !== b.length) {
            return false;
          }
          return arrayStartsWith(a, b);
        }
        function arrayStartsWith(array2, start) {
          if (start.length > array2.length) {
            return false;
          }
          for (var i = 0; i < start.length; i++) {
            if (start[i] !== array2[i]) {
              return false;
            }
          }
          return true;
        }
        Object.defineProperty(merge$1, "__esModule", {
          value: true
        });
        merge$1.calcLineCount = calcLineCount;
        merge$1.merge = merge;
        var _create = create2;
        var _parse = parse$2;
        var _array = array;
        function _toConsumableArray(arr) {
          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
        }
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
        }
        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr)) return _arrayLikeToArray(arr);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function calcLineCount(hunk) {
          var _calcOldNewLineCount = (
            /*istanbul ignore end*/
            calcOldNewLineCount(hunk.lines)
          ), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;
          if (oldLines !== void 0) {
            hunk.oldLines = oldLines;
          } else {
            delete hunk.oldLines;
          }
          if (newLines !== void 0) {
            hunk.newLines = newLines;
          } else {
            delete hunk.newLines;
          }
        }
        function merge(mine, theirs, base2) {
          mine = loadPatch(mine, base2);
          theirs = loadPatch(theirs, base2);
          var ret = {};
          if (mine.index || theirs.index) {
            ret.index = mine.index || theirs.index;
          }
          if (mine.newFileName || theirs.newFileName) {
            if (!fileNameChanged(mine)) {
              ret.oldFileName = theirs.oldFileName || mine.oldFileName;
              ret.newFileName = theirs.newFileName || mine.newFileName;
              ret.oldHeader = theirs.oldHeader || mine.oldHeader;
              ret.newHeader = theirs.newHeader || mine.newHeader;
            } else if (!fileNameChanged(theirs)) {
              ret.oldFileName = mine.oldFileName;
              ret.newFileName = mine.newFileName;
              ret.oldHeader = mine.oldHeader;
              ret.newHeader = mine.newHeader;
            } else {
              ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
              ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
              ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
              ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
            }
          }
          ret.hunks = [];
          var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;
          while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
            var mineCurrent = mine.hunks[mineIndex] || {
              oldStart: Infinity
            }, theirsCurrent = theirs.hunks[theirsIndex] || {
              oldStart: Infinity
            };
            if (hunkBefore(mineCurrent, theirsCurrent)) {
              ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
              mineIndex++;
              theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
            } else if (hunkBefore(theirsCurrent, mineCurrent)) {
              ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
              theirsIndex++;
              mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
            } else {
              var mergedHunk = {
                oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
                oldLines: 0,
                newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
                newLines: 0,
                lines: []
              };
              mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
              theirsIndex++;
              mineIndex++;
              ret.hunks.push(mergedHunk);
            }
          }
          return ret;
        }
        function loadPatch(param, base2) {
          if (typeof param === "string") {
            if (/^@@/m.test(param) || /^Index:/m.test(param)) {
              return (
                /*istanbul ignore start*/
                /*istanbul ignore end*/
                /*istanbul ignore start*/
                (0, _parse.parsePatch)(param)[0]
              );
            }
            if (!base2) {
              throw new Error("Must provide a base reference or pass in a patch");
            }
            return (
              /*istanbul ignore start*/
              /*istanbul ignore end*/
              /*istanbul ignore start*/
              (0, _create.structuredPatch)(void 0, void 0, base2, param)
            );
          }
          return param;
        }
        function fileNameChanged(patch) {
          return patch.newFileName && patch.newFileName !== patch.oldFileName;
        }
        function selectField(index, mine, theirs) {
          if (mine === theirs) {
            return mine;
          } else {
            index.conflict = true;
            return {
              mine,
              theirs
            };
          }
        }
        function hunkBefore(test3, check) {
          return test3.oldStart < check.oldStart && test3.oldStart + test3.oldLines < check.oldStart;
        }
        function cloneHunk(hunk, offset) {
          return {
            oldStart: hunk.oldStart,
            oldLines: hunk.oldLines,
            newStart: hunk.newStart + offset,
            newLines: hunk.newLines,
            lines: hunk.lines
          };
        }
        function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
          var mine = {
            offset: mineOffset,
            lines: mineLines,
            index: 0
          }, their = {
            offset: theirOffset,
            lines: theirLines,
            index: 0
          };
          insertLeading(hunk, mine, their);
          insertLeading(hunk, their, mine);
          while (mine.index < mine.lines.length && their.index < their.lines.length) {
            var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];
            if ((mineCurrent[0] === "-" || mineCurrent[0] === "+") && (theirCurrent[0] === "-" || theirCurrent[0] === "+")) {
              mutualChange(hunk, mine, their);
            } else if (mineCurrent[0] === "+" && theirCurrent[0] === " ") {
              var _hunk$lines;
              (_hunk$lines = /*istanbul ignore end*/
              hunk.lines).push.apply(
                /*istanbul ignore start*/
                _hunk$lines,
                /*istanbul ignore start*/
                _toConsumableArray(
                  /*istanbul ignore end*/
                  collectChange(mine)
                )
              );
            } else if (theirCurrent[0] === "+" && mineCurrent[0] === " ") {
              var _hunk$lines2;
              (_hunk$lines2 = /*istanbul ignore end*/
              hunk.lines).push.apply(
                /*istanbul ignore start*/
                _hunk$lines2,
                /*istanbul ignore start*/
                _toConsumableArray(
                  /*istanbul ignore end*/
                  collectChange(their)
                )
              );
            } else if (mineCurrent[0] === "-" && theirCurrent[0] === " ") {
              removal(hunk, mine, their);
            } else if (theirCurrent[0] === "-" && mineCurrent[0] === " ") {
              removal(hunk, their, mine, true);
            } else if (mineCurrent === theirCurrent) {
              hunk.lines.push(mineCurrent);
              mine.index++;
              their.index++;
            } else {
              conflict(hunk, collectChange(mine), collectChange(their));
            }
          }
          insertTrailing(hunk, mine);
          insertTrailing(hunk, their);
          calcLineCount(hunk);
        }
        function mutualChange(hunk, mine, their) {
          var myChanges = collectChange(mine), theirChanges = collectChange(their);
          if (allRemoves(myChanges) && allRemoves(theirChanges)) {
            if (
              /*istanbul ignore start*/
              /*istanbul ignore end*/
              /*istanbul ignore start*/
              (0, _array.arrayStartsWith)(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)
            ) {
              var _hunk$lines3;
              (_hunk$lines3 = /*istanbul ignore end*/
              hunk.lines).push.apply(
                /*istanbul ignore start*/
                _hunk$lines3,
                /*istanbul ignore start*/
                _toConsumableArray(
                  /*istanbul ignore end*/
                  myChanges
                )
              );
              return;
            } else if (
              /*istanbul ignore start*/
              /*istanbul ignore end*/
              /*istanbul ignore start*/
              (0, _array.arrayStartsWith)(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)
            ) {
              var _hunk$lines4;
              (_hunk$lines4 = /*istanbul ignore end*/
              hunk.lines).push.apply(
                /*istanbul ignore start*/
                _hunk$lines4,
                /*istanbul ignore start*/
                _toConsumableArray(
                  /*istanbul ignore end*/
                  theirChanges
                )
              );
              return;
            }
          } else if (
            /*istanbul ignore start*/
            /*istanbul ignore end*/
            /*istanbul ignore start*/
            (0, _array.arrayEqual)(myChanges, theirChanges)
          ) {
            var _hunk$lines5;
            (_hunk$lines5 = /*istanbul ignore end*/
            hunk.lines).push.apply(
              /*istanbul ignore start*/
              _hunk$lines5,
              /*istanbul ignore start*/
              _toConsumableArray(
                /*istanbul ignore end*/
                myChanges
              )
            );
            return;
          }
          conflict(hunk, myChanges, theirChanges);
        }
        function removal(hunk, mine, their, swap2) {
          var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);
          if (theirChanges.merged) {
            var _hunk$lines6;
            (_hunk$lines6 = /*istanbul ignore end*/
            hunk.lines).push.apply(
              /*istanbul ignore start*/
              _hunk$lines6,
              /*istanbul ignore start*/
              _toConsumableArray(
                /*istanbul ignore end*/
                theirChanges.merged
              )
            );
          } else {
            conflict(hunk, swap2 ? theirChanges : myChanges, swap2 ? myChanges : theirChanges);
          }
        }
        function conflict(hunk, mine, their) {
          hunk.conflict = true;
          hunk.lines.push({
            conflict: true,
            mine,
            theirs: their
          });
        }
        function insertLeading(hunk, insert, their) {
          while (insert.offset < their.offset && insert.index < insert.lines.length) {
            var line2 = insert.lines[insert.index++];
            hunk.lines.push(line2);
            insert.offset++;
          }
        }
        function insertTrailing(hunk, insert) {
          while (insert.index < insert.lines.length) {
            var line2 = insert.lines[insert.index++];
            hunk.lines.push(line2);
          }
        }
        function collectChange(state) {
          var ret = [], operation = state.lines[state.index][0];
          while (state.index < state.lines.length) {
            var line2 = state.lines[state.index];
            if (operation === "-" && line2[0] === "+") {
              operation = "+";
            }
            if (operation === line2[0]) {
              ret.push(line2);
              state.index++;
            } else {
              break;
            }
          }
          return ret;
        }
        function collectContext(state, matchChanges) {
          var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;
          while (matchIndex < matchChanges.length && state.index < state.lines.length) {
            var change = state.lines[state.index], match = matchChanges[matchIndex];
            if (match[0] === "+") {
              break;
            }
            contextChanges = contextChanges || change[0] !== " ";
            merged.push(match);
            matchIndex++;
            if (change[0] === "+") {
              conflicted = true;
              while (change[0] === "+") {
                changes.push(change);
                change = state.lines[++state.index];
              }
            }
            if (match.substr(1) === change.substr(1)) {
              changes.push(change);
              state.index++;
            } else {
              conflicted = true;
            }
          }
          if ((matchChanges[matchIndex] || "")[0] === "+" && contextChanges) {
            conflicted = true;
          }
          if (conflicted) {
            return changes;
          }
          while (matchIndex < matchChanges.length) {
            merged.push(matchChanges[matchIndex++]);
          }
          return {
            merged,
            changes
          };
        }
        function allRemoves(changes) {
          return changes.reduce(function(prev, change) {
            return prev && change[0] === "-";
          }, true);
        }
        function skipRemoveSuperset(state, removeChanges, delta) {
          for (var i = 0; i < delta; i++) {
            var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
            if (state.lines[state.index + i] !== " " + changeContent) {
              return false;
            }
          }
          state.index += delta;
          return true;
        }
        function calcOldNewLineCount(lines) {
          var oldLines = 0;
          var newLines = 0;
          lines.forEach(function(line2) {
            if (typeof line2 !== "string") {
              var myCount = calcOldNewLineCount(line2.mine);
              var theirCount = calcOldNewLineCount(line2.theirs);
              if (oldLines !== void 0) {
                if (myCount.oldLines === theirCount.oldLines) {
                  oldLines += myCount.oldLines;
                } else {
                  oldLines = void 0;
                }
              }
              if (newLines !== void 0) {
                if (myCount.newLines === theirCount.newLines) {
                  newLines += myCount.newLines;
                } else {
                  newLines = void 0;
                }
              }
            } else {
              if (newLines !== void 0 && (line2[0] === "+" || line2[0] === " ")) {
                newLines++;
              }
              if (oldLines !== void 0 && (line2[0] === "-" || line2[0] === " ")) {
                oldLines++;
              }
            }
          });
          return {
            oldLines,
            newLines
          };
        }
        var reverse = {};
        Object.defineProperty(reverse, "__esModule", {
          value: true
        });
        reverse.reversePatch = reversePatch;
        function ownKeys2(object, enumerableOnly) {
          var keys2 = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
            keys2.push.apply(keys2, symbols);
          }
          return keys2;
        }
        function _objectSpread2(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys2(Object(source), true).forEach(function(key) {
                _defineProperty3(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys2(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function _defineProperty3(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function reversePatch(structuredPatch2) {
          if (Array.isArray(structuredPatch2)) {
            return structuredPatch2.map(reversePatch).reverse();
          }
          return (
            /*istanbul ignore start*/
            _objectSpread2(_objectSpread2(
              {},
              /*istanbul ignore end*/
              structuredPatch2
            ), {}, {
              oldFileName: structuredPatch2.newFileName,
              oldHeader: structuredPatch2.newHeader,
              newFileName: structuredPatch2.oldFileName,
              newHeader: structuredPatch2.oldHeader,
              hunks: structuredPatch2.hunks.map(function(hunk) {
                return {
                  oldLines: hunk.newLines,
                  oldStart: hunk.newStart,
                  newLines: hunk.oldLines,
                  newStart: hunk.oldStart,
                  linedelimiters: hunk.linedelimiters,
                  lines: hunk.lines.map(function(l) {
                    if (l.startsWith("-")) {
                      return (
                        /*istanbul ignore start*/
                        "+".concat(
                          /*istanbul ignore end*/
                          l.slice(1)
                        )
                      );
                    }
                    if (l.startsWith("+")) {
                      return (
                        /*istanbul ignore start*/
                        "-".concat(
                          /*istanbul ignore end*/
                          l.slice(1)
                        )
                      );
                    }
                    return l;
                  })
                };
              })
            })
          );
        }
        var dmp = {};
        Object.defineProperty(dmp, "__esModule", {
          value: true
        });
        dmp.convertChangesToDMP = convertChangesToDMP;
        function convertChangesToDMP(changes) {
          var ret = [], change, operation;
          for (var i = 0; i < changes.length; i++) {
            change = changes[i];
            if (change.added) {
              operation = 1;
            } else if (change.removed) {
              operation = -1;
            } else {
              operation = 0;
            }
            ret.push([operation, change.value]);
          }
          return ret;
        }
        var xml = {};
        Object.defineProperty(xml, "__esModule", {
          value: true
        });
        xml.convertChangesToXML = convertChangesToXML;
        function convertChangesToXML(changes) {
          var ret = [];
          for (var i = 0; i < changes.length; i++) {
            var change = changes[i];
            if (change.added) {
              ret.push("<ins>");
            } else if (change.removed) {
              ret.push("<del>");
            }
            ret.push(escapeHTML2(change.value));
            if (change.added) {
              ret.push("</ins>");
            } else if (change.removed) {
              ret.push("</del>");
            }
          }
          return ret.join("");
        }
        function escapeHTML2(s2) {
          var n = s2;
          n = n.replace(/&/g, "&amp;");
          n = n.replace(/</g, "&lt;");
          n = n.replace(/>/g, "&gt;");
          n = n.replace(/"/g, "&quot;");
          return n;
        }
        (function(exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          Object.defineProperty(exports2, "Diff", {
            enumerable: true,
            get: function get2() {
              return _base2["default"];
            }
          });
          Object.defineProperty(exports2, "diffChars", {
            enumerable: true,
            get: function get2() {
              return _character.diffChars;
            }
          });
          Object.defineProperty(exports2, "diffWords", {
            enumerable: true,
            get: function get2() {
              return _word.diffWords;
            }
          });
          Object.defineProperty(exports2, "diffWordsWithSpace", {
            enumerable: true,
            get: function get2() {
              return _word.diffWordsWithSpace;
            }
          });
          Object.defineProperty(exports2, "diffLines", {
            enumerable: true,
            get: function get2() {
              return _line2.diffLines;
            }
          });
          Object.defineProperty(exports2, "diffTrimmedLines", {
            enumerable: true,
            get: function get2() {
              return _line2.diffTrimmedLines;
            }
          });
          Object.defineProperty(exports2, "diffSentences", {
            enumerable: true,
            get: function get2() {
              return _sentence.diffSentences;
            }
          });
          Object.defineProperty(exports2, "diffCss", {
            enumerable: true,
            get: function get2() {
              return _css.diffCss;
            }
          });
          Object.defineProperty(exports2, "diffJson", {
            enumerable: true,
            get: function get2() {
              return _json.diffJson;
            }
          });
          Object.defineProperty(exports2, "canonicalize", {
            enumerable: true,
            get: function get2() {
              return _json.canonicalize;
            }
          });
          Object.defineProperty(exports2, "diffArrays", {
            enumerable: true,
            get: function get2() {
              return _array2.diffArrays;
            }
          });
          Object.defineProperty(exports2, "applyPatch", {
            enumerable: true,
            get: function get2() {
              return _apply.applyPatch;
            }
          });
          Object.defineProperty(exports2, "applyPatches", {
            enumerable: true,
            get: function get2() {
              return _apply.applyPatches;
            }
          });
          Object.defineProperty(exports2, "parsePatch", {
            enumerable: true,
            get: function get2() {
              return _parse2.parsePatch;
            }
          });
          Object.defineProperty(exports2, "merge", {
            enumerable: true,
            get: function get2() {
              return _merge.merge;
            }
          });
          Object.defineProperty(exports2, "reversePatch", {
            enumerable: true,
            get: function get2() {
              return _reverse.reversePatch;
            }
          });
          Object.defineProperty(exports2, "structuredPatch", {
            enumerable: true,
            get: function get2() {
              return _create2.structuredPatch;
            }
          });
          Object.defineProperty(exports2, "createTwoFilesPatch", {
            enumerable: true,
            get: function get2() {
              return _create2.createTwoFilesPatch;
            }
          });
          Object.defineProperty(exports2, "createPatch", {
            enumerable: true,
            get: function get2() {
              return _create2.createPatch;
            }
          });
          Object.defineProperty(exports2, "formatPatch", {
            enumerable: true,
            get: function get2() {
              return _create2.formatPatch;
            }
          });
          Object.defineProperty(exports2, "convertChangesToDMP", {
            enumerable: true,
            get: function get2() {
              return _dmp.convertChangesToDMP;
            }
          });
          Object.defineProperty(exports2, "convertChangesToXML", {
            enumerable: true,
            get: function get2() {
              return _xml.convertChangesToXML;
            }
          });
          var _base2 = _interopRequireDefault2(base);
          var _character = character;
          var _word = word;
          var _line2 = line;
          var _sentence = sentence;
          var _css = css;
          var _json = json$1;
          var _array2 = array$1;
          var _apply = apply2;
          var _parse2 = parse$2;
          var _merge = merge$1;
          var _reverse = reverse;
          var _create2 = create2;
          var _dmp = dmp;
          var _xml = xml;
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
        })(lib);
        var s$1 = 1e3;
        var m$1 = s$1 * 60;
        var h$1 = m$1 * 60;
        var d$1 = h$1 * 24;
        var w$1 = d$1 * 7;
        var y$1 = d$1 * 365.25;
        var ms$1 = function(val, options) {
          options = options || {};
          var type3 = typeof val;
          if (type3 === "string" && val.length > 0) {
            return parse$1(val);
          } else if (type3 === "number" && isFinite(val)) {
            return options.long ? fmtLong$1(val) : fmtShort$1(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
          );
        };
        function parse$1(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str
          );
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type3 = (match[2] || "ms").toLowerCase();
          switch (type3) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y$1;
            case "weeks":
            case "week":
            case "w":
              return n * w$1;
            case "days":
            case "day":
            case "d":
              return n * d$1;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h$1;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m$1;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s$1;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return void 0;
          }
        }
        function fmtShort$1(ms2) {
          var msAbs = Math.abs(ms2);
          if (msAbs >= d$1) {
            return Math.round(ms2 / d$1) + "d";
          }
          if (msAbs >= h$1) {
            return Math.round(ms2 / h$1) + "h";
          }
          if (msAbs >= m$1) {
            return Math.round(ms2 / m$1) + "m";
          }
          if (msAbs >= s$1) {
            return Math.round(ms2 / s$1) + "s";
          }
          return ms2 + "ms";
        }
        function fmtLong$1(ms2) {
          var msAbs = Math.abs(ms2);
          if (msAbs >= d$1) {
            return plural$1(ms2, msAbs, d$1, "day");
          }
          if (msAbs >= h$1) {
            return plural$1(ms2, msAbs, h$1, "hour");
          }
          if (msAbs >= m$1) {
            return plural$1(ms2, msAbs, m$1, "minute");
          }
          if (msAbs >= s$1) {
            return plural$1(ms2, msAbs, s$1, "second");
          }
          return ms2 + " ms";
        }
        function plural$1(ms2, msAbs, n, name2) {
          var isPlural = msAbs >= n * 1.5;
          return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
        }
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var inited = false;
        function init() {
          inited = true;
          var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i];
            revLookup[code.charCodeAt(i)] = i;
          }
          revLookup["-".charCodeAt(0)] = 62;
          revLookup["_".charCodeAt(0)] = 63;
        }
        function toByteArray(b64) {
          if (!inited) {
            init();
          }
          var i, j, l, tmp, placeHolders, arr;
          var len = b64.length;
          if (len % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }
          placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
          arr = new Arr(len * 3 / 4 - placeHolders);
          l = placeHolders > 0 ? len - 4 : len;
          var L = 0;
          for (i = 0, j = 0; i < l; i += 4, j += 3) {
            tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
            arr[L++] = tmp >> 16 & 255;
            arr[L++] = tmp >> 8 & 255;
            arr[L++] = tmp & 255;
          }
          if (placeHolders === 2) {
            tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
            arr[L++] = tmp & 255;
          } else if (placeHolders === 1) {
            tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
            arr[L++] = tmp >> 8 & 255;
            arr[L++] = tmp & 255;
          }
          return arr;
        }
        function tripletToBase64(num) {
          return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i = start; i < end; i += 3) {
            tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }
        function fromByteArray(uint8) {
          if (!inited) {
            init();
          }
          var tmp;
          var len = uint8.length;
          var extraBytes = len % 3;
          var output = "";
          var parts = [];
          var maxChunkLength = 16383;
          for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
            parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
          }
          if (extraBytes === 1) {
            tmp = uint8[len - 1];
            output += lookup[tmp >> 2];
            output += lookup[tmp << 4 & 63];
            output += "==";
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
            output += lookup[tmp >> 10];
            output += lookup[tmp >> 4 & 63];
            output += lookup[tmp << 2 & 63];
            output += "=";
          }
          parts.push(output);
          return parts.join("");
        }
        function read(buffer, offset, isLE, mLen, nBytes) {
          var e, m2;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d2 = isLE ? -1 : 1;
          var s2 = buffer[offset + i];
          i += d2;
          e = s2 & (1 << -nBits) - 1;
          s2 >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d2, nBits -= 8) {
          }
          m2 = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i], i += d2, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
          } else {
            m2 = m2 + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
        }
        function write(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m2, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d2 = isLE ? 1 : -1;
          var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m2 = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m2 = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m2 = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
          }
          e = e << mLen | m2;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d2, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d2] |= s2 * 128;
        }
        var toString$1 = {}.toString;
        var isArray = Array.isArray || function(arr) {
          return toString$1.call(arr) == "[object Array]";
        };
        var INSPECT_MAX_BYTES = 50;
        Buffer2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
        kMaxLength();
        function kMaxLength() {
          return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
        }
        function createBuffer(that, length) {
          if (kMaxLength() < length) {
            throw new RangeError("Invalid typed array length");
          }
          if (Buffer2.TYPED_ARRAY_SUPPORT) {
            that = new Uint8Array(length);
            that.__proto__ = Buffer2.prototype;
          } else {
            if (that === null) {
              that = new Buffer2(length);
            }
            that.length = length;
          }
          return that;
        }
        function Buffer2(arg, encodingOrOffset, length) {
          if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
            return new Buffer2(arg, encodingOrOffset, length);
          }
          if (typeof arg === "number") {
            if (typeof encodingOrOffset === "string") {
              throw new Error(
                "If encoding is specified then the first argument must be a string"
              );
            }
            return allocUnsafe(this, arg);
          }
          return from(this, arg, encodingOrOffset, length);
        }
        Buffer2.poolSize = 8192;
        Buffer2._augment = function(arr) {
          arr.__proto__ = Buffer2.prototype;
          return arr;
        };
        function from(that, value, encodingOrOffset, length) {
          if (typeof value === "number") {
            throw new TypeError('"value" argument must not be a number');
          }
          if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
            return fromArrayBuffer(that, value, encodingOrOffset, length);
          }
          if (typeof value === "string") {
            return fromString(that, value, encodingOrOffset);
          }
          return fromObject(that, value);
        }
        Buffer2.from = function(value, encodingOrOffset, length) {
          return from(null, value, encodingOrOffset, length);
        };
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          Buffer2.prototype.__proto__ = Uint8Array.prototype;
          Buffer2.__proto__ = Uint8Array;
          if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) ;
        }
        function assertSize(size) {
          if (typeof size !== "number") {
            throw new TypeError('"size" argument must be a number');
          } else if (size < 0) {
            throw new RangeError('"size" argument must not be negative');
          }
        }
        function alloc(that, size, fill, encoding) {
          assertSize(size);
          if (size <= 0) {
            return createBuffer(that, size);
          }
          if (fill !== void 0) {
            return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
          }
          return createBuffer(that, size);
        }
        Buffer2.alloc = function(size, fill, encoding) {
          return alloc(null, size, fill, encoding);
        };
        function allocUnsafe(that, size) {
          assertSize(size);
          that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
          if (!Buffer2.TYPED_ARRAY_SUPPORT) {
            for (var i = 0; i < size; ++i) {
              that[i] = 0;
            }
          }
          return that;
        }
        Buffer2.allocUnsafe = function(size) {
          return allocUnsafe(null, size);
        };
        Buffer2.allocUnsafeSlow = function(size) {
          return allocUnsafe(null, size);
        };
        function fromString(that, string, encoding) {
          if (typeof encoding !== "string" || encoding === "") {
            encoding = "utf8";
          }
          if (!Buffer2.isEncoding(encoding)) {
            throw new TypeError('"encoding" must be a valid string encoding');
          }
          var length = byteLength(string, encoding) | 0;
          that = createBuffer(that, length);
          var actual = that.write(string, encoding);
          if (actual !== length) {
            that = that.slice(0, actual);
          }
          return that;
        }
        function fromArrayLike(that, array2) {
          var length = array2.length < 0 ? 0 : checked(array2.length) | 0;
          that = createBuffer(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array2[i] & 255;
          }
          return that;
        }
        function fromArrayBuffer(that, array2, byteOffset, length) {
          array2.byteLength;
          if (byteOffset < 0 || array2.byteLength < byteOffset) {
            throw new RangeError("'offset' is out of bounds");
          }
          if (array2.byteLength < byteOffset + (length || 0)) {
            throw new RangeError("'length' is out of bounds");
          }
          if (byteOffset === void 0 && length === void 0) {
            array2 = new Uint8Array(array2);
          } else if (length === void 0) {
            array2 = new Uint8Array(array2, byteOffset);
          } else {
            array2 = new Uint8Array(array2, byteOffset, length);
          }
          if (Buffer2.TYPED_ARRAY_SUPPORT) {
            that = array2;
            that.__proto__ = Buffer2.prototype;
          } else {
            that = fromArrayLike(that, array2);
          }
          return that;
        }
        function fromObject(that, obj) {
          if (internalIsBuffer(obj)) {
            var len = checked(obj.length) | 0;
            that = createBuffer(that, len);
            if (that.length === 0) {
              return that;
            }
            obj.copy(that, 0, 0, len);
            return that;
          }
          if (obj) {
            if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
              if (typeof obj.length !== "number" || isnan(obj.length)) {
                return createBuffer(that, 0);
              }
              return fromArrayLike(that, obj);
            }
            if (obj.type === "Buffer" && isArray(obj.data)) {
              return fromArrayLike(that, obj.data);
            }
          }
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }
        function checked(length) {
          if (length >= kMaxLength()) {
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
          }
          return length | 0;
        }
        Buffer2.isBuffer = isBuffer;
        function internalIsBuffer(b) {
          return !!(b != null && b._isBuffer);
        }
        Buffer2.compare = function compare(a, b) {
          if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
            throw new TypeError("Arguments must be Buffers");
          }
          if (a === b) return 0;
          var x = a.length;
          var y2 = b.length;
          for (var i = 0, len = Math.min(x, y2); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i];
              y2 = b[i];
              break;
            }
          }
          if (x < y2) return -1;
          if (y2 < x) return 1;
          return 0;
        };
        Buffer2.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        };
        Buffer2.concat = function concat(list2, length) {
          if (!isArray(list2)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          if (list2.length === 0) {
            return Buffer2.alloc(0);
          }
          var i;
          if (length === void 0) {
            length = 0;
            for (i = 0; i < list2.length; ++i) {
              length += list2[i].length;
            }
          }
          var buffer = Buffer2.allocUnsafe(length);
          var pos = 0;
          for (i = 0; i < list2.length; ++i) {
            var buf = list2[i];
            if (!internalIsBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            buf.copy(buffer, pos);
            pos += buf.length;
          }
          return buffer;
        };
        function byteLength(string, encoding) {
          if (internalIsBuffer(string)) {
            return string.length;
          }
          if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
            return string.byteLength;
          }
          if (typeof string !== "string") {
            string = "" + string;
          }
          var len = string.length;
          if (len === 0) return 0;
          var loweredCase = false;
          for (; ; ) {
            switch (encoding) {
              case "ascii":
              case "latin1":
              case "binary":
                return len;
              case "utf8":
              case "utf-8":
              case void 0:
                return utf8ToBytes(string).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return len * 2;
              case "hex":
                return len >>> 1;
              case "base64":
                return base64ToBytes(string).length;
              default:
                if (loweredCase) return utf8ToBytes(string).length;
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer2.byteLength = byteLength;
        function slowToString(encoding, start, end) {
          var loweredCase = false;
          if (start === void 0 || start < 0) {
            start = 0;
          }
          if (start > this.length) {
            return "";
          }
          if (end === void 0 || end > this.length) {
            end = this.length;
          }
          if (end <= 0) {
            return "";
          }
          end >>>= 0;
          start >>>= 0;
          if (end <= start) {
            return "";
          }
          if (!encoding) encoding = "utf8";
          while (true) {
            switch (encoding) {
              case "hex":
                return hexSlice(this, start, end);
              case "utf8":
              case "utf-8":
                return utf8Slice(this, start, end);
              case "ascii":
                return asciiSlice(this, start, end);
              case "latin1":
              case "binary":
                return latin1Slice(this, start, end);
              case "base64":
                return base64Slice(this, start, end);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice(this, start, end);
              default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = (encoding + "").toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer2.prototype._isBuffer = true;
        function swap(b, n, m2) {
          var i = b[n];
          b[n] = b[m2];
          b[m2] = i;
        }
        Buffer2.prototype.swap16 = function swap16() {
          var len = this.length;
          if (len % 2 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          }
          for (var i = 0; i < len; i += 2) {
            swap(this, i, i + 1);
          }
          return this;
        };
        Buffer2.prototype.swap32 = function swap32() {
          var len = this.length;
          if (len % 4 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          }
          for (var i = 0; i < len; i += 4) {
            swap(this, i, i + 3);
            swap(this, i + 1, i + 2);
          }
          return this;
        };
        Buffer2.prototype.swap64 = function swap64() {
          var len = this.length;
          if (len % 8 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          }
          for (var i = 0; i < len; i += 8) {
            swap(this, i, i + 7);
            swap(this, i + 1, i + 6);
            swap(this, i + 2, i + 5);
            swap(this, i + 3, i + 4);
          }
          return this;
        };
        Buffer2.prototype.toString = function toString3() {
          var length = this.length | 0;
          if (length === 0) return "";
          if (arguments.length === 0) return utf8Slice(this, 0, length);
          return slowToString.apply(this, arguments);
        };
        Buffer2.prototype.equals = function equals(b) {
          if (!internalIsBuffer(b)) throw new TypeError("Argument must be a Buffer");
          if (this === b) return true;
          return Buffer2.compare(this, b) === 0;
        };
        Buffer2.prototype.inspect = function inspect4() {
          var str = "";
          var max = INSPECT_MAX_BYTES;
          if (this.length > 0) {
            str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
            if (this.length > max) str += " ... ";
          }
          return "<Buffer " + str + ">";
        };
        Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
          if (!internalIsBuffer(target)) {
            throw new TypeError("Argument must be a Buffer");
          }
          if (start === void 0) {
            start = 0;
          }
          if (end === void 0) {
            end = target ? target.length : 0;
          }
          if (thisStart === void 0) {
            thisStart = 0;
          }
          if (thisEnd === void 0) {
            thisEnd = this.length;
          }
          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
            throw new RangeError("out of range index");
          }
          if (thisStart >= thisEnd && start >= end) {
            return 0;
          }
          if (thisStart >= thisEnd) {
            return -1;
          }
          if (start >= end) {
            return 1;
          }
          start >>>= 0;
          end >>>= 0;
          thisStart >>>= 0;
          thisEnd >>>= 0;
          if (this === target) return 0;
          var x = thisEnd - thisStart;
          var y2 = end - start;
          var len = Math.min(x, y2);
          var thisCopy = this.slice(thisStart, thisEnd);
          var targetCopy = target.slice(start, end);
          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i];
              y2 = targetCopy[i];
              break;
            }
          }
          if (x < y2) return -1;
          if (y2 < x) return 1;
          return 0;
        };
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          if (buffer.length === 0) return -1;
          if (typeof byteOffset === "string") {
            encoding = byteOffset;
            byteOffset = 0;
          } else if (byteOffset > 2147483647) {
            byteOffset = 2147483647;
          } else if (byteOffset < -2147483648) {
            byteOffset = -2147483648;
          }
          byteOffset = +byteOffset;
          if (isNaN(byteOffset)) {
            byteOffset = dir ? 0 : buffer.length - 1;
          }
          if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
          if (byteOffset >= buffer.length) {
            if (dir) return -1;
            else byteOffset = buffer.length - 1;
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0;
            else return -1;
          }
          if (typeof val === "string") {
            val = Buffer2.from(val, encoding);
          }
          if (internalIsBuffer(val)) {
            if (val.length === 0) {
              return -1;
            }
            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
          } else if (typeof val === "number") {
            val = val & 255;
            if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
              } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
              }
            }
            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
          }
          throw new TypeError("val must be string, number or Buffer");
        }
        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1;
          var arrLength = arr.length;
          var valLength = val.length;
          if (encoding !== void 0) {
            encoding = String(encoding).toLowerCase();
            if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
              if (arr.length < 2 || val.length < 2) {
                return -1;
              }
              indexSize = 2;
              arrLength /= 2;
              valLength /= 2;
              byteOffset /= 2;
            }
          }
          function read2(buf, i2) {
            if (indexSize === 1) {
              return buf[i2];
            } else {
              return buf.readUInt16BE(i2 * indexSize);
            }
          }
          var i;
          if (dir) {
            var foundIndex = -1;
            for (i = byteOffset; i < arrLength; i++) {
              if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
              } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
              }
            }
          } else {
            if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
            for (i = byteOffset; i >= 0; i--) {
              var found = true;
              for (var j = 0; j < valLength; j++) {
                if (read2(arr, i + j) !== read2(val, j)) {
                  found = false;
                  break;
                }
              }
              if (found) return i;
            }
          }
          return -1;
        }
        Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
          return this.indexOf(val, byteOffset, encoding) !== -1;
        };
        Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };
        Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };
        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining;
            }
          }
          var strLen = string.length;
          if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
          if (length > strLen / 2) {
            length = strLen / 2;
          }
          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16);
            if (isNaN(parsed)) return i;
            buf[offset + i] = parsed;
          }
          return i;
        }
        function utf8Write(buf, string, offset, length) {
          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }
        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length);
        }
        function latin1Write(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length);
        }
        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length);
        }
        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
        }
        Buffer2.prototype.write = function write2(string, offset, length, encoding) {
          if (offset === void 0) {
            encoding = "utf8";
            length = this.length;
            offset = 0;
          } else if (length === void 0 && typeof offset === "string") {
            encoding = offset;
            length = this.length;
            offset = 0;
          } else if (isFinite(offset)) {
            offset = offset | 0;
            if (isFinite(length)) {
              length = length | 0;
              if (encoding === void 0) encoding = "utf8";
            } else {
              encoding = length;
              length = void 0;
            }
          } else {
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          }
          var remaining = this.length - offset;
          if (length === void 0 || length > remaining) length = remaining;
          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
            throw new RangeError("Attempt to write outside buffer bounds");
          }
          if (!encoding) encoding = "utf8";
          var loweredCase = false;
          for (; ; ) {
            switch (encoding) {
              case "hex":
                return hexWrite(this, string, offset, length);
              case "utf8":
              case "utf-8":
                return utf8Write(this, string, offset, length);
              case "ascii":
                return asciiWrite(this, string, offset, length);
              case "latin1":
              case "binary":
                return latin1Write(this, string, offset, length);
              case "base64":
                return base64Write(this, string, offset, length);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length);
              default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        };
        Buffer2.prototype.toJSON = function toJSON() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        };
        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return fromByteArray(buf);
          } else {
            return fromByteArray(buf.slice(start, end));
          }
        }
        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end);
          var res = [];
          var i = start;
          while (i < end) {
            var firstByte = buf[i];
            var codePoint = null;
            var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint;
              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 128) {
                    codePoint = firstByte;
                  }
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 192) === 128) {
                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                    if (tempCodePoint > 127) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                      codePoint = tempCodePoint;
                    }
                  }
              }
            }
            if (codePoint === null) {
              codePoint = 65533;
              bytesPerSequence = 1;
            } else if (codePoint > 65535) {
              codePoint -= 65536;
              res.push(codePoint >>> 10 & 1023 | 55296);
              codePoint = 56320 | codePoint & 1023;
            }
            res.push(codePoint);
            i += bytesPerSequence;
          }
          return decodeCodePointsArray(res);
        }
        var MAX_ARGUMENTS_LENGTH = 4096;
        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length;
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints);
          }
          var res = "";
          var i = 0;
          while (i < len) {
            res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
            );
          }
          return res;
        }
        function asciiSlice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 127);
          }
          return ret;
        }
        function latin1Slice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i]);
          }
          return ret;
        }
        function hexSlice(buf, start, end) {
          var len = buf.length;
          if (!start || start < 0) start = 0;
          if (!end || end < 0 || end > len) end = len;
          var out = "";
          for (var i = start; i < end; ++i) {
            out += toHex(buf[i]);
          }
          return out;
        }
        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = "";
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
          }
          return res;
        }
        Buffer2.prototype.slice = function slice(start, end) {
          var len = this.length;
          start = ~~start;
          end = end === void 0 ? len : ~~end;
          if (start < 0) {
            start += len;
            if (start < 0) start = 0;
          } else if (start > len) {
            start = len;
          }
          if (end < 0) {
            end += len;
            if (end < 0) end = 0;
          } else if (end > len) {
            end = len;
          }
          if (end < start) end = start;
          var newBuf;
          if (Buffer2.TYPED_ARRAY_SUPPORT) {
            newBuf = this.subarray(start, end);
            newBuf.__proto__ = Buffer2.prototype;
          } else {
            var sliceLen = end - start;
            newBuf = new Buffer2(sliceLen, void 0);
            for (var i = 0; i < sliceLen; ++i) {
              newBuf[i] = this[i + start];
            }
          }
          return newBuf;
        };
        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
          if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
        }
        Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) checkOffset(offset, byteLength2, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength2 && (mul *= 256)) {
            val += this[offset + i] * mul;
          }
          return val;
        };
        Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) {
            checkOffset(offset, byteLength2, this.length);
          }
          var val = this[offset + --byteLength2];
          var mul = 1;
          while (byteLength2 > 0 && (mul *= 256)) {
            val += this[offset + --byteLength2] * mul;
          }
          return val;
        };
        Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          return this[offset];
        };
        Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] | this[offset + 1] << 8;
        };
        Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] << 8 | this[offset + 1];
        };
        Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
        };
        Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };
        Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) checkOffset(offset, byteLength2, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength2 && (mul *= 256)) {
            val += this[offset + i] * mul;
          }
          mul *= 128;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
          return val;
        };
        Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) checkOffset(offset, byteLength2, this.length);
          var i = byteLength2;
          var mul = 1;
          var val = this[offset + --i];
          while (i > 0 && (mul *= 256)) {
            val += this[offset + --i] * mul;
          }
          mul *= 128;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
          return val;
        };
        Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          if (!(this[offset] & 128)) return this[offset];
          return (255 - this[offset] + 1) * -1;
        };
        Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset] | this[offset + 1] << 8;
          return val & 32768 ? val | 4294901760 : val;
        };
        Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset + 1] | this[offset] << 8;
          return val & 32768 ? val | 4294901760 : val;
        };
        Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };
        Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };
        Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return read(this, offset, true, 23, 4);
        };
        Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return read(this, offset, false, 23, 4);
        };
        Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return read(this, offset, true, 52, 8);
        };
        Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return read(this, offset, false, 52, 8);
        };
        function checkInt(buf, value, offset, ext, max, min2) {
          if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (value > max || value < min2) throw new RangeError('"value" argument is out of bounds');
          if (offset + ext > buf.length) throw new RangeError("Index out of range");
        }
        Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
            checkInt(this, value, offset, byteLength2, maxBytes, 0);
          }
          var mul = 1;
          var i = 0;
          this[offset] = value & 255;
          while (++i < byteLength2 && (mul *= 256)) {
            this[offset + i] = value / mul & 255;
          }
          return offset + byteLength2;
        };
        Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength2 = byteLength2 | 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
            checkInt(this, value, offset, byteLength2, maxBytes, 0);
          }
          var i = byteLength2 - 1;
          var mul = 1;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            this[offset + i] = value / mul & 255;
          }
          return offset + byteLength2;
        };
        Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
          if (!Buffer2.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          this[offset] = value & 255;
          return offset + 1;
        };
        function objectWriteUInt16(buf, value, offset, littleEndian) {
          if (value < 0) value = 65535 + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
            buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
          }
        }
        Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
          if (Buffer2.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }
          return offset + 2;
        };
        Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
          if (Buffer2.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }
          return offset + 2;
        };
        function objectWriteUInt32(buf, value, offset, littleEndian) {
          if (value < 0) value = 4294967295 + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
            buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
          }
        }
        Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
          if (Buffer2.TYPED_ARRAY_SUPPORT) {
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 255;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }
          return offset + 4;
        };
        Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
          if (Buffer2.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }
          return offset + 4;
        };
        Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength2 - 1);
            checkInt(this, value, offset, byteLength2, limit - 1, -limit);
          }
          var i = 0;
          var mul = 1;
          var sub = 0;
          this[offset] = value & 255;
          while (++i < byteLength2 && (mul *= 256)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (value / mul >> 0) - sub & 255;
          }
          return offset + byteLength2;
        };
        Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength2 - 1);
            checkInt(this, value, offset, byteLength2, limit - 1, -limit);
          }
          var i = byteLength2 - 1;
          var mul = 1;
          var sub = 0;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (value / mul >> 0) - sub & 255;
          }
          return offset + byteLength2;
        };
        Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
          if (!Buffer2.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          if (value < 0) value = 255 + value + 1;
          this[offset] = value & 255;
          return offset + 1;
        };
        Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
          if (Buffer2.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }
          return offset + 2;
        };
        Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
          if (Buffer2.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }
          return offset + 2;
        };
        Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
          if (Buffer2.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }
          return offset + 4;
        };
        Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
          if (value < 0) value = 4294967295 + value + 1;
          if (Buffer2.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }
          return offset + 4;
        };
        function checkIEEE754(buf, value, offset, ext, max, min2) {
          if (offset + ext > buf.length) throw new RangeError("Index out of range");
          if (offset < 0) throw new RangeError("Index out of range");
        }
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 4);
          }
          write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4;
        }
        Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 8);
          }
          write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8;
        }
        Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert);
        };
        Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
          if (!start) start = 0;
          if (!end && end !== 0) end = this.length;
          if (targetStart >= target.length) targetStart = target.length;
          if (!targetStart) targetStart = 0;
          if (end > 0 && end < start) end = start;
          if (end === start) return 0;
          if (target.length === 0 || this.length === 0) return 0;
          if (targetStart < 0) {
            throw new RangeError("targetStart out of bounds");
          }
          if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
          if (end < 0) throw new RangeError("sourceEnd out of bounds");
          if (end > this.length) end = this.length;
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start;
          }
          var len = end - start;
          var i;
          if (this === target && start < targetStart && targetStart < end) {
            for (i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start];
            }
          } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
            for (i = 0; i < len; ++i) {
              target[i + targetStart] = this[i + start];
            }
          } else {
            Uint8Array.prototype.set.call(
              target,
              this.subarray(start, start + len),
              targetStart
            );
          }
          return len;
        };
        Buffer2.prototype.fill = function fill(val, start, end, encoding) {
          if (typeof val === "string") {
            if (typeof start === "string") {
              encoding = start;
              start = 0;
              end = this.length;
            } else if (typeof end === "string") {
              encoding = end;
              end = this.length;
            }
            if (val.length === 1) {
              var code = val.charCodeAt(0);
              if (code < 256) {
                val = code;
              }
            }
            if (encoding !== void 0 && typeof encoding !== "string") {
              throw new TypeError("encoding must be a string");
            }
            if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding);
            }
          } else if (typeof val === "number") {
            val = val & 255;
          }
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError("Out of range index");
          }
          if (end <= start) {
            return this;
          }
          start = start >>> 0;
          end = end === void 0 ? this.length : end >>> 0;
          if (!val) val = 0;
          var i;
          if (typeof val === "number") {
            for (i = start; i < end; ++i) {
              this[i] = val;
            }
          } else {
            var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
            var len = bytes.length;
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len];
            }
          }
          return this;
        };
        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
        function base64clean(str) {
          str = stringtrim(str).replace(INVALID_BASE64_RE, "");
          if (str.length < 2) return "";
          while (str.length % 4 !== 0) {
            str = str + "=";
          }
          return str;
        }
        function stringtrim(str) {
          if (str.trim) return str.trim();
          return str.replace(/^\s+|\s+$/g, "");
        }
        function toHex(n) {
          if (n < 16) return "0" + n.toString(16);
          return n.toString(16);
        }
        function utf8ToBytes(string, units) {
          units = units || Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;
          var bytes = [];
          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i);
            if (codePoint > 55295 && codePoint < 57344) {
              if (!leadSurrogate) {
                if (codePoint > 56319) {
                  if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  continue;
                } else if (i + 1 === length) {
                  if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  continue;
                }
                leadSurrogate = codePoint;
                continue;
              }
              if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
              }
              codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
            } else if (leadSurrogate) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
            }
            leadSurrogate = null;
            if (codePoint < 128) {
              if ((units -= 1) < 0) break;
              bytes.push(codePoint);
            } else if (codePoint < 2048) {
              if ((units -= 2) < 0) break;
              bytes.push(
                codePoint >> 6 | 192,
                codePoint & 63 | 128
              );
            } else if (codePoint < 65536) {
              if ((units -= 3) < 0) break;
              bytes.push(
                codePoint >> 12 | 224,
                codePoint >> 6 & 63 | 128,
                codePoint & 63 | 128
              );
            } else if (codePoint < 1114112) {
              if ((units -= 4) < 0) break;
              bytes.push(
                codePoint >> 18 | 240,
                codePoint >> 12 & 63 | 128,
                codePoint >> 6 & 63 | 128,
                codePoint & 63 | 128
              );
            } else {
              throw new Error("Invalid code point");
            }
          }
          return bytes;
        }
        function asciiToBytes(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            byteArray.push(str.charCodeAt(i) & 255);
          }
          return byteArray;
        }
        function utf16leToBytes(str, units) {
          var c, hi, lo;
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break;
            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }
          return byteArray;
        }
        function base64ToBytes(str) {
          return toByteArray(base64clean(str));
        }
        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length) break;
            dst[i + offset] = src[i];
          }
          return i;
        }
        function isnan(val) {
          return val !== val;
        }
        function isBuffer(obj) {
          return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
        }
        function isFastBuffer(obj) {
          return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
        }
        function isSlowBuffer(obj) {
          return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
        }
        var browser$2 = true;
        var utils$3 = {};
        var he = { exports: {} };
        (function(module3, exports2) {
          (function(root) {
            var freeExports = exports2;
            var freeModule = module3 && module3.exports == freeExports && module3;
            var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
              root = freeGlobal;
            }
            var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
            var regexAsciiWhitelist = /[\x01-\x7F]/g;
            var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
            var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
            var encodeMap = { "\xAD": "shy", "\u200C": "zwnj", "\u200D": "zwj", "\u200E": "lrm", "\u2063": "ic", "\u2062": "it", "\u2061": "af", "\u200F": "rlm", "\u200B": "ZeroWidthSpace", "\u2060": "NoBreak", "\u0311": "DownBreve", "\u20DB": "tdot", "\u20DC": "DotDot", "	": "Tab", "\n": "NewLine", "\u2008": "puncsp", "\u205F": "MediumSpace", "\u2009": "thinsp", "\u200A": "hairsp", "\u2004": "emsp13", "\u2002": "ensp", "\u2005": "emsp14", "\u2003": "emsp", "\u2007": "numsp", "\xA0": "nbsp", "\u205F\u200A": "ThickSpace", "\u203E": "oline", "_": "lowbar", "\u2010": "dash", "\u2013": "ndash", "\u2014": "mdash", "\u2015": "horbar", ",": "comma", ";": "semi", "\u204F": "bsemi", ":": "colon", "\u2A74": "Colone", "!": "excl", "\xA1": "iexcl", "?": "quest", "\xBF": "iquest", ".": "period", "\u2025": "nldr", "\u2026": "mldr", "\xB7": "middot", "'": "apos", "\u2018": "lsquo", "\u2019": "rsquo", "\u201A": "sbquo", "\u2039": "lsaquo", "\u203A": "rsaquo", '"': "quot", "\u201C": "ldquo", "\u201D": "rdquo", "\u201E": "bdquo", "\xAB": "laquo", "\xBB": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "\u2308": "lceil", "\u2309": "rceil", "\u230A": "lfloor", "\u230B": "rfloor", "\u2985": "lopar", "\u2986": "ropar", "\u298B": "lbrke", "\u298C": "rbrke", "\u298D": "lbrkslu", "\u298E": "rbrksld", "\u298F": "lbrksld", "\u2990": "rbrkslu", "\u2991": "langd", "\u2992": "rangd", "\u2993": "lparlt", "\u2994": "rpargt", "\u2995": "gtlPar", "\u2996": "ltrPar", "\u27E6": "lobrk", "\u27E7": "robrk", "\u27E8": "lang", "\u27E9": "rang", "\u27EA": "Lang", "\u27EB": "Rang", "\u27EC": "loang", "\u27ED": "roang", "\u2772": "lbbrk", "\u2773": "rbbrk", "\u2016": "Vert", "\xA7": "sect", "\xB6": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "\u2030": "permil", "\u2031": "pertenk", "\u2020": "dagger", "\u2021": "Dagger", "\u2022": "bull", "\u2043": "hybull", "\u2032": "prime", "\u2033": "Prime", "\u2034": "tprime", "\u2057": "qprime", "\u2035": "bprime", "\u2041": "caret", "`": "grave", "\xB4": "acute", "\u02DC": "tilde", "^": "Hat", "\xAF": "macr", "\u02D8": "breve", "\u02D9": "dot", "\xA8": "die", "\u02DA": "ring", "\u02DD": "dblac", "\xB8": "cedil", "\u02DB": "ogon", "\u02C6": "circ", "\u02C7": "caron", "\xB0": "deg", "\xA9": "copy", "\xAE": "reg", "\u2117": "copysr", "\u2118": "wp", "\u211E": "rx", "\u2127": "mho", "\u2129": "iiota", "\u2190": "larr", "\u219A": "nlarr", "\u2192": "rarr", "\u219B": "nrarr", "\u2191": "uarr", "\u2193": "darr", "\u2194": "harr", "\u21AE": "nharr", "\u2195": "varr", "\u2196": "nwarr", "\u2197": "nearr", "\u2198": "searr", "\u2199": "swarr", "\u219D": "rarrw", "\u219D\u0338": "nrarrw", "\u219E": "Larr", "\u219F": "Uarr", "\u21A0": "Rarr", "\u21A1": "Darr", "\u21A2": "larrtl", "\u21A3": "rarrtl", "\u21A4": "mapstoleft", "\u21A5": "mapstoup", "\u21A6": "map", "\u21A7": "mapstodown", "\u21A9": "larrhk", "\u21AA": "rarrhk", "\u21AB": "larrlp", "\u21AC": "rarrlp", "\u21AD": "harrw", "\u21B0": "lsh", "\u21B1": "rsh", "\u21B2": "ldsh", "\u21B3": "rdsh", "\u21B5": "crarr", "\u21B6": "cularr", "\u21B7": "curarr", "\u21BA": "olarr", "\u21BB": "orarr", "\u21BC": "lharu", "\u21BD": "lhard", "\u21BE": "uharr", "\u21BF": "uharl", "\u21C0": "rharu", "\u21C1": "rhard", "\u21C2": "dharr", "\u21C3": "dharl", "\u21C4": "rlarr", "\u21C5": "udarr", "\u21C6": "lrarr", "\u21C7": "llarr", "\u21C8": "uuarr", "\u21C9": "rrarr", "\u21CA": "ddarr", "\u21CB": "lrhar", "\u21CC": "rlhar", "\u21D0": "lArr", "\u21CD": "nlArr", "\u21D1": "uArr", "\u21D2": "rArr", "\u21CF": "nrArr", "\u21D3": "dArr", "\u21D4": "iff", "\u21CE": "nhArr", "\u21D5": "vArr", "\u21D6": "nwArr", "\u21D7": "neArr", "\u21D8": "seArr", "\u21D9": "swArr", "\u21DA": "lAarr", "\u21DB": "rAarr", "\u21DD": "zigrarr", "\u21E4": "larrb", "\u21E5": "rarrb", "\u21F5": "duarr", "\u21FD": "loarr", "\u21FE": "roarr", "\u21FF": "hoarr", "\u2200": "forall", "\u2201": "comp", "\u2202": "part", "\u2202\u0338": "npart", "\u2203": "exist", "\u2204": "nexist", "\u2205": "empty", "\u2207": "Del", "\u2208": "in", "\u2209": "notin", "\u220B": "ni", "\u220C": "notni", "\u03F6": "bepsi", "\u220F": "prod", "\u2210": "coprod", "\u2211": "sum", "+": "plus", "\xB1": "pm", "\xF7": "div", "\xD7": "times", "<": "lt", "\u226E": "nlt", "<\u20D2": "nvlt", "=": "equals", "\u2260": "ne", "=\u20E5": "bne", "\u2A75": "Equal", ">": "gt", "\u226F": "ngt", ">\u20D2": "nvgt", "\xAC": "not", "|": "vert", "\xA6": "brvbar", "\u2212": "minus", "\u2213": "mp", "\u2214": "plusdo", "\u2044": "frasl", "\u2216": "setmn", "\u2217": "lowast", "\u2218": "compfn", "\u221A": "Sqrt", "\u221D": "prop", "\u221E": "infin", "\u221F": "angrt", "\u2220": "ang", "\u2220\u20D2": "nang", "\u2221": "angmsd", "\u2222": "angsph", "\u2223": "mid", "\u2224": "nmid", "\u2225": "par", "\u2226": "npar", "\u2227": "and", "\u2228": "or", "\u2229": "cap", "\u2229\uFE00": "caps", "\u222A": "cup", "\u222A\uFE00": "cups", "\u222B": "int", "\u222C": "Int", "\u222D": "tint", "\u2A0C": "qint", "\u222E": "oint", "\u222F": "Conint", "\u2230": "Cconint", "\u2231": "cwint", "\u2232": "cwconint", "\u2233": "awconint", "\u2234": "there4", "\u2235": "becaus", "\u2236": "ratio", "\u2237": "Colon", "\u2238": "minusd", "\u223A": "mDDot", "\u223B": "homtht", "\u223C": "sim", "\u2241": "nsim", "\u223C\u20D2": "nvsim", "\u223D": "bsim", "\u223D\u0331": "race", "\u223E": "ac", "\u223E\u0333": "acE", "\u223F": "acd", "\u2240": "wr", "\u2242": "esim", "\u2242\u0338": "nesim", "\u2243": "sime", "\u2244": "nsime", "\u2245": "cong", "\u2247": "ncong", "\u2246": "simne", "\u2248": "ap", "\u2249": "nap", "\u224A": "ape", "\u224B": "apid", "\u224B\u0338": "napid", "\u224C": "bcong", "\u224D": "CupCap", "\u226D": "NotCupCap", "\u224D\u20D2": "nvap", "\u224E": "bump", "\u224E\u0338": "nbump", "\u224F": "bumpe", "\u224F\u0338": "nbumpe", "\u2250": "doteq", "\u2250\u0338": "nedot", "\u2251": "eDot", "\u2252": "efDot", "\u2253": "erDot", "\u2254": "colone", "\u2255": "ecolon", "\u2256": "ecir", "\u2257": "cire", "\u2259": "wedgeq", "\u225A": "veeeq", "\u225C": "trie", "\u225F": "equest", "\u2261": "equiv", "\u2262": "nequiv", "\u2261\u20E5": "bnequiv", "\u2264": "le", "\u2270": "nle", "\u2264\u20D2": "nvle", "\u2265": "ge", "\u2271": "nge", "\u2265\u20D2": "nvge", "\u2266": "lE", "\u2266\u0338": "nlE", "\u2267": "gE", "\u2267\u0338": "ngE", "\u2268\uFE00": "lvnE", "\u2268": "lnE", "\u2269": "gnE", "\u2269\uFE00": "gvnE", "\u226A": "ll", "\u226A\u0338": "nLtv", "\u226A\u20D2": "nLt", "\u226B": "gg", "\u226B\u0338": "nGtv", "\u226B\u20D2": "nGt", "\u226C": "twixt", "\u2272": "lsim", "\u2274": "nlsim", "\u2273": "gsim", "\u2275": "ngsim", "\u2276": "lg", "\u2278": "ntlg", "\u2277": "gl", "\u2279": "ntgl", "\u227A": "pr", "\u2280": "npr", "\u227B": "sc", "\u2281": "nsc", "\u227C": "prcue", "\u22E0": "nprcue", "\u227D": "sccue", "\u22E1": "nsccue", "\u227E": "prsim", "\u227F": "scsim", "\u227F\u0338": "NotSucceedsTilde", "\u2282": "sub", "\u2284": "nsub", "\u2282\u20D2": "vnsub", "\u2283": "sup", "\u2285": "nsup", "\u2283\u20D2": "vnsup", "\u2286": "sube", "\u2288": "nsube", "\u2287": "supe", "\u2289": "nsupe", "\u228A\uFE00": "vsubne", "\u228A": "subne", "\u228B\uFE00": "vsupne", "\u228B": "supne", "\u228D": "cupdot", "\u228E": "uplus", "\u228F": "sqsub", "\u228F\u0338": "NotSquareSubset", "\u2290": "sqsup", "\u2290\u0338": "NotSquareSuperset", "\u2291": "sqsube", "\u22E2": "nsqsube", "\u2292": "sqsupe", "\u22E3": "nsqsupe", "\u2293": "sqcap", "\u2293\uFE00": "sqcaps", "\u2294": "sqcup", "\u2294\uFE00": "sqcups", "\u2295": "oplus", "\u2296": "ominus", "\u2297": "otimes", "\u2298": "osol", "\u2299": "odot", "\u229A": "ocir", "\u229B": "oast", "\u229D": "odash", "\u229E": "plusb", "\u229F": "minusb", "\u22A0": "timesb", "\u22A1": "sdotb", "\u22A2": "vdash", "\u22AC": "nvdash", "\u22A3": "dashv", "\u22A4": "top", "\u22A5": "bot", "\u22A7": "models", "\u22A8": "vDash", "\u22AD": "nvDash", "\u22A9": "Vdash", "\u22AE": "nVdash", "\u22AA": "Vvdash", "\u22AB": "VDash", "\u22AF": "nVDash", "\u22B0": "prurel", "\u22B2": "vltri", "\u22EA": "nltri", "\u22B3": "vrtri", "\u22EB": "nrtri", "\u22B4": "ltrie", "\u22EC": "nltrie", "\u22B4\u20D2": "nvltrie", "\u22B5": "rtrie", "\u22ED": "nrtrie", "\u22B5\u20D2": "nvrtrie", "\u22B6": "origof", "\u22B7": "imof", "\u22B8": "mumap", "\u22B9": "hercon", "\u22BA": "intcal", "\u22BB": "veebar", "\u22BD": "barvee", "\u22BE": "angrtvb", "\u22BF": "lrtri", "\u22C0": "Wedge", "\u22C1": "Vee", "\u22C2": "xcap", "\u22C3": "xcup", "\u22C4": "diam", "\u22C5": "sdot", "\u22C6": "Star", "\u22C7": "divonx", "\u22C8": "bowtie", "\u22C9": "ltimes", "\u22CA": "rtimes", "\u22CB": "lthree", "\u22CC": "rthree", "\u22CD": "bsime", "\u22CE": "cuvee", "\u22CF": "cuwed", "\u22D0": "Sub", "\u22D1": "Sup", "\u22D2": "Cap", "\u22D3": "Cup", "\u22D4": "fork", "\u22D5": "epar", "\u22D6": "ltdot", "\u22D7": "gtdot", "\u22D8": "Ll", "\u22D8\u0338": "nLl", "\u22D9": "Gg", "\u22D9\u0338": "nGg", "\u22DA\uFE00": "lesg", "\u22DA": "leg", "\u22DB": "gel", "\u22DB\uFE00": "gesl", "\u22DE": "cuepr", "\u22DF": "cuesc", "\u22E6": "lnsim", "\u22E7": "gnsim", "\u22E8": "prnsim", "\u22E9": "scnsim", "\u22EE": "vellip", "\u22EF": "ctdot", "\u22F0": "utdot", "\u22F1": "dtdot", "\u22F2": "disin", "\u22F3": "isinsv", "\u22F4": "isins", "\u22F5": "isindot", "\u22F5\u0338": "notindot", "\u22F6": "notinvc", "\u22F7": "notinvb", "\u22F9": "isinE", "\u22F9\u0338": "notinE", "\u22FA": "nisd", "\u22FB": "xnis", "\u22FC": "nis", "\u22FD": "notnivc", "\u22FE": "notnivb", "\u2305": "barwed", "\u2306": "Barwed", "\u230C": "drcrop", "\u230D": "dlcrop", "\u230E": "urcrop", "\u230F": "ulcrop", "\u2310": "bnot", "\u2312": "profline", "\u2313": "profsurf", "\u2315": "telrec", "\u2316": "target", "\u231C": "ulcorn", "\u231D": "urcorn", "\u231E": "dlcorn", "\u231F": "drcorn", "\u2322": "frown", "\u2323": "smile", "\u232D": "cylcty", "\u232E": "profalar", "\u2336": "topbot", "\u233D": "ovbar", "\u233F": "solbar", "\u237C": "angzarr", "\u23B0": "lmoust", "\u23B1": "rmoust", "\u23B4": "tbrk", "\u23B5": "bbrk", "\u23B6": "bbrktbrk", "\u23DC": "OverParenthesis", "\u23DD": "UnderParenthesis", "\u23DE": "OverBrace", "\u23DF": "UnderBrace", "\u23E2": "trpezium", "\u23E7": "elinters", "\u2423": "blank", "\u2500": "boxh", "\u2502": "boxv", "\u250C": "boxdr", "\u2510": "boxdl", "\u2514": "boxur", "\u2518": "boxul", "\u251C": "boxvr", "\u2524": "boxvl", "\u252C": "boxhd", "\u2534": "boxhu", "\u253C": "boxvh", "\u2550": "boxH", "\u2551": "boxV", "\u2552": "boxdR", "\u2553": "boxDr", "\u2554": "boxDR", "\u2555": "boxdL", "\u2556": "boxDl", "\u2557": "boxDL", "\u2558": "boxuR", "\u2559": "boxUr", "\u255A": "boxUR", "\u255B": "boxuL", "\u255C": "boxUl", "\u255D": "boxUL", "\u255E": "boxvR", "\u255F": "boxVr", "\u2560": "boxVR", "\u2561": "boxvL", "\u2562": "boxVl", "\u2563": "boxVL", "\u2564": "boxHd", "\u2565": "boxhD", "\u2566": "boxHD", "\u2567": "boxHu", "\u2568": "boxhU", "\u2569": "boxHU", "\u256A": "boxvH", "\u256B": "boxVh", "\u256C": "boxVH", "\u2580": "uhblk", "\u2584": "lhblk", "\u2588": "block", "\u2591": "blk14", "\u2592": "blk12", "\u2593": "blk34", "\u25A1": "squ", "\u25AA": "squf", "\u25AB": "EmptyVerySmallSquare", "\u25AD": "rect", "\u25AE": "marker", "\u25B1": "fltns", "\u25B3": "xutri", "\u25B4": "utrif", "\u25B5": "utri", "\u25B8": "rtrif", "\u25B9": "rtri", "\u25BD": "xdtri", "\u25BE": "dtrif", "\u25BF": "dtri", "\u25C2": "ltrif", "\u25C3": "ltri", "\u25CA": "loz", "\u25CB": "cir", "\u25EC": "tridot", "\u25EF": "xcirc", "\u25F8": "ultri", "\u25F9": "urtri", "\u25FA": "lltri", "\u25FB": "EmptySmallSquare", "\u25FC": "FilledSmallSquare", "\u2605": "starf", "\u2606": "star", "\u260E": "phone", "\u2640": "female", "\u2642": "male", "\u2660": "spades", "\u2663": "clubs", "\u2665": "hearts", "\u2666": "diams", "\u266A": "sung", "\u2713": "check", "\u2717": "cross", "\u2720": "malt", "\u2736": "sext", "\u2758": "VerticalSeparator", "\u27C8": "bsolhsub", "\u27C9": "suphsol", "\u27F5": "xlarr", "\u27F6": "xrarr", "\u27F7": "xharr", "\u27F8": "xlArr", "\u27F9": "xrArr", "\u27FA": "xhArr", "\u27FC": "xmap", "\u27FF": "dzigrarr", "\u2902": "nvlArr", "\u2903": "nvrArr", "\u2904": "nvHarr", "\u2905": "Map", "\u290C": "lbarr", "\u290D": "rbarr", "\u290E": "lBarr", "\u290F": "rBarr", "\u2910": "RBarr", "\u2911": "DDotrahd", "\u2912": "UpArrowBar", "\u2913": "DownArrowBar", "\u2916": "Rarrtl", "\u2919": "latail", "\u291A": "ratail", "\u291B": "lAtail", "\u291C": "rAtail", "\u291D": "larrfs", "\u291E": "rarrfs", "\u291F": "larrbfs", "\u2920": "rarrbfs", "\u2923": "nwarhk", "\u2924": "nearhk", "\u2925": "searhk", "\u2926": "swarhk", "\u2927": "nwnear", "\u2928": "toea", "\u2929": "tosa", "\u292A": "swnwar", "\u2933": "rarrc", "\u2933\u0338": "nrarrc", "\u2935": "cudarrr", "\u2936": "ldca", "\u2937": "rdca", "\u2938": "cudarrl", "\u2939": "larrpl", "\u293C": "curarrm", "\u293D": "cularrp", "\u2945": "rarrpl", "\u2948": "harrcir", "\u2949": "Uarrocir", "\u294A": "lurdshar", "\u294B": "ldrushar", "\u294E": "LeftRightVector", "\u294F": "RightUpDownVector", "\u2950": "DownLeftRightVector", "\u2951": "LeftUpDownVector", "\u2952": "LeftVectorBar", "\u2953": "RightVectorBar", "\u2954": "RightUpVectorBar", "\u2955": "RightDownVectorBar", "\u2956": "DownLeftVectorBar", "\u2957": "DownRightVectorBar", "\u2958": "LeftUpVectorBar", "\u2959": "LeftDownVectorBar", "\u295A": "LeftTeeVector", "\u295B": "RightTeeVector", "\u295C": "RightUpTeeVector", "\u295D": "RightDownTeeVector", "\u295E": "DownLeftTeeVector", "\u295F": "DownRightTeeVector", "\u2960": "LeftUpTeeVector", "\u2961": "LeftDownTeeVector", "\u2962": "lHar", "\u2963": "uHar", "\u2964": "rHar", "\u2965": "dHar", "\u2966": "luruhar", "\u2967": "ldrdhar", "\u2968": "ruluhar", "\u2969": "rdldhar", "\u296A": "lharul", "\u296B": "llhard", "\u296C": "rharul", "\u296D": "lrhard", "\u296E": "udhar", "\u296F": "duhar", "\u2970": "RoundImplies", "\u2971": "erarr", "\u2972": "simrarr", "\u2973": "larrsim", "\u2974": "rarrsim", "\u2975": "rarrap", "\u2976": "ltlarr", "\u2978": "gtrarr", "\u2979": "subrarr", "\u297B": "suplarr", "\u297C": "lfisht", "\u297D": "rfisht", "\u297E": "ufisht", "\u297F": "dfisht", "\u299A": "vzigzag", "\u299C": "vangrt", "\u299D": "angrtvbd", "\u29A4": "ange", "\u29A5": "range", "\u29A6": "dwangle", "\u29A7": "uwangle", "\u29A8": "angmsdaa", "\u29A9": "angmsdab", "\u29AA": "angmsdac", "\u29AB": "angmsdad", "\u29AC": "angmsdae", "\u29AD": "angmsdaf", "\u29AE": "angmsdag", "\u29AF": "angmsdah", "\u29B0": "bemptyv", "\u29B1": "demptyv", "\u29B2": "cemptyv", "\u29B3": "raemptyv", "\u29B4": "laemptyv", "\u29B5": "ohbar", "\u29B6": "omid", "\u29B7": "opar", "\u29B9": "operp", "\u29BB": "olcross", "\u29BC": "odsold", "\u29BE": "olcir", "\u29BF": "ofcir", "\u29C0": "olt", "\u29C1": "ogt", "\u29C2": "cirscir", "\u29C3": "cirE", "\u29C4": "solb", "\u29C5": "bsolb", "\u29C9": "boxbox", "\u29CD": "trisb", "\u29CE": "rtriltri", "\u29CF": "LeftTriangleBar", "\u29CF\u0338": "NotLeftTriangleBar", "\u29D0": "RightTriangleBar", "\u29D0\u0338": "NotRightTriangleBar", "\u29DC": "iinfin", "\u29DD": "infintie", "\u29DE": "nvinfin", "\u29E3": "eparsl", "\u29E4": "smeparsl", "\u29E5": "eqvparsl", "\u29EB": "lozf", "\u29F4": "RuleDelayed", "\u29F6": "dsol", "\u2A00": "xodot", "\u2A01": "xoplus", "\u2A02": "xotime", "\u2A04": "xuplus", "\u2A06": "xsqcup", "\u2A0D": "fpartint", "\u2A10": "cirfnint", "\u2A11": "awint", "\u2A12": "rppolint", "\u2A13": "scpolint", "\u2A14": "npolint", "\u2A15": "pointint", "\u2A16": "quatint", "\u2A17": "intlarhk", "\u2A22": "pluscir", "\u2A23": "plusacir", "\u2A24": "simplus", "\u2A25": "plusdu", "\u2A26": "plussim", "\u2A27": "plustwo", "\u2A29": "mcomma", "\u2A2A": "minusdu", "\u2A2D": "loplus", "\u2A2E": "roplus", "\u2A2F": "Cross", "\u2A30": "timesd", "\u2A31": "timesbar", "\u2A33": "smashp", "\u2A34": "lotimes", "\u2A35": "rotimes", "\u2A36": "otimesas", "\u2A37": "Otimes", "\u2A38": "odiv", "\u2A39": "triplus", "\u2A3A": "triminus", "\u2A3B": "tritime", "\u2A3C": "iprod", "\u2A3F": "amalg", "\u2A40": "capdot", "\u2A42": "ncup", "\u2A43": "ncap", "\u2A44": "capand", "\u2A45": "cupor", "\u2A46": "cupcap", "\u2A47": "capcup", "\u2A48": "cupbrcap", "\u2A49": "capbrcup", "\u2A4A": "cupcup", "\u2A4B": "capcap", "\u2A4C": "ccups", "\u2A4D": "ccaps", "\u2A50": "ccupssm", "\u2A53": "And", "\u2A54": "Or", "\u2A55": "andand", "\u2A56": "oror", "\u2A57": "orslope", "\u2A58": "andslope", "\u2A5A": "andv", "\u2A5B": "orv", "\u2A5C": "andd", "\u2A5D": "ord", "\u2A5F": "wedbar", "\u2A66": "sdote", "\u2A6A": "simdot", "\u2A6D": "congdot", "\u2A6D\u0338": "ncongdot", "\u2A6E": "easter", "\u2A6F": "apacir", "\u2A70": "apE", "\u2A70\u0338": "napE", "\u2A71": "eplus", "\u2A72": "pluse", "\u2A73": "Esim", "\u2A77": "eDDot", "\u2A78": "equivDD", "\u2A79": "ltcir", "\u2A7A": "gtcir", "\u2A7B": "ltquest", "\u2A7C": "gtquest", "\u2A7D": "les", "\u2A7D\u0338": "nles", "\u2A7E": "ges", "\u2A7E\u0338": "nges", "\u2A7F": "lesdot", "\u2A80": "gesdot", "\u2A81": "lesdoto", "\u2A82": "gesdoto", "\u2A83": "lesdotor", "\u2A84": "gesdotol", "\u2A85": "lap", "\u2A86": "gap", "\u2A87": "lne", "\u2A88": "gne", "\u2A89": "lnap", "\u2A8A": "gnap", "\u2A8B": "lEg", "\u2A8C": "gEl", "\u2A8D": "lsime", "\u2A8E": "gsime", "\u2A8F": "lsimg", "\u2A90": "gsiml", "\u2A91": "lgE", "\u2A92": "glE", "\u2A93": "lesges", "\u2A94": "gesles", "\u2A95": "els", "\u2A96": "egs", "\u2A97": "elsdot", "\u2A98": "egsdot", "\u2A99": "el", "\u2A9A": "eg", "\u2A9D": "siml", "\u2A9E": "simg", "\u2A9F": "simlE", "\u2AA0": "simgE", "\u2AA1": "LessLess", "\u2AA1\u0338": "NotNestedLessLess", "\u2AA2": "GreaterGreater", "\u2AA2\u0338": "NotNestedGreaterGreater", "\u2AA4": "glj", "\u2AA5": "gla", "\u2AA6": "ltcc", "\u2AA7": "gtcc", "\u2AA8": "lescc", "\u2AA9": "gescc", "\u2AAA": "smt", "\u2AAB": "lat", "\u2AAC": "smte", "\u2AAC\uFE00": "smtes", "\u2AAD": "late", "\u2AAD\uFE00": "lates", "\u2AAE": "bumpE", "\u2AAF": "pre", "\u2AAF\u0338": "npre", "\u2AB0": "sce", "\u2AB0\u0338": "nsce", "\u2AB3": "prE", "\u2AB4": "scE", "\u2AB5": "prnE", "\u2AB6": "scnE", "\u2AB7": "prap", "\u2AB8": "scap", "\u2AB9": "prnap", "\u2ABA": "scnap", "\u2ABB": "Pr", "\u2ABC": "Sc", "\u2ABD": "subdot", "\u2ABE": "supdot", "\u2ABF": "subplus", "\u2AC0": "supplus", "\u2AC1": "submult", "\u2AC2": "supmult", "\u2AC3": "subedot", "\u2AC4": "supedot", "\u2AC5": "subE", "\u2AC5\u0338": "nsubE", "\u2AC6": "supE", "\u2AC6\u0338": "nsupE", "\u2AC7": "subsim", "\u2AC8": "supsim", "\u2ACB\uFE00": "vsubnE", "\u2ACB": "subnE", "\u2ACC\uFE00": "vsupnE", "\u2ACC": "supnE", "\u2ACF": "csub", "\u2AD0": "csup", "\u2AD1": "csube", "\u2AD2": "csupe", "\u2AD3": "subsup", "\u2AD4": "supsub", "\u2AD5": "subsub", "\u2AD6": "supsup", "\u2AD7": "suphsub", "\u2AD8": "supdsub", "\u2AD9": "forkv", "\u2ADA": "topfork", "\u2ADB": "mlcp", "\u2AE4": "Dashv", "\u2AE6": "Vdashl", "\u2AE7": "Barv", "\u2AE8": "vBar", "\u2AE9": "vBarv", "\u2AEB": "Vbar", "\u2AEC": "Not", "\u2AED": "bNot", "\u2AEE": "rnmid", "\u2AEF": "cirmid", "\u2AF0": "midcir", "\u2AF1": "topcir", "\u2AF2": "nhpar", "\u2AF3": "parsim", "\u2AFD": "parsl", "\u2AFD\u20E5": "nparsl", "\u266D": "flat", "\u266E": "natur", "\u266F": "sharp", "\xA4": "curren", "\xA2": "cent", "$": "dollar", "\xA3": "pound", "\xA5": "yen", "\u20AC": "euro", "\xB9": "sup1", "\xBD": "half", "\u2153": "frac13", "\xBC": "frac14", "\u2155": "frac15", "\u2159": "frac16", "\u215B": "frac18", "\xB2": "sup2", "\u2154": "frac23", "\u2156": "frac25", "\xB3": "sup3", "\xBE": "frac34", "\u2157": "frac35", "\u215C": "frac38", "\u2158": "frac45", "\u215A": "frac56", "\u215D": "frac58", "\u215E": "frac78", "\u{1D4B6}": "ascr", "\u{1D552}": "aopf", "\u{1D51E}": "afr", "\u{1D538}": "Aopf", "\u{1D504}": "Afr", "\u{1D49C}": "Ascr", "\xAA": "ordf", "\xE1": "aacute", "\xC1": "Aacute", "\xE0": "agrave", "\xC0": "Agrave", "\u0103": "abreve", "\u0102": "Abreve", "\xE2": "acirc", "\xC2": "Acirc", "\xE5": "aring", "\xC5": "angst", "\xE4": "auml", "\xC4": "Auml", "\xE3": "atilde", "\xC3": "Atilde", "\u0105": "aogon", "\u0104": "Aogon", "\u0101": "amacr", "\u0100": "Amacr", "\xE6": "aelig", "\xC6": "AElig", "\u{1D4B7}": "bscr", "\u{1D553}": "bopf", "\u{1D51F}": "bfr", "\u{1D539}": "Bopf", "\u212C": "Bscr", "\u{1D505}": "Bfr", "\u{1D520}": "cfr", "\u{1D4B8}": "cscr", "\u{1D554}": "copf", "\u212D": "Cfr", "\u{1D49E}": "Cscr", "\u2102": "Copf", "\u0107": "cacute", "\u0106": "Cacute", "\u0109": "ccirc", "\u0108": "Ccirc", "\u010D": "ccaron", "\u010C": "Ccaron", "\u010B": "cdot", "\u010A": "Cdot", "\xE7": "ccedil", "\xC7": "Ccedil", "\u2105": "incare", "\u{1D521}": "dfr", "\u2146": "dd", "\u{1D555}": "dopf", "\u{1D4B9}": "dscr", "\u{1D49F}": "Dscr", "\u{1D507}": "Dfr", "\u2145": "DD", "\u{1D53B}": "Dopf", "\u010F": "dcaron", "\u010E": "Dcaron", "\u0111": "dstrok", "\u0110": "Dstrok", "\xF0": "eth", "\xD0": "ETH", "\u2147": "ee", "\u212F": "escr", "\u{1D522}": "efr", "\u{1D556}": "eopf", "\u2130": "Escr", "\u{1D508}": "Efr", "\u{1D53C}": "Eopf", "\xE9": "eacute", "\xC9": "Eacute", "\xE8": "egrave", "\xC8": "Egrave", "\xEA": "ecirc", "\xCA": "Ecirc", "\u011B": "ecaron", "\u011A": "Ecaron", "\xEB": "euml", "\xCB": "Euml", "\u0117": "edot", "\u0116": "Edot", "\u0119": "eogon", "\u0118": "Eogon", "\u0113": "emacr", "\u0112": "Emacr", "\u{1D523}": "ffr", "\u{1D557}": "fopf", "\u{1D4BB}": "fscr", "\u{1D509}": "Ffr", "\u{1D53D}": "Fopf", "\u2131": "Fscr", "\uFB00": "fflig", "\uFB03": "ffilig", "\uFB04": "ffllig", "\uFB01": "filig", "fj": "fjlig", "\uFB02": "fllig", "\u0192": "fnof", "\u210A": "gscr", "\u{1D558}": "gopf", "\u{1D524}": "gfr", "\u{1D4A2}": "Gscr", "\u{1D53E}": "Gopf", "\u{1D50A}": "Gfr", "\u01F5": "gacute", "\u011F": "gbreve", "\u011E": "Gbreve", "\u011D": "gcirc", "\u011C": "Gcirc", "\u0121": "gdot", "\u0120": "Gdot", "\u0122": "Gcedil", "\u{1D525}": "hfr", "\u210E": "planckh", "\u{1D4BD}": "hscr", "\u{1D559}": "hopf", "\u210B": "Hscr", "\u210C": "Hfr", "\u210D": "Hopf", "\u0125": "hcirc", "\u0124": "Hcirc", "\u210F": "hbar", "\u0127": "hstrok", "\u0126": "Hstrok", "\u{1D55A}": "iopf", "\u{1D526}": "ifr", "\u{1D4BE}": "iscr", "\u2148": "ii", "\u{1D540}": "Iopf", "\u2110": "Iscr", "\u2111": "Im", "\xED": "iacute", "\xCD": "Iacute", "\xEC": "igrave", "\xCC": "Igrave", "\xEE": "icirc", "\xCE": "Icirc", "\xEF": "iuml", "\xCF": "Iuml", "\u0129": "itilde", "\u0128": "Itilde", "\u0130": "Idot", "\u012F": "iogon", "\u012E": "Iogon", "\u012B": "imacr", "\u012A": "Imacr", "\u0133": "ijlig", "\u0132": "IJlig", "\u0131": "imath", "\u{1D4BF}": "jscr", "\u{1D55B}": "jopf", "\u{1D527}": "jfr", "\u{1D4A5}": "Jscr", "\u{1D50D}": "Jfr", "\u{1D541}": "Jopf", "\u0135": "jcirc", "\u0134": "Jcirc", "\u0237": "jmath", "\u{1D55C}": "kopf", "\u{1D4C0}": "kscr", "\u{1D528}": "kfr", "\u{1D4A6}": "Kscr", "\u{1D542}": "Kopf", "\u{1D50E}": "Kfr", "\u0137": "kcedil", "\u0136": "Kcedil", "\u{1D529}": "lfr", "\u{1D4C1}": "lscr", "\u2113": "ell", "\u{1D55D}": "lopf", "\u2112": "Lscr", "\u{1D50F}": "Lfr", "\u{1D543}": "Lopf", "\u013A": "lacute", "\u0139": "Lacute", "\u013E": "lcaron", "\u013D": "Lcaron", "\u013C": "lcedil", "\u013B": "Lcedil", "\u0142": "lstrok", "\u0141": "Lstrok", "\u0140": "lmidot", "\u013F": "Lmidot", "\u{1D52A}": "mfr", "\u{1D55E}": "mopf", "\u{1D4C2}": "mscr", "\u{1D510}": "Mfr", "\u{1D544}": "Mopf", "\u2133": "Mscr", "\u{1D52B}": "nfr", "\u{1D55F}": "nopf", "\u{1D4C3}": "nscr", "\u2115": "Nopf", "\u{1D4A9}": "Nscr", "\u{1D511}": "Nfr", "\u0144": "nacute", "\u0143": "Nacute", "\u0148": "ncaron", "\u0147": "Ncaron", "\xF1": "ntilde", "\xD1": "Ntilde", "\u0146": "ncedil", "\u0145": "Ncedil", "\u2116": "numero", "\u014B": "eng", "\u014A": "ENG", "\u{1D560}": "oopf", "\u{1D52C}": "ofr", "\u2134": "oscr", "\u{1D4AA}": "Oscr", "\u{1D512}": "Ofr", "\u{1D546}": "Oopf", "\xBA": "ordm", "\xF3": "oacute", "\xD3": "Oacute", "\xF2": "ograve", "\xD2": "Ograve", "\xF4": "ocirc", "\xD4": "Ocirc", "\xF6": "ouml", "\xD6": "Ouml", "\u0151": "odblac", "\u0150": "Odblac", "\xF5": "otilde", "\xD5": "Otilde", "\xF8": "oslash", "\xD8": "Oslash", "\u014D": "omacr", "\u014C": "Omacr", "\u0153": "oelig", "\u0152": "OElig", "\u{1D52D}": "pfr", "\u{1D4C5}": "pscr", "\u{1D561}": "popf", "\u2119": "Popf", "\u{1D513}": "Pfr", "\u{1D4AB}": "Pscr", "\u{1D562}": "qopf", "\u{1D52E}": "qfr", "\u{1D4C6}": "qscr", "\u{1D4AC}": "Qscr", "\u{1D514}": "Qfr", "\u211A": "Qopf", "\u0138": "kgreen", "\u{1D52F}": "rfr", "\u{1D563}": "ropf", "\u{1D4C7}": "rscr", "\u211B": "Rscr", "\u211C": "Re", "\u211D": "Ropf", "\u0155": "racute", "\u0154": "Racute", "\u0159": "rcaron", "\u0158": "Rcaron", "\u0157": "rcedil", "\u0156": "Rcedil", "\u{1D564}": "sopf", "\u{1D4C8}": "sscr", "\u{1D530}": "sfr", "\u{1D54A}": "Sopf", "\u{1D516}": "Sfr", "\u{1D4AE}": "Sscr", "\u24C8": "oS", "\u015B": "sacute", "\u015A": "Sacute", "\u015D": "scirc", "\u015C": "Scirc", "\u0161": "scaron", "\u0160": "Scaron", "\u015F": "scedil", "\u015E": "Scedil", "\xDF": "szlig", "\u{1D531}": "tfr", "\u{1D4C9}": "tscr", "\u{1D565}": "topf", "\u{1D4AF}": "Tscr", "\u{1D517}": "Tfr", "\u{1D54B}": "Topf", "\u0165": "tcaron", "\u0164": "Tcaron", "\u0163": "tcedil", "\u0162": "Tcedil", "\u2122": "trade", "\u0167": "tstrok", "\u0166": "Tstrok", "\u{1D4CA}": "uscr", "\u{1D566}": "uopf", "\u{1D532}": "ufr", "\u{1D54C}": "Uopf", "\u{1D518}": "Ufr", "\u{1D4B0}": "Uscr", "\xFA": "uacute", "\xDA": "Uacute", "\xF9": "ugrave", "\xD9": "Ugrave", "\u016D": "ubreve", "\u016C": "Ubreve", "\xFB": "ucirc", "\xDB": "Ucirc", "\u016F": "uring", "\u016E": "Uring", "\xFC": "uuml", "\xDC": "Uuml", "\u0171": "udblac", "\u0170": "Udblac", "\u0169": "utilde", "\u0168": "Utilde", "\u0173": "uogon", "\u0172": "Uogon", "\u016B": "umacr", "\u016A": "Umacr", "\u{1D533}": "vfr", "\u{1D567}": "vopf", "\u{1D4CB}": "vscr", "\u{1D519}": "Vfr", "\u{1D54D}": "Vopf", "\u{1D4B1}": "Vscr", "\u{1D568}": "wopf", "\u{1D4CC}": "wscr", "\u{1D534}": "wfr", "\u{1D4B2}": "Wscr", "\u{1D54E}": "Wopf", "\u{1D51A}": "Wfr", "\u0175": "wcirc", "\u0174": "Wcirc", "\u{1D535}": "xfr", "\u{1D4CD}": "xscr", "\u{1D569}": "xopf", "\u{1D54F}": "Xopf", "\u{1D51B}": "Xfr", "\u{1D4B3}": "Xscr", "\u{1D536}": "yfr", "\u{1D4CE}": "yscr", "\u{1D56A}": "yopf", "\u{1D4B4}": "Yscr", "\u{1D51C}": "Yfr", "\u{1D550}": "Yopf", "\xFD": "yacute", "\xDD": "Yacute", "\u0177": "ycirc", "\u0176": "Ycirc", "\xFF": "yuml", "\u0178": "Yuml", "\u{1D4CF}": "zscr", "\u{1D537}": "zfr", "\u{1D56B}": "zopf", "\u2128": "Zfr", "\u2124": "Zopf", "\u{1D4B5}": "Zscr", "\u017A": "zacute", "\u0179": "Zacute", "\u017E": "zcaron", "\u017D": "Zcaron", "\u017C": "zdot", "\u017B": "Zdot", "\u01B5": "imped", "\xFE": "thorn", "\xDE": "THORN", "\u0149": "napos", "\u03B1": "alpha", "\u0391": "Alpha", "\u03B2": "beta", "\u0392": "Beta", "\u03B3": "gamma", "\u0393": "Gamma", "\u03B4": "delta", "\u0394": "Delta", "\u03B5": "epsi", "\u03F5": "epsiv", "\u0395": "Epsilon", "\u03DD": "gammad", "\u03DC": "Gammad", "\u03B6": "zeta", "\u0396": "Zeta", "\u03B7": "eta", "\u0397": "Eta", "\u03B8": "theta", "\u03D1": "thetav", "\u0398": "Theta", "\u03B9": "iota", "\u0399": "Iota", "\u03BA": "kappa", "\u03F0": "kappav", "\u039A": "Kappa", "\u03BB": "lambda", "\u039B": "Lambda", "\u03BC": "mu", "\xB5": "micro", "\u039C": "Mu", "\u03BD": "nu", "\u039D": "Nu", "\u03BE": "xi", "\u039E": "Xi", "\u03BF": "omicron", "\u039F": "Omicron", "\u03C0": "pi", "\u03D6": "piv", "\u03A0": "Pi", "\u03C1": "rho", "\u03F1": "rhov", "\u03A1": "Rho", "\u03C3": "sigma", "\u03A3": "Sigma", "\u03C2": "sigmaf", "\u03C4": "tau", "\u03A4": "Tau", "\u03C5": "upsi", "\u03A5": "Upsilon", "\u03D2": "Upsi", "\u03C6": "phi", "\u03D5": "phiv", "\u03A6": "Phi", "\u03C7": "chi", "\u03A7": "Chi", "\u03C8": "psi", "\u03A8": "Psi", "\u03C9": "omega", "\u03A9": "ohm", "\u0430": "acy", "\u0410": "Acy", "\u0431": "bcy", "\u0411": "Bcy", "\u0432": "vcy", "\u0412": "Vcy", "\u0433": "gcy", "\u0413": "Gcy", "\u0453": "gjcy", "\u0403": "GJcy", "\u0434": "dcy", "\u0414": "Dcy", "\u0452": "djcy", "\u0402": "DJcy", "\u0435": "iecy", "\u0415": "IEcy", "\u0451": "iocy", "\u0401": "IOcy", "\u0454": "jukcy", "\u0404": "Jukcy", "\u0436": "zhcy", "\u0416": "ZHcy", "\u0437": "zcy", "\u0417": "Zcy", "\u0455": "dscy", "\u0405": "DScy", "\u0438": "icy", "\u0418": "Icy", "\u0456": "iukcy", "\u0406": "Iukcy", "\u0457": "yicy", "\u0407": "YIcy", "\u0439": "jcy", "\u0419": "Jcy", "\u0458": "jsercy", "\u0408": "Jsercy", "\u043A": "kcy", "\u041A": "Kcy", "\u045C": "kjcy", "\u040C": "KJcy", "\u043B": "lcy", "\u041B": "Lcy", "\u0459": "ljcy", "\u0409": "LJcy", "\u043C": "mcy", "\u041C": "Mcy", "\u043D": "ncy", "\u041D": "Ncy", "\u045A": "njcy", "\u040A": "NJcy", "\u043E": "ocy", "\u041E": "Ocy", "\u043F": "pcy", "\u041F": "Pcy", "\u0440": "rcy", "\u0420": "Rcy", "\u0441": "scy", "\u0421": "Scy", "\u0442": "tcy", "\u0422": "Tcy", "\u045B": "tshcy", "\u040B": "TSHcy", "\u0443": "ucy", "\u0423": "Ucy", "\u045E": "ubrcy", "\u040E": "Ubrcy", "\u0444": "fcy", "\u0424": "Fcy", "\u0445": "khcy", "\u0425": "KHcy", "\u0446": "tscy", "\u0426": "TScy", "\u0447": "chcy", "\u0427": "CHcy", "\u045F": "dzcy", "\u040F": "DZcy", "\u0448": "shcy", "\u0428": "SHcy", "\u0449": "shchcy", "\u0429": "SHCHcy", "\u044A": "hardcy", "\u042A": "HARDcy", "\u044B": "ycy", "\u042B": "Ycy", "\u044C": "softcy", "\u042C": "SOFTcy", "\u044D": "ecy", "\u042D": "Ecy", "\u044E": "yucy", "\u042E": "YUcy", "\u044F": "yacy", "\u042F": "YAcy", "\u2135": "aleph", "\u2136": "beth", "\u2137": "gimel", "\u2138": "daleth" };
            var regexEscape = /["&'<>`]/g;
            var escapeMap = {
              '"': "&quot;",
              "&": "&amp;",
              "'": "&#x27;",
              "<": "&lt;",
              // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
              // following is not strictly necessary unless its part of a tag or an
              // unquoted attribute value. Were only escaping it to support those
              // situations, and for XML support.
              ">": "&gt;",
              // In Internet Explorer  8, the backtick character can be used
              // to break out of (un)quoted attribute values or HTML comments.
              // See http://html5sec.org/#102, http://html5sec.org/#108, and
              // http://html5sec.org/#133.
              "`": "&#x60;"
            };
            var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
            var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
            var decodeMap = { "aacute": "\xE1", "Aacute": "\xC1", "abreve": "\u0103", "Abreve": "\u0102", "ac": "\u223E", "acd": "\u223F", "acE": "\u223E\u0333", "acirc": "\xE2", "Acirc": "\xC2", "acute": "\xB4", "acy": "\u0430", "Acy": "\u0410", "aelig": "\xE6", "AElig": "\xC6", "af": "\u2061", "afr": "\u{1D51E}", "Afr": "\u{1D504}", "agrave": "\xE0", "Agrave": "\xC0", "alefsym": "\u2135", "aleph": "\u2135", "alpha": "\u03B1", "Alpha": "\u0391", "amacr": "\u0101", "Amacr": "\u0100", "amalg": "\u2A3F", "amp": "&", "AMP": "&", "and": "\u2227", "And": "\u2A53", "andand": "\u2A55", "andd": "\u2A5C", "andslope": "\u2A58", "andv": "\u2A5A", "ang": "\u2220", "ange": "\u29A4", "angle": "\u2220", "angmsd": "\u2221", "angmsdaa": "\u29A8", "angmsdab": "\u29A9", "angmsdac": "\u29AA", "angmsdad": "\u29AB", "angmsdae": "\u29AC", "angmsdaf": "\u29AD", "angmsdag": "\u29AE", "angmsdah": "\u29AF", "angrt": "\u221F", "angrtvb": "\u22BE", "angrtvbd": "\u299D", "angsph": "\u2222", "angst": "\xC5", "angzarr": "\u237C", "aogon": "\u0105", "Aogon": "\u0104", "aopf": "\u{1D552}", "Aopf": "\u{1D538}", "ap": "\u2248", "apacir": "\u2A6F", "ape": "\u224A", "apE": "\u2A70", "apid": "\u224B", "apos": "'", "ApplyFunction": "\u2061", "approx": "\u2248", "approxeq": "\u224A", "aring": "\xE5", "Aring": "\xC5", "ascr": "\u{1D4B6}", "Ascr": "\u{1D49C}", "Assign": "\u2254", "ast": "*", "asymp": "\u2248", "asympeq": "\u224D", "atilde": "\xE3", "Atilde": "\xC3", "auml": "\xE4", "Auml": "\xC4", "awconint": "\u2233", "awint": "\u2A11", "backcong": "\u224C", "backepsilon": "\u03F6", "backprime": "\u2035", "backsim": "\u223D", "backsimeq": "\u22CD", "Backslash": "\u2216", "Barv": "\u2AE7", "barvee": "\u22BD", "barwed": "\u2305", "Barwed": "\u2306", "barwedge": "\u2305", "bbrk": "\u23B5", "bbrktbrk": "\u23B6", "bcong": "\u224C", "bcy": "\u0431", "Bcy": "\u0411", "bdquo": "\u201E", "becaus": "\u2235", "because": "\u2235", "Because": "\u2235", "bemptyv": "\u29B0", "bepsi": "\u03F6", "bernou": "\u212C", "Bernoullis": "\u212C", "beta": "\u03B2", "Beta": "\u0392", "beth": "\u2136", "between": "\u226C", "bfr": "\u{1D51F}", "Bfr": "\u{1D505}", "bigcap": "\u22C2", "bigcirc": "\u25EF", "bigcup": "\u22C3", "bigodot": "\u2A00", "bigoplus": "\u2A01", "bigotimes": "\u2A02", "bigsqcup": "\u2A06", "bigstar": "\u2605", "bigtriangledown": "\u25BD", "bigtriangleup": "\u25B3", "biguplus": "\u2A04", "bigvee": "\u22C1", "bigwedge": "\u22C0", "bkarow": "\u290D", "blacklozenge": "\u29EB", "blacksquare": "\u25AA", "blacktriangle": "\u25B4", "blacktriangledown": "\u25BE", "blacktriangleleft": "\u25C2", "blacktriangleright": "\u25B8", "blank": "\u2423", "blk12": "\u2592", "blk14": "\u2591", "blk34": "\u2593", "block": "\u2588", "bne": "=\u20E5", "bnequiv": "\u2261\u20E5", "bnot": "\u2310", "bNot": "\u2AED", "bopf": "\u{1D553}", "Bopf": "\u{1D539}", "bot": "\u22A5", "bottom": "\u22A5", "bowtie": "\u22C8", "boxbox": "\u29C9", "boxdl": "\u2510", "boxdL": "\u2555", "boxDl": "\u2556", "boxDL": "\u2557", "boxdr": "\u250C", "boxdR": "\u2552", "boxDr": "\u2553", "boxDR": "\u2554", "boxh": "\u2500", "boxH": "\u2550", "boxhd": "\u252C", "boxhD": "\u2565", "boxHd": "\u2564", "boxHD": "\u2566", "boxhu": "\u2534", "boxhU": "\u2568", "boxHu": "\u2567", "boxHU": "\u2569", "boxminus": "\u229F", "boxplus": "\u229E", "boxtimes": "\u22A0", "boxul": "\u2518", "boxuL": "\u255B", "boxUl": "\u255C", "boxUL": "\u255D", "boxur": "\u2514", "boxuR": "\u2558", "boxUr": "\u2559", "boxUR": "\u255A", "boxv": "\u2502", "boxV": "\u2551", "boxvh": "\u253C", "boxvH": "\u256A", "boxVh": "\u256B", "boxVH": "\u256C", "boxvl": "\u2524", "boxvL": "\u2561", "boxVl": "\u2562", "boxVL": "\u2563", "boxvr": "\u251C", "boxvR": "\u255E", "boxVr": "\u255F", "boxVR": "\u2560", "bprime": "\u2035", "breve": "\u02D8", "Breve": "\u02D8", "brvbar": "\xA6", "bscr": "\u{1D4B7}", "Bscr": "\u212C", "bsemi": "\u204F", "bsim": "\u223D", "bsime": "\u22CD", "bsol": "\\", "bsolb": "\u29C5", "bsolhsub": "\u27C8", "bull": "\u2022", "bullet": "\u2022", "bump": "\u224E", "bumpe": "\u224F", "bumpE": "\u2AAE", "bumpeq": "\u224F", "Bumpeq": "\u224E", "cacute": "\u0107", "Cacute": "\u0106", "cap": "\u2229", "Cap": "\u22D2", "capand": "\u2A44", "capbrcup": "\u2A49", "capcap": "\u2A4B", "capcup": "\u2A47", "capdot": "\u2A40", "CapitalDifferentialD": "\u2145", "caps": "\u2229\uFE00", "caret": "\u2041", "caron": "\u02C7", "Cayleys": "\u212D", "ccaps": "\u2A4D", "ccaron": "\u010D", "Ccaron": "\u010C", "ccedil": "\xE7", "Ccedil": "\xC7", "ccirc": "\u0109", "Ccirc": "\u0108", "Cconint": "\u2230", "ccups": "\u2A4C", "ccupssm": "\u2A50", "cdot": "\u010B", "Cdot": "\u010A", "cedil": "\xB8", "Cedilla": "\xB8", "cemptyv": "\u29B2", "cent": "\xA2", "centerdot": "\xB7", "CenterDot": "\xB7", "cfr": "\u{1D520}", "Cfr": "\u212D", "chcy": "\u0447", "CHcy": "\u0427", "check": "\u2713", "checkmark": "\u2713", "chi": "\u03C7", "Chi": "\u03A7", "cir": "\u25CB", "circ": "\u02C6", "circeq": "\u2257", "circlearrowleft": "\u21BA", "circlearrowright": "\u21BB", "circledast": "\u229B", "circledcirc": "\u229A", "circleddash": "\u229D", "CircleDot": "\u2299", "circledR": "\xAE", "circledS": "\u24C8", "CircleMinus": "\u2296", "CirclePlus": "\u2295", "CircleTimes": "\u2297", "cire": "\u2257", "cirE": "\u29C3", "cirfnint": "\u2A10", "cirmid": "\u2AEF", "cirscir": "\u29C2", "ClockwiseContourIntegral": "\u2232", "CloseCurlyDoubleQuote": "\u201D", "CloseCurlyQuote": "\u2019", "clubs": "\u2663", "clubsuit": "\u2663", "colon": ":", "Colon": "\u2237", "colone": "\u2254", "Colone": "\u2A74", "coloneq": "\u2254", "comma": ",", "commat": "@", "comp": "\u2201", "compfn": "\u2218", "complement": "\u2201", "complexes": "\u2102", "cong": "\u2245", "congdot": "\u2A6D", "Congruent": "\u2261", "conint": "\u222E", "Conint": "\u222F", "ContourIntegral": "\u222E", "copf": "\u{1D554}", "Copf": "\u2102", "coprod": "\u2210", "Coproduct": "\u2210", "copy": "\xA9", "COPY": "\xA9", "copysr": "\u2117", "CounterClockwiseContourIntegral": "\u2233", "crarr": "\u21B5", "cross": "\u2717", "Cross": "\u2A2F", "cscr": "\u{1D4B8}", "Cscr": "\u{1D49E}", "csub": "\u2ACF", "csube": "\u2AD1", "csup": "\u2AD0", "csupe": "\u2AD2", "ctdot": "\u22EF", "cudarrl": "\u2938", "cudarrr": "\u2935", "cuepr": "\u22DE", "cuesc": "\u22DF", "cularr": "\u21B6", "cularrp": "\u293D", "cup": "\u222A", "Cup": "\u22D3", "cupbrcap": "\u2A48", "cupcap": "\u2A46", "CupCap": "\u224D", "cupcup": "\u2A4A", "cupdot": "\u228D", "cupor": "\u2A45", "cups": "\u222A\uFE00", "curarr": "\u21B7", "curarrm": "\u293C", "curlyeqprec": "\u22DE", "curlyeqsucc": "\u22DF", "curlyvee": "\u22CE", "curlywedge": "\u22CF", "curren": "\xA4", "curvearrowleft": "\u21B6", "curvearrowright": "\u21B7", "cuvee": "\u22CE", "cuwed": "\u22CF", "cwconint": "\u2232", "cwint": "\u2231", "cylcty": "\u232D", "dagger": "\u2020", "Dagger": "\u2021", "daleth": "\u2138", "darr": "\u2193", "dArr": "\u21D3", "Darr": "\u21A1", "dash": "\u2010", "dashv": "\u22A3", "Dashv": "\u2AE4", "dbkarow": "\u290F", "dblac": "\u02DD", "dcaron": "\u010F", "Dcaron": "\u010E", "dcy": "\u0434", "Dcy": "\u0414", "dd": "\u2146", "DD": "\u2145", "ddagger": "\u2021", "ddarr": "\u21CA", "DDotrahd": "\u2911", "ddotseq": "\u2A77", "deg": "\xB0", "Del": "\u2207", "delta": "\u03B4", "Delta": "\u0394", "demptyv": "\u29B1", "dfisht": "\u297F", "dfr": "\u{1D521}", "Dfr": "\u{1D507}", "dHar": "\u2965", "dharl": "\u21C3", "dharr": "\u21C2", "DiacriticalAcute": "\xB4", "DiacriticalDot": "\u02D9", "DiacriticalDoubleAcute": "\u02DD", "DiacriticalGrave": "`", "DiacriticalTilde": "\u02DC", "diam": "\u22C4", "diamond": "\u22C4", "Diamond": "\u22C4", "diamondsuit": "\u2666", "diams": "\u2666", "die": "\xA8", "DifferentialD": "\u2146", "digamma": "\u03DD", "disin": "\u22F2", "div": "\xF7", "divide": "\xF7", "divideontimes": "\u22C7", "divonx": "\u22C7", "djcy": "\u0452", "DJcy": "\u0402", "dlcorn": "\u231E", "dlcrop": "\u230D", "dollar": "$", "dopf": "\u{1D555}", "Dopf": "\u{1D53B}", "dot": "\u02D9", "Dot": "\xA8", "DotDot": "\u20DC", "doteq": "\u2250", "doteqdot": "\u2251", "DotEqual": "\u2250", "dotminus": "\u2238", "dotplus": "\u2214", "dotsquare": "\u22A1", "doublebarwedge": "\u2306", "DoubleContourIntegral": "\u222F", "DoubleDot": "\xA8", "DoubleDownArrow": "\u21D3", "DoubleLeftArrow": "\u21D0", "DoubleLeftRightArrow": "\u21D4", "DoubleLeftTee": "\u2AE4", "DoubleLongLeftArrow": "\u27F8", "DoubleLongLeftRightArrow": "\u27FA", "DoubleLongRightArrow": "\u27F9", "DoubleRightArrow": "\u21D2", "DoubleRightTee": "\u22A8", "DoubleUpArrow": "\u21D1", "DoubleUpDownArrow": "\u21D5", "DoubleVerticalBar": "\u2225", "downarrow": "\u2193", "Downarrow": "\u21D3", "DownArrow": "\u2193", "DownArrowBar": "\u2913", "DownArrowUpArrow": "\u21F5", "DownBreve": "\u0311", "downdownarrows": "\u21CA", "downharpoonleft": "\u21C3", "downharpoonright": "\u21C2", "DownLeftRightVector": "\u2950", "DownLeftTeeVector": "\u295E", "DownLeftVector": "\u21BD", "DownLeftVectorBar": "\u2956", "DownRightTeeVector": "\u295F", "DownRightVector": "\u21C1", "DownRightVectorBar": "\u2957", "DownTee": "\u22A4", "DownTeeArrow": "\u21A7", "drbkarow": "\u2910", "drcorn": "\u231F", "drcrop": "\u230C", "dscr": "\u{1D4B9}", "Dscr": "\u{1D49F}", "dscy": "\u0455", "DScy": "\u0405", "dsol": "\u29F6", "dstrok": "\u0111", "Dstrok": "\u0110", "dtdot": "\u22F1", "dtri": "\u25BF", "dtrif": "\u25BE", "duarr": "\u21F5", "duhar": "\u296F", "dwangle": "\u29A6", "dzcy": "\u045F", "DZcy": "\u040F", "dzigrarr": "\u27FF", "eacute": "\xE9", "Eacute": "\xC9", "easter": "\u2A6E", "ecaron": "\u011B", "Ecaron": "\u011A", "ecir": "\u2256", "ecirc": "\xEA", "Ecirc": "\xCA", "ecolon": "\u2255", "ecy": "\u044D", "Ecy": "\u042D", "eDDot": "\u2A77", "edot": "\u0117", "eDot": "\u2251", "Edot": "\u0116", "ee": "\u2147", "efDot": "\u2252", "efr": "\u{1D522}", "Efr": "\u{1D508}", "eg": "\u2A9A", "egrave": "\xE8", "Egrave": "\xC8", "egs": "\u2A96", "egsdot": "\u2A98", "el": "\u2A99", "Element": "\u2208", "elinters": "\u23E7", "ell": "\u2113", "els": "\u2A95", "elsdot": "\u2A97", "emacr": "\u0113", "Emacr": "\u0112", "empty": "\u2205", "emptyset": "\u2205", "EmptySmallSquare": "\u25FB", "emptyv": "\u2205", "EmptyVerySmallSquare": "\u25AB", "emsp": "\u2003", "emsp13": "\u2004", "emsp14": "\u2005", "eng": "\u014B", "ENG": "\u014A", "ensp": "\u2002", "eogon": "\u0119", "Eogon": "\u0118", "eopf": "\u{1D556}", "Eopf": "\u{1D53C}", "epar": "\u22D5", "eparsl": "\u29E3", "eplus": "\u2A71", "epsi": "\u03B5", "epsilon": "\u03B5", "Epsilon": "\u0395", "epsiv": "\u03F5", "eqcirc": "\u2256", "eqcolon": "\u2255", "eqsim": "\u2242", "eqslantgtr": "\u2A96", "eqslantless": "\u2A95", "Equal": "\u2A75", "equals": "=", "EqualTilde": "\u2242", "equest": "\u225F", "Equilibrium": "\u21CC", "equiv": "\u2261", "equivDD": "\u2A78", "eqvparsl": "\u29E5", "erarr": "\u2971", "erDot": "\u2253", "escr": "\u212F", "Escr": "\u2130", "esdot": "\u2250", "esim": "\u2242", "Esim": "\u2A73", "eta": "\u03B7", "Eta": "\u0397", "eth": "\xF0", "ETH": "\xD0", "euml": "\xEB", "Euml": "\xCB", "euro": "\u20AC", "excl": "!", "exist": "\u2203", "Exists": "\u2203", "expectation": "\u2130", "exponentiale": "\u2147", "ExponentialE": "\u2147", "fallingdotseq": "\u2252", "fcy": "\u0444", "Fcy": "\u0424", "female": "\u2640", "ffilig": "\uFB03", "fflig": "\uFB00", "ffllig": "\uFB04", "ffr": "\u{1D523}", "Ffr": "\u{1D509}", "filig": "\uFB01", "FilledSmallSquare": "\u25FC", "FilledVerySmallSquare": "\u25AA", "fjlig": "fj", "flat": "\u266D", "fllig": "\uFB02", "fltns": "\u25B1", "fnof": "\u0192", "fopf": "\u{1D557}", "Fopf": "\u{1D53D}", "forall": "\u2200", "ForAll": "\u2200", "fork": "\u22D4", "forkv": "\u2AD9", "Fouriertrf": "\u2131", "fpartint": "\u2A0D", "frac12": "\xBD", "frac13": "\u2153", "frac14": "\xBC", "frac15": "\u2155", "frac16": "\u2159", "frac18": "\u215B", "frac23": "\u2154", "frac25": "\u2156", "frac34": "\xBE", "frac35": "\u2157", "frac38": "\u215C", "frac45": "\u2158", "frac56": "\u215A", "frac58": "\u215D", "frac78": "\u215E", "frasl": "\u2044", "frown": "\u2322", "fscr": "\u{1D4BB}", "Fscr": "\u2131", "gacute": "\u01F5", "gamma": "\u03B3", "Gamma": "\u0393", "gammad": "\u03DD", "Gammad": "\u03DC", "gap": "\u2A86", "gbreve": "\u011F", "Gbreve": "\u011E", "Gcedil": "\u0122", "gcirc": "\u011D", "Gcirc": "\u011C", "gcy": "\u0433", "Gcy": "\u0413", "gdot": "\u0121", "Gdot": "\u0120", "ge": "\u2265", "gE": "\u2267", "gel": "\u22DB", "gEl": "\u2A8C", "geq": "\u2265", "geqq": "\u2267", "geqslant": "\u2A7E", "ges": "\u2A7E", "gescc": "\u2AA9", "gesdot": "\u2A80", "gesdoto": "\u2A82", "gesdotol": "\u2A84", "gesl": "\u22DB\uFE00", "gesles": "\u2A94", "gfr": "\u{1D524}", "Gfr": "\u{1D50A}", "gg": "\u226B", "Gg": "\u22D9", "ggg": "\u22D9", "gimel": "\u2137", "gjcy": "\u0453", "GJcy": "\u0403", "gl": "\u2277", "gla": "\u2AA5", "glE": "\u2A92", "glj": "\u2AA4", "gnap": "\u2A8A", "gnapprox": "\u2A8A", "gne": "\u2A88", "gnE": "\u2269", "gneq": "\u2A88", "gneqq": "\u2269", "gnsim": "\u22E7", "gopf": "\u{1D558}", "Gopf": "\u{1D53E}", "grave": "`", "GreaterEqual": "\u2265", "GreaterEqualLess": "\u22DB", "GreaterFullEqual": "\u2267", "GreaterGreater": "\u2AA2", "GreaterLess": "\u2277", "GreaterSlantEqual": "\u2A7E", "GreaterTilde": "\u2273", "gscr": "\u210A", "Gscr": "\u{1D4A2}", "gsim": "\u2273", "gsime": "\u2A8E", "gsiml": "\u2A90", "gt": ">", "Gt": "\u226B", "GT": ">", "gtcc": "\u2AA7", "gtcir": "\u2A7A", "gtdot": "\u22D7", "gtlPar": "\u2995", "gtquest": "\u2A7C", "gtrapprox": "\u2A86", "gtrarr": "\u2978", "gtrdot": "\u22D7", "gtreqless": "\u22DB", "gtreqqless": "\u2A8C", "gtrless": "\u2277", "gtrsim": "\u2273", "gvertneqq": "\u2269\uFE00", "gvnE": "\u2269\uFE00", "Hacek": "\u02C7", "hairsp": "\u200A", "half": "\xBD", "hamilt": "\u210B", "hardcy": "\u044A", "HARDcy": "\u042A", "harr": "\u2194", "hArr": "\u21D4", "harrcir": "\u2948", "harrw": "\u21AD", "Hat": "^", "hbar": "\u210F", "hcirc": "\u0125", "Hcirc": "\u0124", "hearts": "\u2665", "heartsuit": "\u2665", "hellip": "\u2026", "hercon": "\u22B9", "hfr": "\u{1D525}", "Hfr": "\u210C", "HilbertSpace": "\u210B", "hksearow": "\u2925", "hkswarow": "\u2926", "hoarr": "\u21FF", "homtht": "\u223B", "hookleftarrow": "\u21A9", "hookrightarrow": "\u21AA", "hopf": "\u{1D559}", "Hopf": "\u210D", "horbar": "\u2015", "HorizontalLine": "\u2500", "hscr": "\u{1D4BD}", "Hscr": "\u210B", "hslash": "\u210F", "hstrok": "\u0127", "Hstrok": "\u0126", "HumpDownHump": "\u224E", "HumpEqual": "\u224F", "hybull": "\u2043", "hyphen": "\u2010", "iacute": "\xED", "Iacute": "\xCD", "ic": "\u2063", "icirc": "\xEE", "Icirc": "\xCE", "icy": "\u0438", "Icy": "\u0418", "Idot": "\u0130", "iecy": "\u0435", "IEcy": "\u0415", "iexcl": "\xA1", "iff": "\u21D4", "ifr": "\u{1D526}", "Ifr": "\u2111", "igrave": "\xEC", "Igrave": "\xCC", "ii": "\u2148", "iiiint": "\u2A0C", "iiint": "\u222D", "iinfin": "\u29DC", "iiota": "\u2129", "ijlig": "\u0133", "IJlig": "\u0132", "Im": "\u2111", "imacr": "\u012B", "Imacr": "\u012A", "image": "\u2111", "ImaginaryI": "\u2148", "imagline": "\u2110", "imagpart": "\u2111", "imath": "\u0131", "imof": "\u22B7", "imped": "\u01B5", "Implies": "\u21D2", "in": "\u2208", "incare": "\u2105", "infin": "\u221E", "infintie": "\u29DD", "inodot": "\u0131", "int": "\u222B", "Int": "\u222C", "intcal": "\u22BA", "integers": "\u2124", "Integral": "\u222B", "intercal": "\u22BA", "Intersection": "\u22C2", "intlarhk": "\u2A17", "intprod": "\u2A3C", "InvisibleComma": "\u2063", "InvisibleTimes": "\u2062", "iocy": "\u0451", "IOcy": "\u0401", "iogon": "\u012F", "Iogon": "\u012E", "iopf": "\u{1D55A}", "Iopf": "\u{1D540}", "iota": "\u03B9", "Iota": "\u0399", "iprod": "\u2A3C", "iquest": "\xBF", "iscr": "\u{1D4BE}", "Iscr": "\u2110", "isin": "\u2208", "isindot": "\u22F5", "isinE": "\u22F9", "isins": "\u22F4", "isinsv": "\u22F3", "isinv": "\u2208", "it": "\u2062", "itilde": "\u0129", "Itilde": "\u0128", "iukcy": "\u0456", "Iukcy": "\u0406", "iuml": "\xEF", "Iuml": "\xCF", "jcirc": "\u0135", "Jcirc": "\u0134", "jcy": "\u0439", "Jcy": "\u0419", "jfr": "\u{1D527}", "Jfr": "\u{1D50D}", "jmath": "\u0237", "jopf": "\u{1D55B}", "Jopf": "\u{1D541}", "jscr": "\u{1D4BF}", "Jscr": "\u{1D4A5}", "jsercy": "\u0458", "Jsercy": "\u0408", "jukcy": "\u0454", "Jukcy": "\u0404", "kappa": "\u03BA", "Kappa": "\u039A", "kappav": "\u03F0", "kcedil": "\u0137", "Kcedil": "\u0136", "kcy": "\u043A", "Kcy": "\u041A", "kfr": "\u{1D528}", "Kfr": "\u{1D50E}", "kgreen": "\u0138", "khcy": "\u0445", "KHcy": "\u0425", "kjcy": "\u045C", "KJcy": "\u040C", "kopf": "\u{1D55C}", "Kopf": "\u{1D542}", "kscr": "\u{1D4C0}", "Kscr": "\u{1D4A6}", "lAarr": "\u21DA", "lacute": "\u013A", "Lacute": "\u0139", "laemptyv": "\u29B4", "lagran": "\u2112", "lambda": "\u03BB", "Lambda": "\u039B", "lang": "\u27E8", "Lang": "\u27EA", "langd": "\u2991", "langle": "\u27E8", "lap": "\u2A85", "Laplacetrf": "\u2112", "laquo": "\xAB", "larr": "\u2190", "lArr": "\u21D0", "Larr": "\u219E", "larrb": "\u21E4", "larrbfs": "\u291F", "larrfs": "\u291D", "larrhk": "\u21A9", "larrlp": "\u21AB", "larrpl": "\u2939", "larrsim": "\u2973", "larrtl": "\u21A2", "lat": "\u2AAB", "latail": "\u2919", "lAtail": "\u291B", "late": "\u2AAD", "lates": "\u2AAD\uFE00", "lbarr": "\u290C", "lBarr": "\u290E", "lbbrk": "\u2772", "lbrace": "{", "lbrack": "[", "lbrke": "\u298B", "lbrksld": "\u298F", "lbrkslu": "\u298D", "lcaron": "\u013E", "Lcaron": "\u013D", "lcedil": "\u013C", "Lcedil": "\u013B", "lceil": "\u2308", "lcub": "{", "lcy": "\u043B", "Lcy": "\u041B", "ldca": "\u2936", "ldquo": "\u201C", "ldquor": "\u201E", "ldrdhar": "\u2967", "ldrushar": "\u294B", "ldsh": "\u21B2", "le": "\u2264", "lE": "\u2266", "LeftAngleBracket": "\u27E8", "leftarrow": "\u2190", "Leftarrow": "\u21D0", "LeftArrow": "\u2190", "LeftArrowBar": "\u21E4", "LeftArrowRightArrow": "\u21C6", "leftarrowtail": "\u21A2", "LeftCeiling": "\u2308", "LeftDoubleBracket": "\u27E6", "LeftDownTeeVector": "\u2961", "LeftDownVector": "\u21C3", "LeftDownVectorBar": "\u2959", "LeftFloor": "\u230A", "leftharpoondown": "\u21BD", "leftharpoonup": "\u21BC", "leftleftarrows": "\u21C7", "leftrightarrow": "\u2194", "Leftrightarrow": "\u21D4", "LeftRightArrow": "\u2194", "leftrightarrows": "\u21C6", "leftrightharpoons": "\u21CB", "leftrightsquigarrow": "\u21AD", "LeftRightVector": "\u294E", "LeftTee": "\u22A3", "LeftTeeArrow": "\u21A4", "LeftTeeVector": "\u295A", "leftthreetimes": "\u22CB", "LeftTriangle": "\u22B2", "LeftTriangleBar": "\u29CF", "LeftTriangleEqual": "\u22B4", "LeftUpDownVector": "\u2951", "LeftUpTeeVector": "\u2960", "LeftUpVector": "\u21BF", "LeftUpVectorBar": "\u2958", "LeftVector": "\u21BC", "LeftVectorBar": "\u2952", "leg": "\u22DA", "lEg": "\u2A8B", "leq": "\u2264", "leqq": "\u2266", "leqslant": "\u2A7D", "les": "\u2A7D", "lescc": "\u2AA8", "lesdot": "\u2A7F", "lesdoto": "\u2A81", "lesdotor": "\u2A83", "lesg": "\u22DA\uFE00", "lesges": "\u2A93", "lessapprox": "\u2A85", "lessdot": "\u22D6", "lesseqgtr": "\u22DA", "lesseqqgtr": "\u2A8B", "LessEqualGreater": "\u22DA", "LessFullEqual": "\u2266", "LessGreater": "\u2276", "lessgtr": "\u2276", "LessLess": "\u2AA1", "lesssim": "\u2272", "LessSlantEqual": "\u2A7D", "LessTilde": "\u2272", "lfisht": "\u297C", "lfloor": "\u230A", "lfr": "\u{1D529}", "Lfr": "\u{1D50F}", "lg": "\u2276", "lgE": "\u2A91", "lHar": "\u2962", "lhard": "\u21BD", "lharu": "\u21BC", "lharul": "\u296A", "lhblk": "\u2584", "ljcy": "\u0459", "LJcy": "\u0409", "ll": "\u226A", "Ll": "\u22D8", "llarr": "\u21C7", "llcorner": "\u231E", "Lleftarrow": "\u21DA", "llhard": "\u296B", "lltri": "\u25FA", "lmidot": "\u0140", "Lmidot": "\u013F", "lmoust": "\u23B0", "lmoustache": "\u23B0", "lnap": "\u2A89", "lnapprox": "\u2A89", "lne": "\u2A87", "lnE": "\u2268", "lneq": "\u2A87", "lneqq": "\u2268", "lnsim": "\u22E6", "loang": "\u27EC", "loarr": "\u21FD", "lobrk": "\u27E6", "longleftarrow": "\u27F5", "Longleftarrow": "\u27F8", "LongLeftArrow": "\u27F5", "longleftrightarrow": "\u27F7", "Longleftrightarrow": "\u27FA", "LongLeftRightArrow": "\u27F7", "longmapsto": "\u27FC", "longrightarrow": "\u27F6", "Longrightarrow": "\u27F9", "LongRightArrow": "\u27F6", "looparrowleft": "\u21AB", "looparrowright": "\u21AC", "lopar": "\u2985", "lopf": "\u{1D55D}", "Lopf": "\u{1D543}", "loplus": "\u2A2D", "lotimes": "\u2A34", "lowast": "\u2217", "lowbar": "_", "LowerLeftArrow": "\u2199", "LowerRightArrow": "\u2198", "loz": "\u25CA", "lozenge": "\u25CA", "lozf": "\u29EB", "lpar": "(", "lparlt": "\u2993", "lrarr": "\u21C6", "lrcorner": "\u231F", "lrhar": "\u21CB", "lrhard": "\u296D", "lrm": "\u200E", "lrtri": "\u22BF", "lsaquo": "\u2039", "lscr": "\u{1D4C1}", "Lscr": "\u2112", "lsh": "\u21B0", "Lsh": "\u21B0", "lsim": "\u2272", "lsime": "\u2A8D", "lsimg": "\u2A8F", "lsqb": "[", "lsquo": "\u2018", "lsquor": "\u201A", "lstrok": "\u0142", "Lstrok": "\u0141", "lt": "<", "Lt": "\u226A", "LT": "<", "ltcc": "\u2AA6", "ltcir": "\u2A79", "ltdot": "\u22D6", "lthree": "\u22CB", "ltimes": "\u22C9", "ltlarr": "\u2976", "ltquest": "\u2A7B", "ltri": "\u25C3", "ltrie": "\u22B4", "ltrif": "\u25C2", "ltrPar": "\u2996", "lurdshar": "\u294A", "luruhar": "\u2966", "lvertneqq": "\u2268\uFE00", "lvnE": "\u2268\uFE00", "macr": "\xAF", "male": "\u2642", "malt": "\u2720", "maltese": "\u2720", "map": "\u21A6", "Map": "\u2905", "mapsto": "\u21A6", "mapstodown": "\u21A7", "mapstoleft": "\u21A4", "mapstoup": "\u21A5", "marker": "\u25AE", "mcomma": "\u2A29", "mcy": "\u043C", "Mcy": "\u041C", "mdash": "\u2014", "mDDot": "\u223A", "measuredangle": "\u2221", "MediumSpace": "\u205F", "Mellintrf": "\u2133", "mfr": "\u{1D52A}", "Mfr": "\u{1D510}", "mho": "\u2127", "micro": "\xB5", "mid": "\u2223", "midast": "*", "midcir": "\u2AF0", "middot": "\xB7", "minus": "\u2212", "minusb": "\u229F", "minusd": "\u2238", "minusdu": "\u2A2A", "MinusPlus": "\u2213", "mlcp": "\u2ADB", "mldr": "\u2026", "mnplus": "\u2213", "models": "\u22A7", "mopf": "\u{1D55E}", "Mopf": "\u{1D544}", "mp": "\u2213", "mscr": "\u{1D4C2}", "Mscr": "\u2133", "mstpos": "\u223E", "mu": "\u03BC", "Mu": "\u039C", "multimap": "\u22B8", "mumap": "\u22B8", "nabla": "\u2207", "nacute": "\u0144", "Nacute": "\u0143", "nang": "\u2220\u20D2", "nap": "\u2249", "napE": "\u2A70\u0338", "napid": "\u224B\u0338", "napos": "\u0149", "napprox": "\u2249", "natur": "\u266E", "natural": "\u266E", "naturals": "\u2115", "nbsp": "\xA0", "nbump": "\u224E\u0338", "nbumpe": "\u224F\u0338", "ncap": "\u2A43", "ncaron": "\u0148", "Ncaron": "\u0147", "ncedil": "\u0146", "Ncedil": "\u0145", "ncong": "\u2247", "ncongdot": "\u2A6D\u0338", "ncup": "\u2A42", "ncy": "\u043D", "Ncy": "\u041D", "ndash": "\u2013", "ne": "\u2260", "nearhk": "\u2924", "nearr": "\u2197", "neArr": "\u21D7", "nearrow": "\u2197", "nedot": "\u2250\u0338", "NegativeMediumSpace": "\u200B", "NegativeThickSpace": "\u200B", "NegativeThinSpace": "\u200B", "NegativeVeryThinSpace": "\u200B", "nequiv": "\u2262", "nesear": "\u2928", "nesim": "\u2242\u0338", "NestedGreaterGreater": "\u226B", "NestedLessLess": "\u226A", "NewLine": "\n", "nexist": "\u2204", "nexists": "\u2204", "nfr": "\u{1D52B}", "Nfr": "\u{1D511}", "nge": "\u2271", "ngE": "\u2267\u0338", "ngeq": "\u2271", "ngeqq": "\u2267\u0338", "ngeqslant": "\u2A7E\u0338", "nges": "\u2A7E\u0338", "nGg": "\u22D9\u0338", "ngsim": "\u2275", "ngt": "\u226F", "nGt": "\u226B\u20D2", "ngtr": "\u226F", "nGtv": "\u226B\u0338", "nharr": "\u21AE", "nhArr": "\u21CE", "nhpar": "\u2AF2", "ni": "\u220B", "nis": "\u22FC", "nisd": "\u22FA", "niv": "\u220B", "njcy": "\u045A", "NJcy": "\u040A", "nlarr": "\u219A", "nlArr": "\u21CD", "nldr": "\u2025", "nle": "\u2270", "nlE": "\u2266\u0338", "nleftarrow": "\u219A", "nLeftarrow": "\u21CD", "nleftrightarrow": "\u21AE", "nLeftrightarrow": "\u21CE", "nleq": "\u2270", "nleqq": "\u2266\u0338", "nleqslant": "\u2A7D\u0338", "nles": "\u2A7D\u0338", "nless": "\u226E", "nLl": "\u22D8\u0338", "nlsim": "\u2274", "nlt": "\u226E", "nLt": "\u226A\u20D2", "nltri": "\u22EA", "nltrie": "\u22EC", "nLtv": "\u226A\u0338", "nmid": "\u2224", "NoBreak": "\u2060", "NonBreakingSpace": "\xA0", "nopf": "\u{1D55F}", "Nopf": "\u2115", "not": "\xAC", "Not": "\u2AEC", "NotCongruent": "\u2262", "NotCupCap": "\u226D", "NotDoubleVerticalBar": "\u2226", "NotElement": "\u2209", "NotEqual": "\u2260", "NotEqualTilde": "\u2242\u0338", "NotExists": "\u2204", "NotGreater": "\u226F", "NotGreaterEqual": "\u2271", "NotGreaterFullEqual": "\u2267\u0338", "NotGreaterGreater": "\u226B\u0338", "NotGreaterLess": "\u2279", "NotGreaterSlantEqual": "\u2A7E\u0338", "NotGreaterTilde": "\u2275", "NotHumpDownHump": "\u224E\u0338", "NotHumpEqual": "\u224F\u0338", "notin": "\u2209", "notindot": "\u22F5\u0338", "notinE": "\u22F9\u0338", "notinva": "\u2209", "notinvb": "\u22F7", "notinvc": "\u22F6", "NotLeftTriangle": "\u22EA", "NotLeftTriangleBar": "\u29CF\u0338", "NotLeftTriangleEqual": "\u22EC", "NotLess": "\u226E", "NotLessEqual": "\u2270", "NotLessGreater": "\u2278", "NotLessLess": "\u226A\u0338", "NotLessSlantEqual": "\u2A7D\u0338", "NotLessTilde": "\u2274", "NotNestedGreaterGreater": "\u2AA2\u0338", "NotNestedLessLess": "\u2AA1\u0338", "notni": "\u220C", "notniva": "\u220C", "notnivb": "\u22FE", "notnivc": "\u22FD", "NotPrecedes": "\u2280", "NotPrecedesEqual": "\u2AAF\u0338", "NotPrecedesSlantEqual": "\u22E0", "NotReverseElement": "\u220C", "NotRightTriangle": "\u22EB", "NotRightTriangleBar": "\u29D0\u0338", "NotRightTriangleEqual": "\u22ED", "NotSquareSubset": "\u228F\u0338", "NotSquareSubsetEqual": "\u22E2", "NotSquareSuperset": "\u2290\u0338", "NotSquareSupersetEqual": "\u22E3", "NotSubset": "\u2282\u20D2", "NotSubsetEqual": "\u2288", "NotSucceeds": "\u2281", "NotSucceedsEqual": "\u2AB0\u0338", "NotSucceedsSlantEqual": "\u22E1", "NotSucceedsTilde": "\u227F\u0338", "NotSuperset": "\u2283\u20D2", "NotSupersetEqual": "\u2289", "NotTilde": "\u2241", "NotTildeEqual": "\u2244", "NotTildeFullEqual": "\u2247", "NotTildeTilde": "\u2249", "NotVerticalBar": "\u2224", "npar": "\u2226", "nparallel": "\u2226", "nparsl": "\u2AFD\u20E5", "npart": "\u2202\u0338", "npolint": "\u2A14", "npr": "\u2280", "nprcue": "\u22E0", "npre": "\u2AAF\u0338", "nprec": "\u2280", "npreceq": "\u2AAF\u0338", "nrarr": "\u219B", "nrArr": "\u21CF", "nrarrc": "\u2933\u0338", "nrarrw": "\u219D\u0338", "nrightarrow": "\u219B", "nRightarrow": "\u21CF", "nrtri": "\u22EB", "nrtrie": "\u22ED", "nsc": "\u2281", "nsccue": "\u22E1", "nsce": "\u2AB0\u0338", "nscr": "\u{1D4C3}", "Nscr": "\u{1D4A9}", "nshortmid": "\u2224", "nshortparallel": "\u2226", "nsim": "\u2241", "nsime": "\u2244", "nsimeq": "\u2244", "nsmid": "\u2224", "nspar": "\u2226", "nsqsube": "\u22E2", "nsqsupe": "\u22E3", "nsub": "\u2284", "nsube": "\u2288", "nsubE": "\u2AC5\u0338", "nsubset": "\u2282\u20D2", "nsubseteq": "\u2288", "nsubseteqq": "\u2AC5\u0338", "nsucc": "\u2281", "nsucceq": "\u2AB0\u0338", "nsup": "\u2285", "nsupe": "\u2289", "nsupE": "\u2AC6\u0338", "nsupset": "\u2283\u20D2", "nsupseteq": "\u2289", "nsupseteqq": "\u2AC6\u0338", "ntgl": "\u2279", "ntilde": "\xF1", "Ntilde": "\xD1", "ntlg": "\u2278", "ntriangleleft": "\u22EA", "ntrianglelefteq": "\u22EC", "ntriangleright": "\u22EB", "ntrianglerighteq": "\u22ED", "nu": "\u03BD", "Nu": "\u039D", "num": "#", "numero": "\u2116", "numsp": "\u2007", "nvap": "\u224D\u20D2", "nvdash": "\u22AC", "nvDash": "\u22AD", "nVdash": "\u22AE", "nVDash": "\u22AF", "nvge": "\u2265\u20D2", "nvgt": ">\u20D2", "nvHarr": "\u2904", "nvinfin": "\u29DE", "nvlArr": "\u2902", "nvle": "\u2264\u20D2", "nvlt": "<\u20D2", "nvltrie": "\u22B4\u20D2", "nvrArr": "\u2903", "nvrtrie": "\u22B5\u20D2", "nvsim": "\u223C\u20D2", "nwarhk": "\u2923", "nwarr": "\u2196", "nwArr": "\u21D6", "nwarrow": "\u2196", "nwnear": "\u2927", "oacute": "\xF3", "Oacute": "\xD3", "oast": "\u229B", "ocir": "\u229A", "ocirc": "\xF4", "Ocirc": "\xD4", "ocy": "\u043E", "Ocy": "\u041E", "odash": "\u229D", "odblac": "\u0151", "Odblac": "\u0150", "odiv": "\u2A38", "odot": "\u2299", "odsold": "\u29BC", "oelig": "\u0153", "OElig": "\u0152", "ofcir": "\u29BF", "ofr": "\u{1D52C}", "Ofr": "\u{1D512}", "ogon": "\u02DB", "ograve": "\xF2", "Ograve": "\xD2", "ogt": "\u29C1", "ohbar": "\u29B5", "ohm": "\u03A9", "oint": "\u222E", "olarr": "\u21BA", "olcir": "\u29BE", "olcross": "\u29BB", "oline": "\u203E", "olt": "\u29C0", "omacr": "\u014D", "Omacr": "\u014C", "omega": "\u03C9", "Omega": "\u03A9", "omicron": "\u03BF", "Omicron": "\u039F", "omid": "\u29B6", "ominus": "\u2296", "oopf": "\u{1D560}", "Oopf": "\u{1D546}", "opar": "\u29B7", "OpenCurlyDoubleQuote": "\u201C", "OpenCurlyQuote": "\u2018", "operp": "\u29B9", "oplus": "\u2295", "or": "\u2228", "Or": "\u2A54", "orarr": "\u21BB", "ord": "\u2A5D", "order": "\u2134", "orderof": "\u2134", "ordf": "\xAA", "ordm": "\xBA", "origof": "\u22B6", "oror": "\u2A56", "orslope": "\u2A57", "orv": "\u2A5B", "oS": "\u24C8", "oscr": "\u2134", "Oscr": "\u{1D4AA}", "oslash": "\xF8", "Oslash": "\xD8", "osol": "\u2298", "otilde": "\xF5", "Otilde": "\xD5", "otimes": "\u2297", "Otimes": "\u2A37", "otimesas": "\u2A36", "ouml": "\xF6", "Ouml": "\xD6", "ovbar": "\u233D", "OverBar": "\u203E", "OverBrace": "\u23DE", "OverBracket": "\u23B4", "OverParenthesis": "\u23DC", "par": "\u2225", "para": "\xB6", "parallel": "\u2225", "parsim": "\u2AF3", "parsl": "\u2AFD", "part": "\u2202", "PartialD": "\u2202", "pcy": "\u043F", "Pcy": "\u041F", "percnt": "%", "period": ".", "permil": "\u2030", "perp": "\u22A5", "pertenk": "\u2031", "pfr": "\u{1D52D}", "Pfr": "\u{1D513}", "phi": "\u03C6", "Phi": "\u03A6", "phiv": "\u03D5", "phmmat": "\u2133", "phone": "\u260E", "pi": "\u03C0", "Pi": "\u03A0", "pitchfork": "\u22D4", "piv": "\u03D6", "planck": "\u210F", "planckh": "\u210E", "plankv": "\u210F", "plus": "+", "plusacir": "\u2A23", "plusb": "\u229E", "pluscir": "\u2A22", "plusdo": "\u2214", "plusdu": "\u2A25", "pluse": "\u2A72", "PlusMinus": "\xB1", "plusmn": "\xB1", "plussim": "\u2A26", "plustwo": "\u2A27", "pm": "\xB1", "Poincareplane": "\u210C", "pointint": "\u2A15", "popf": "\u{1D561}", "Popf": "\u2119", "pound": "\xA3", "pr": "\u227A", "Pr": "\u2ABB", "prap": "\u2AB7", "prcue": "\u227C", "pre": "\u2AAF", "prE": "\u2AB3", "prec": "\u227A", "precapprox": "\u2AB7", "preccurlyeq": "\u227C", "Precedes": "\u227A", "PrecedesEqual": "\u2AAF", "PrecedesSlantEqual": "\u227C", "PrecedesTilde": "\u227E", "preceq": "\u2AAF", "precnapprox": "\u2AB9", "precneqq": "\u2AB5", "precnsim": "\u22E8", "precsim": "\u227E", "prime": "\u2032", "Prime": "\u2033", "primes": "\u2119", "prnap": "\u2AB9", "prnE": "\u2AB5", "prnsim": "\u22E8", "prod": "\u220F", "Product": "\u220F", "profalar": "\u232E", "profline": "\u2312", "profsurf": "\u2313", "prop": "\u221D", "Proportion": "\u2237", "Proportional": "\u221D", "propto": "\u221D", "prsim": "\u227E", "prurel": "\u22B0", "pscr": "\u{1D4C5}", "Pscr": "\u{1D4AB}", "psi": "\u03C8", "Psi": "\u03A8", "puncsp": "\u2008", "qfr": "\u{1D52E}", "Qfr": "\u{1D514}", "qint": "\u2A0C", "qopf": "\u{1D562}", "Qopf": "\u211A", "qprime": "\u2057", "qscr": "\u{1D4C6}", "Qscr": "\u{1D4AC}", "quaternions": "\u210D", "quatint": "\u2A16", "quest": "?", "questeq": "\u225F", "quot": '"', "QUOT": '"', "rAarr": "\u21DB", "race": "\u223D\u0331", "racute": "\u0155", "Racute": "\u0154", "radic": "\u221A", "raemptyv": "\u29B3", "rang": "\u27E9", "Rang": "\u27EB", "rangd": "\u2992", "range": "\u29A5", "rangle": "\u27E9", "raquo": "\xBB", "rarr": "\u2192", "rArr": "\u21D2", "Rarr": "\u21A0", "rarrap": "\u2975", "rarrb": "\u21E5", "rarrbfs": "\u2920", "rarrc": "\u2933", "rarrfs": "\u291E", "rarrhk": "\u21AA", "rarrlp": "\u21AC", "rarrpl": "\u2945", "rarrsim": "\u2974", "rarrtl": "\u21A3", "Rarrtl": "\u2916", "rarrw": "\u219D", "ratail": "\u291A", "rAtail": "\u291C", "ratio": "\u2236", "rationals": "\u211A", "rbarr": "\u290D", "rBarr": "\u290F", "RBarr": "\u2910", "rbbrk": "\u2773", "rbrace": "}", "rbrack": "]", "rbrke": "\u298C", "rbrksld": "\u298E", "rbrkslu": "\u2990", "rcaron": "\u0159", "Rcaron": "\u0158", "rcedil": "\u0157", "Rcedil": "\u0156", "rceil": "\u2309", "rcub": "}", "rcy": "\u0440", "Rcy": "\u0420", "rdca": "\u2937", "rdldhar": "\u2969", "rdquo": "\u201D", "rdquor": "\u201D", "rdsh": "\u21B3", "Re": "\u211C", "real": "\u211C", "realine": "\u211B", "realpart": "\u211C", "reals": "\u211D", "rect": "\u25AD", "reg": "\xAE", "REG": "\xAE", "ReverseElement": "\u220B", "ReverseEquilibrium": "\u21CB", "ReverseUpEquilibrium": "\u296F", "rfisht": "\u297D", "rfloor": "\u230B", "rfr": "\u{1D52F}", "Rfr": "\u211C", "rHar": "\u2964", "rhard": "\u21C1", "rharu": "\u21C0", "rharul": "\u296C", "rho": "\u03C1", "Rho": "\u03A1", "rhov": "\u03F1", "RightAngleBracket": "\u27E9", "rightarrow": "\u2192", "Rightarrow": "\u21D2", "RightArrow": "\u2192", "RightArrowBar": "\u21E5", "RightArrowLeftArrow": "\u21C4", "rightarrowtail": "\u21A3", "RightCeiling": "\u2309", "RightDoubleBracket": "\u27E7", "RightDownTeeVector": "\u295D", "RightDownVector": "\u21C2", "RightDownVectorBar": "\u2955", "RightFloor": "\u230B", "rightharpoondown": "\u21C1", "rightharpoonup": "\u21C0", "rightleftarrows": "\u21C4", "rightleftharpoons": "\u21CC", "rightrightarrows": "\u21C9", "rightsquigarrow": "\u219D", "RightTee": "\u22A2", "RightTeeArrow": "\u21A6", "RightTeeVector": "\u295B", "rightthreetimes": "\u22CC", "RightTriangle": "\u22B3", "RightTriangleBar": "\u29D0", "RightTriangleEqual": "\u22B5", "RightUpDownVector": "\u294F", "RightUpTeeVector": "\u295C", "RightUpVector": "\u21BE", "RightUpVectorBar": "\u2954", "RightVector": "\u21C0", "RightVectorBar": "\u2953", "ring": "\u02DA", "risingdotseq": "\u2253", "rlarr": "\u21C4", "rlhar": "\u21CC", "rlm": "\u200F", "rmoust": "\u23B1", "rmoustache": "\u23B1", "rnmid": "\u2AEE", "roang": "\u27ED", "roarr": "\u21FE", "robrk": "\u27E7", "ropar": "\u2986", "ropf": "\u{1D563}", "Ropf": "\u211D", "roplus": "\u2A2E", "rotimes": "\u2A35", "RoundImplies": "\u2970", "rpar": ")", "rpargt": "\u2994", "rppolint": "\u2A12", "rrarr": "\u21C9", "Rrightarrow": "\u21DB", "rsaquo": "\u203A", "rscr": "\u{1D4C7}", "Rscr": "\u211B", "rsh": "\u21B1", "Rsh": "\u21B1", "rsqb": "]", "rsquo": "\u2019", "rsquor": "\u2019", "rthree": "\u22CC", "rtimes": "\u22CA", "rtri": "\u25B9", "rtrie": "\u22B5", "rtrif": "\u25B8", "rtriltri": "\u29CE", "RuleDelayed": "\u29F4", "ruluhar": "\u2968", "rx": "\u211E", "sacute": "\u015B", "Sacute": "\u015A", "sbquo": "\u201A", "sc": "\u227B", "Sc": "\u2ABC", "scap": "\u2AB8", "scaron": "\u0161", "Scaron": "\u0160", "sccue": "\u227D", "sce": "\u2AB0", "scE": "\u2AB4", "scedil": "\u015F", "Scedil": "\u015E", "scirc": "\u015D", "Scirc": "\u015C", "scnap": "\u2ABA", "scnE": "\u2AB6", "scnsim": "\u22E9", "scpolint": "\u2A13", "scsim": "\u227F", "scy": "\u0441", "Scy": "\u0421", "sdot": "\u22C5", "sdotb": "\u22A1", "sdote": "\u2A66", "searhk": "\u2925", "searr": "\u2198", "seArr": "\u21D8", "searrow": "\u2198", "sect": "\xA7", "semi": ";", "seswar": "\u2929", "setminus": "\u2216", "setmn": "\u2216", "sext": "\u2736", "sfr": "\u{1D530}", "Sfr": "\u{1D516}", "sfrown": "\u2322", "sharp": "\u266F", "shchcy": "\u0449", "SHCHcy": "\u0429", "shcy": "\u0448", "SHcy": "\u0428", "ShortDownArrow": "\u2193", "ShortLeftArrow": "\u2190", "shortmid": "\u2223", "shortparallel": "\u2225", "ShortRightArrow": "\u2192", "ShortUpArrow": "\u2191", "shy": "\xAD", "sigma": "\u03C3", "Sigma": "\u03A3", "sigmaf": "\u03C2", "sigmav": "\u03C2", "sim": "\u223C", "simdot": "\u2A6A", "sime": "\u2243", "simeq": "\u2243", "simg": "\u2A9E", "simgE": "\u2AA0", "siml": "\u2A9D", "simlE": "\u2A9F", "simne": "\u2246", "simplus": "\u2A24", "simrarr": "\u2972", "slarr": "\u2190", "SmallCircle": "\u2218", "smallsetminus": "\u2216", "smashp": "\u2A33", "smeparsl": "\u29E4", "smid": "\u2223", "smile": "\u2323", "smt": "\u2AAA", "smte": "\u2AAC", "smtes": "\u2AAC\uFE00", "softcy": "\u044C", "SOFTcy": "\u042C", "sol": "/", "solb": "\u29C4", "solbar": "\u233F", "sopf": "\u{1D564}", "Sopf": "\u{1D54A}", "spades": "\u2660", "spadesuit": "\u2660", "spar": "\u2225", "sqcap": "\u2293", "sqcaps": "\u2293\uFE00", "sqcup": "\u2294", "sqcups": "\u2294\uFE00", "Sqrt": "\u221A", "sqsub": "\u228F", "sqsube": "\u2291", "sqsubset": "\u228F", "sqsubseteq": "\u2291", "sqsup": "\u2290", "sqsupe": "\u2292", "sqsupset": "\u2290", "sqsupseteq": "\u2292", "squ": "\u25A1", "square": "\u25A1", "Square": "\u25A1", "SquareIntersection": "\u2293", "SquareSubset": "\u228F", "SquareSubsetEqual": "\u2291", "SquareSuperset": "\u2290", "SquareSupersetEqual": "\u2292", "SquareUnion": "\u2294", "squarf": "\u25AA", "squf": "\u25AA", "srarr": "\u2192", "sscr": "\u{1D4C8}", "Sscr": "\u{1D4AE}", "ssetmn": "\u2216", "ssmile": "\u2323", "sstarf": "\u22C6", "star": "\u2606", "Star": "\u22C6", "starf": "\u2605", "straightepsilon": "\u03F5", "straightphi": "\u03D5", "strns": "\xAF", "sub": "\u2282", "Sub": "\u22D0", "subdot": "\u2ABD", "sube": "\u2286", "subE": "\u2AC5", "subedot": "\u2AC3", "submult": "\u2AC1", "subne": "\u228A", "subnE": "\u2ACB", "subplus": "\u2ABF", "subrarr": "\u2979", "subset": "\u2282", "Subset": "\u22D0", "subseteq": "\u2286", "subseteqq": "\u2AC5", "SubsetEqual": "\u2286", "subsetneq": "\u228A", "subsetneqq": "\u2ACB", "subsim": "\u2AC7", "subsub": "\u2AD5", "subsup": "\u2AD3", "succ": "\u227B", "succapprox": "\u2AB8", "succcurlyeq": "\u227D", "Succeeds": "\u227B", "SucceedsEqual": "\u2AB0", "SucceedsSlantEqual": "\u227D", "SucceedsTilde": "\u227F", "succeq": "\u2AB0", "succnapprox": "\u2ABA", "succneqq": "\u2AB6", "succnsim": "\u22E9", "succsim": "\u227F", "SuchThat": "\u220B", "sum": "\u2211", "Sum": "\u2211", "sung": "\u266A", "sup": "\u2283", "Sup": "\u22D1", "sup1": "\xB9", "sup2": "\xB2", "sup3": "\xB3", "supdot": "\u2ABE", "supdsub": "\u2AD8", "supe": "\u2287", "supE": "\u2AC6", "supedot": "\u2AC4", "Superset": "\u2283", "SupersetEqual": "\u2287", "suphsol": "\u27C9", "suphsub": "\u2AD7", "suplarr": "\u297B", "supmult": "\u2AC2", "supne": "\u228B", "supnE": "\u2ACC", "supplus": "\u2AC0", "supset": "\u2283", "Supset": "\u22D1", "supseteq": "\u2287", "supseteqq": "\u2AC6", "supsetneq": "\u228B", "supsetneqq": "\u2ACC", "supsim": "\u2AC8", "supsub": "\u2AD4", "supsup": "\u2AD6", "swarhk": "\u2926", "swarr": "\u2199", "swArr": "\u21D9", "swarrow": "\u2199", "swnwar": "\u292A", "szlig": "\xDF", "Tab": "	", "target": "\u2316", "tau": "\u03C4", "Tau": "\u03A4", "tbrk": "\u23B4", "tcaron": "\u0165", "Tcaron": "\u0164", "tcedil": "\u0163", "Tcedil": "\u0162", "tcy": "\u0442", "Tcy": "\u0422", "tdot": "\u20DB", "telrec": "\u2315", "tfr": "\u{1D531}", "Tfr": "\u{1D517}", "there4": "\u2234", "therefore": "\u2234", "Therefore": "\u2234", "theta": "\u03B8", "Theta": "\u0398", "thetasym": "\u03D1", "thetav": "\u03D1", "thickapprox": "\u2248", "thicksim": "\u223C", "ThickSpace": "\u205F\u200A", "thinsp": "\u2009", "ThinSpace": "\u2009", "thkap": "\u2248", "thksim": "\u223C", "thorn": "\xFE", "THORN": "\xDE", "tilde": "\u02DC", "Tilde": "\u223C", "TildeEqual": "\u2243", "TildeFullEqual": "\u2245", "TildeTilde": "\u2248", "times": "\xD7", "timesb": "\u22A0", "timesbar": "\u2A31", "timesd": "\u2A30", "tint": "\u222D", "toea": "\u2928", "top": "\u22A4", "topbot": "\u2336", "topcir": "\u2AF1", "topf": "\u{1D565}", "Topf": "\u{1D54B}", "topfork": "\u2ADA", "tosa": "\u2929", "tprime": "\u2034", "trade": "\u2122", "TRADE": "\u2122", "triangle": "\u25B5", "triangledown": "\u25BF", "triangleleft": "\u25C3", "trianglelefteq": "\u22B4", "triangleq": "\u225C", "triangleright": "\u25B9", "trianglerighteq": "\u22B5", "tridot": "\u25EC", "trie": "\u225C", "triminus": "\u2A3A", "TripleDot": "\u20DB", "triplus": "\u2A39", "trisb": "\u29CD", "tritime": "\u2A3B", "trpezium": "\u23E2", "tscr": "\u{1D4C9}", "Tscr": "\u{1D4AF}", "tscy": "\u0446", "TScy": "\u0426", "tshcy": "\u045B", "TSHcy": "\u040B", "tstrok": "\u0167", "Tstrok": "\u0166", "twixt": "\u226C", "twoheadleftarrow": "\u219E", "twoheadrightarrow": "\u21A0", "uacute": "\xFA", "Uacute": "\xDA", "uarr": "\u2191", "uArr": "\u21D1", "Uarr": "\u219F", "Uarrocir": "\u2949", "ubrcy": "\u045E", "Ubrcy": "\u040E", "ubreve": "\u016D", "Ubreve": "\u016C", "ucirc": "\xFB", "Ucirc": "\xDB", "ucy": "\u0443", "Ucy": "\u0423", "udarr": "\u21C5", "udblac": "\u0171", "Udblac": "\u0170", "udhar": "\u296E", "ufisht": "\u297E", "ufr": "\u{1D532}", "Ufr": "\u{1D518}", "ugrave": "\xF9", "Ugrave": "\xD9", "uHar": "\u2963", "uharl": "\u21BF", "uharr": "\u21BE", "uhblk": "\u2580", "ulcorn": "\u231C", "ulcorner": "\u231C", "ulcrop": "\u230F", "ultri": "\u25F8", "umacr": "\u016B", "Umacr": "\u016A", "uml": "\xA8", "UnderBar": "_", "UnderBrace": "\u23DF", "UnderBracket": "\u23B5", "UnderParenthesis": "\u23DD", "Union": "\u22C3", "UnionPlus": "\u228E", "uogon": "\u0173", "Uogon": "\u0172", "uopf": "\u{1D566}", "Uopf": "\u{1D54C}", "uparrow": "\u2191", "Uparrow": "\u21D1", "UpArrow": "\u2191", "UpArrowBar": "\u2912", "UpArrowDownArrow": "\u21C5", "updownarrow": "\u2195", "Updownarrow": "\u21D5", "UpDownArrow": "\u2195", "UpEquilibrium": "\u296E", "upharpoonleft": "\u21BF", "upharpoonright": "\u21BE", "uplus": "\u228E", "UpperLeftArrow": "\u2196", "UpperRightArrow": "\u2197", "upsi": "\u03C5", "Upsi": "\u03D2", "upsih": "\u03D2", "upsilon": "\u03C5", "Upsilon": "\u03A5", "UpTee": "\u22A5", "UpTeeArrow": "\u21A5", "upuparrows": "\u21C8", "urcorn": "\u231D", "urcorner": "\u231D", "urcrop": "\u230E", "uring": "\u016F", "Uring": "\u016E", "urtri": "\u25F9", "uscr": "\u{1D4CA}", "Uscr": "\u{1D4B0}", "utdot": "\u22F0", "utilde": "\u0169", "Utilde": "\u0168", "utri": "\u25B5", "utrif": "\u25B4", "uuarr": "\u21C8", "uuml": "\xFC", "Uuml": "\xDC", "uwangle": "\u29A7", "vangrt": "\u299C", "varepsilon": "\u03F5", "varkappa": "\u03F0", "varnothing": "\u2205", "varphi": "\u03D5", "varpi": "\u03D6", "varpropto": "\u221D", "varr": "\u2195", "vArr": "\u21D5", "varrho": "\u03F1", "varsigma": "\u03C2", "varsubsetneq": "\u228A\uFE00", "varsubsetneqq": "\u2ACB\uFE00", "varsupsetneq": "\u228B\uFE00", "varsupsetneqq": "\u2ACC\uFE00", "vartheta": "\u03D1", "vartriangleleft": "\u22B2", "vartriangleright": "\u22B3", "vBar": "\u2AE8", "Vbar": "\u2AEB", "vBarv": "\u2AE9", "vcy": "\u0432", "Vcy": "\u0412", "vdash": "\u22A2", "vDash": "\u22A8", "Vdash": "\u22A9", "VDash": "\u22AB", "Vdashl": "\u2AE6", "vee": "\u2228", "Vee": "\u22C1", "veebar": "\u22BB", "veeeq": "\u225A", "vellip": "\u22EE", "verbar": "|", "Verbar": "\u2016", "vert": "|", "Vert": "\u2016", "VerticalBar": "\u2223", "VerticalLine": "|", "VerticalSeparator": "\u2758", "VerticalTilde": "\u2240", "VeryThinSpace": "\u200A", "vfr": "\u{1D533}", "Vfr": "\u{1D519}", "vltri": "\u22B2", "vnsub": "\u2282\u20D2", "vnsup": "\u2283\u20D2", "vopf": "\u{1D567}", "Vopf": "\u{1D54D}", "vprop": "\u221D", "vrtri": "\u22B3", "vscr": "\u{1D4CB}", "Vscr": "\u{1D4B1}", "vsubne": "\u228A\uFE00", "vsubnE": "\u2ACB\uFE00", "vsupne": "\u228B\uFE00", "vsupnE": "\u2ACC\uFE00", "Vvdash": "\u22AA", "vzigzag": "\u299A", "wcirc": "\u0175", "Wcirc": "\u0174", "wedbar": "\u2A5F", "wedge": "\u2227", "Wedge": "\u22C0", "wedgeq": "\u2259", "weierp": "\u2118", "wfr": "\u{1D534}", "Wfr": "\u{1D51A}", "wopf": "\u{1D568}", "Wopf": "\u{1D54E}", "wp": "\u2118", "wr": "\u2240", "wreath": "\u2240", "wscr": "\u{1D4CC}", "Wscr": "\u{1D4B2}", "xcap": "\u22C2", "xcirc": "\u25EF", "xcup": "\u22C3", "xdtri": "\u25BD", "xfr": "\u{1D535}", "Xfr": "\u{1D51B}", "xharr": "\u27F7", "xhArr": "\u27FA", "xi": "\u03BE", "Xi": "\u039E", "xlarr": "\u27F5", "xlArr": "\u27F8", "xmap": "\u27FC", "xnis": "\u22FB", "xodot": "\u2A00", "xopf": "\u{1D569}", "Xopf": "\u{1D54F}", "xoplus": "\u2A01", "xotime": "\u2A02", "xrarr": "\u27F6", "xrArr": "\u27F9", "xscr": "\u{1D4CD}", "Xscr": "\u{1D4B3}", "xsqcup": "\u2A06", "xuplus": "\u2A04", "xutri": "\u25B3", "xvee": "\u22C1", "xwedge": "\u22C0", "yacute": "\xFD", "Yacute": "\xDD", "yacy": "\u044F", "YAcy": "\u042F", "ycirc": "\u0177", "Ycirc": "\u0176", "ycy": "\u044B", "Ycy": "\u042B", "yen": "\xA5", "yfr": "\u{1D536}", "Yfr": "\u{1D51C}", "yicy": "\u0457", "YIcy": "\u0407", "yopf": "\u{1D56A}", "Yopf": "\u{1D550}", "yscr": "\u{1D4CE}", "Yscr": "\u{1D4B4}", "yucy": "\u044E", "YUcy": "\u042E", "yuml": "\xFF", "Yuml": "\u0178", "zacute": "\u017A", "Zacute": "\u0179", "zcaron": "\u017E", "Zcaron": "\u017D", "zcy": "\u0437", "Zcy": "\u0417", "zdot": "\u017C", "Zdot": "\u017B", "zeetrf": "\u2128", "ZeroWidthSpace": "\u200B", "zeta": "\u03B6", "Zeta": "\u0396", "zfr": "\u{1D537}", "Zfr": "\u2128", "zhcy": "\u0436", "ZHcy": "\u0416", "zigrarr": "\u21DD", "zopf": "\u{1D56B}", "Zopf": "\u2124", "zscr": "\u{1D4CF}", "Zscr": "\u{1D4B5}", "zwj": "\u200D", "zwnj": "\u200C" };
            var decodeMapLegacy = { "aacute": "\xE1", "Aacute": "\xC1", "acirc": "\xE2", "Acirc": "\xC2", "acute": "\xB4", "aelig": "\xE6", "AElig": "\xC6", "agrave": "\xE0", "Agrave": "\xC0", "amp": "&", "AMP": "&", "aring": "\xE5", "Aring": "\xC5", "atilde": "\xE3", "Atilde": "\xC3", "auml": "\xE4", "Auml": "\xC4", "brvbar": "\xA6", "ccedil": "\xE7", "Ccedil": "\xC7", "cedil": "\xB8", "cent": "\xA2", "copy": "\xA9", "COPY": "\xA9", "curren": "\xA4", "deg": "\xB0", "divide": "\xF7", "eacute": "\xE9", "Eacute": "\xC9", "ecirc": "\xEA", "Ecirc": "\xCA", "egrave": "\xE8", "Egrave": "\xC8", "eth": "\xF0", "ETH": "\xD0", "euml": "\xEB", "Euml": "\xCB", "frac12": "\xBD", "frac14": "\xBC", "frac34": "\xBE", "gt": ">", "GT": ">", "iacute": "\xED", "Iacute": "\xCD", "icirc": "\xEE", "Icirc": "\xCE", "iexcl": "\xA1", "igrave": "\xEC", "Igrave": "\xCC", "iquest": "\xBF", "iuml": "\xEF", "Iuml": "\xCF", "laquo": "\xAB", "lt": "<", "LT": "<", "macr": "\xAF", "micro": "\xB5", "middot": "\xB7", "nbsp": "\xA0", "not": "\xAC", "ntilde": "\xF1", "Ntilde": "\xD1", "oacute": "\xF3", "Oacute": "\xD3", "ocirc": "\xF4", "Ocirc": "\xD4", "ograve": "\xF2", "Ograve": "\xD2", "ordf": "\xAA", "ordm": "\xBA", "oslash": "\xF8", "Oslash": "\xD8", "otilde": "\xF5", "Otilde": "\xD5", "ouml": "\xF6", "Ouml": "\xD6", "para": "\xB6", "plusmn": "\xB1", "pound": "\xA3", "quot": '"', "QUOT": '"', "raquo": "\xBB", "reg": "\xAE", "REG": "\xAE", "sect": "\xA7", "shy": "\xAD", "sup1": "\xB9", "sup2": "\xB2", "sup3": "\xB3", "szlig": "\xDF", "thorn": "\xFE", "THORN": "\xDE", "times": "\xD7", "uacute": "\xFA", "Uacute": "\xDA", "ucirc": "\xFB", "Ucirc": "\xDB", "ugrave": "\xF9", "Ugrave": "\xD9", "uml": "\xA8", "uuml": "\xFC", "Uuml": "\xDC", "yacute": "\xFD", "Yacute": "\xDD", "yen": "\xA5", "yuml": "\xFF" };
            var decodeMapNumeric = { "0": "\uFFFD", "128": "\u20AC", "130": "\u201A", "131": "\u0192", "132": "\u201E", "133": "\u2026", "134": "\u2020", "135": "\u2021", "136": "\u02C6", "137": "\u2030", "138": "\u0160", "139": "\u2039", "140": "\u0152", "142": "\u017D", "145": "\u2018", "146": "\u2019", "147": "\u201C", "148": "\u201D", "149": "\u2022", "150": "\u2013", "151": "\u2014", "152": "\u02DC", "153": "\u2122", "154": "\u0161", "155": "\u203A", "156": "\u0153", "158": "\u017E", "159": "\u0178" };
            var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
            var stringFromCharCode = String.fromCharCode;
            var object = {};
            var hasOwnProperty2 = object.hasOwnProperty;
            var has = function(object2, propertyName) {
              return hasOwnProperty2.call(object2, propertyName);
            };
            var contains = function(array2, value) {
              var index = -1;
              var length = array2.length;
              while (++index < length) {
                if (array2[index] == value) {
                  return true;
                }
              }
              return false;
            };
            var merge2 = function(options, defaults) {
              if (!options) {
                return defaults;
              }
              var result = {};
              var key2;
              for (key2 in defaults) {
                result[key2] = has(options, key2) ? options[key2] : defaults[key2];
              }
              return result;
            };
            var codePointToSymbol = function(codePoint, strict) {
              var output = "";
              if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
                if (strict) {
                  parseError("character reference outside the permissible Unicode range");
                }
                return "\uFFFD";
              }
              if (has(decodeMapNumeric, codePoint)) {
                if (strict) {
                  parseError("disallowed character reference");
                }
                return decodeMapNumeric[codePoint];
              }
              if (strict && contains(invalidReferenceCodePoints, codePoint)) {
                parseError("disallowed character reference");
              }
              if (codePoint > 65535) {
                codePoint -= 65536;
                output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
                codePoint = 56320 | codePoint & 1023;
              }
              output += stringFromCharCode(codePoint);
              return output;
            };
            var hexEscape = function(codePoint) {
              return "&#x" + codePoint.toString(16).toUpperCase() + ";";
            };
            var decEscape = function(codePoint) {
              return "&#" + codePoint + ";";
            };
            var parseError = function(message) {
              throw Error("Parse error: " + message);
            };
            var encode2 = function(string, options) {
              options = merge2(options, encode2.options);
              var strict = options.strict;
              if (strict && regexInvalidRawCodePoint.test(string)) {
                parseError("forbidden code point");
              }
              var encodeEverything = options.encodeEverything;
              var useNamedReferences = options.useNamedReferences;
              var allowUnsafeSymbols = options.allowUnsafeSymbols;
              var escapeCodePoint = options.decimal ? decEscape : hexEscape;
              var escapeBmpSymbol = function(symbol) {
                return escapeCodePoint(symbol.charCodeAt(0));
              };
              if (encodeEverything) {
                string = string.replace(regexAsciiWhitelist, function(symbol) {
                  if (useNamedReferences && has(encodeMap, symbol)) {
                    return "&" + encodeMap[symbol] + ";";
                  }
                  return escapeBmpSymbol(symbol);
                });
                if (useNamedReferences) {
                  string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
                }
                if (useNamedReferences) {
                  string = string.replace(regexEncodeNonAscii, function(string2) {
                    return "&" + encodeMap[string2] + ";";
                  });
                }
              } else if (useNamedReferences) {
                if (!allowUnsafeSymbols) {
                  string = string.replace(regexEscape, function(string2) {
                    return "&" + encodeMap[string2] + ";";
                  });
                }
                string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
                string = string.replace(regexEncodeNonAscii, function(string2) {
                  return "&" + encodeMap[string2] + ";";
                });
              } else if (!allowUnsafeSymbols) {
                string = string.replace(regexEscape, escapeBmpSymbol);
              }
              return string.replace(regexAstralSymbols, function($0) {
                var high = $0.charCodeAt(0);
                var low = $0.charCodeAt(1);
                var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
                return escapeCodePoint(codePoint);
              }).replace(regexBmpWhitelist, escapeBmpSymbol);
            };
            encode2.options = {
              "allowUnsafeSymbols": false,
              "encodeEverything": false,
              "strict": false,
              "useNamedReferences": false,
              "decimal": false
            };
            var decode = function(html3, options) {
              options = merge2(options, decode.options);
              var strict = options.strict;
              if (strict && regexInvalidEntity.test(html3)) {
                parseError("malformed character reference");
              }
              return html3.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
                var codePoint;
                var semicolon;
                var decDigits;
                var hexDigits;
                var reference;
                var next;
                if ($1) {
                  reference = $1;
                  return decodeMap[reference];
                }
                if ($2) {
                  reference = $2;
                  next = $3;
                  if (next && options.isAttributeValue) {
                    if (strict && next == "=") {
                      parseError("`&` did not start a character reference");
                    }
                    return $0;
                  } else {
                    if (strict) {
                      parseError(
                        "named character reference was not terminated by a semicolon"
                      );
                    }
                    return decodeMapLegacy[reference] + (next || "");
                  }
                }
                if ($4) {
                  decDigits = $4;
                  semicolon = $5;
                  if (strict && !semicolon) {
                    parseError("character reference was not terminated by a semicolon");
                  }
                  codePoint = parseInt(decDigits, 10);
                  return codePointToSymbol(codePoint, strict);
                }
                if ($6) {
                  hexDigits = $6;
                  semicolon = $7;
                  if (strict && !semicolon) {
                    parseError("character reference was not terminated by a semicolon");
                  }
                  codePoint = parseInt(hexDigits, 16);
                  return codePointToSymbol(codePoint, strict);
                }
                if (strict) {
                  parseError(
                    "named character reference was not terminated by a semicolon"
                  );
                }
                return $0;
              });
            };
            decode.options = {
              "isAttributeValue": false,
              "strict": false
            };
            var escape2 = function(string) {
              return string.replace(regexEscape, function($0) {
                return escapeMap[$0];
              });
            };
            var he2 = {
              "version": "1.2.0",
              "encode": encode2,
              "decode": decode,
              "escape": escape2,
              "unescape": decode
            };
            if (freeExports && !freeExports.nodeType) {
              if (freeModule) {
                freeModule.exports = he2;
              } else {
                for (var key in he2) {
                  has(he2, key) && (freeExports[key] = he2[key]);
                }
              }
            } else {
              root.he = he2;
            }
          })(commonjsGlobal);
        })(he, he.exports);
        (function(exports2) {
          var path = require$$1;
          var util = require$$0$1;
          var he$1 = he.exports;
          const MOCHA_ID_PROP_NAME2 = "__mocha_id__";
          exports2.inherits = util.inherits;
          exports2.escape = function(html3) {
            return he$1.encode(String(html3), { useNamedReferences: false });
          };
          exports2.isString = function(obj) {
            return typeof obj === "string";
          };
          exports2.slug = function(str) {
            return str.toLowerCase().replace(/\s+/g, "-").replace(/[^-\w]/g, "").replace(/-{2,}/g, "-");
          };
          exports2.clean = function(str) {
            str = str.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/^\uFEFF/, "").replace(
              /^function(?:\s*|\s[^(]*)\([^)]*\)\s*\{((?:.|\n)*?)\}$|^\([^)]*\)\s*=>\s*(?:\{((?:.|\n)*?)\}|((?:.|\n)*))$/,
              "$1$2$3"
            );
            var spaces = str.match(/^\n?( *)/)[1].length;
            var tabs = str.match(/^\n?(\t*)/)[1].length;
            var re = new RegExp(
              "^\n?" + (tabs ? "	" : " ") + "{" + (tabs || spaces) + "}",
              "gm"
            );
            str = str.replace(re, "");
            return str.trim();
          };
          function emptyRepresentation(value, typeHint) {
            switch (typeHint) {
              case "function":
                return "[Function]";
              case "object":
                return "{}";
              case "array":
                return "[]";
              default:
                return value.toString();
            }
          }
          var canonicalType = exports2.canonicalType = function canonicalType2(value) {
            if (value === void 0) {
              return "undefined";
            } else if (value === null) {
              return "null";
            } else if (isBuffer(value)) {
              return "buffer";
            } else if (Object.getPrototypeOf(value) === null) {
              return "null-prototype";
            }
            return Object.prototype.toString.call(value).replace(/^\[.+\s(.+?)]$/, "$1").toLowerCase();
          };
          exports2.type = function type3(value) {
            if (value === null) return "null";
            const primitives = /* @__PURE__ */ new Set([
              "undefined",
              "boolean",
              "number",
              "string",
              "bigint",
              "symbol"
            ]);
            const _type = typeof value;
            if (_type === "function") return _type;
            if (primitives.has(_type)) return _type;
            if (value instanceof String) return "string";
            if (value instanceof Error) return "error";
            if (Array.isArray(value)) return "array";
            return _type;
          };
          exports2.stringify = function(value) {
            var typeHint = canonicalType(value);
            if (!~["object", "array", "function", "null-prototype"].indexOf(typeHint)) {
              if (typeHint === "buffer") {
                var json2 = Buffer2.prototype.toJSON.call(value);
                return jsonStringify(
                  json2.data && json2.type ? json2.data : json2,
                  2
                ).replace(/,(\n|$)/g, "$1");
              }
              if (typeHint === "string" && typeof value === "object") {
                value = value.split("").reduce(function(acc, char, idx) {
                  acc[idx] = char;
                  return acc;
                }, {});
                typeHint = "object";
              } else {
                return jsonStringify(value);
              }
            }
            for (var prop in value) {
              if (Object.prototype.hasOwnProperty.call(value, prop)) {
                return jsonStringify(
                  exports2.canonicalize(value, null, typeHint),
                  2
                ).replace(/,(\n|$)/g, "$1");
              }
            }
            return emptyRepresentation(value, typeHint);
          };
          function jsonStringify(object, spaces, depth) {
            if (typeof spaces === "undefined") {
              return _stringify(object);
            }
            depth = depth || 1;
            var space = spaces * depth;
            var str = Array.isArray(object) ? "[" : "{";
            var end = Array.isArray(object) ? "]" : "}";
            var length = typeof object.length === "number" ? object.length : Object.keys(object).length;
            function repeat(s2, n) {
              return new Array(n).join(s2);
            }
            function _stringify(val) {
              switch (canonicalType(val)) {
                case "null":
                case "undefined":
                  val = "[" + val + "]";
                  break;
                case "array":
                case "object":
                  val = jsonStringify(val, spaces, depth + 1);
                  break;
                case "boolean":
                case "regexp":
                case "symbol":
                case "number":
                  val = val === 0 && 1 / val === -Infinity ? "-0" : val.toString();
                  break;
                case "bigint":
                  val = val.toString() + "n";
                  break;
                case "date":
                  var sDate = isNaN(val.getTime()) ? val.toString() : val.toISOString();
                  val = "[Date: " + sDate + "]";
                  break;
                case "buffer":
                  var json2 = val.toJSON();
                  json2 = json2.data && json2.type ? json2.data : json2;
                  val = "[Buffer: " + jsonStringify(json2, 2, depth + 1) + "]";
                  break;
                default:
                  val = val === "[Function]" || val === "[Circular]" ? val : JSON.stringify(val);
              }
              return val;
            }
            for (var i in object) {
              if (!Object.prototype.hasOwnProperty.call(object, i)) {
                continue;
              }
              --length;
              str += "\n " + repeat(" ", space) + (Array.isArray(object) ? "" : '"' + i + '": ') + // key
              _stringify(object[i]) + // value
              (length ? "," : "");
            }
            return str + // [], {}
            (str.length !== 1 ? "\n" + repeat(" ", --space) + end : end);
          }
          exports2.canonicalize = function canonicalize2(value, stack, typeHint) {
            var canonicalizedObj;
            var prop;
            typeHint = typeHint || canonicalType(value);
            function withStack(value2, fn) {
              stack.push(value2);
              fn();
              stack.pop();
            }
            stack = stack || [];
            if (stack.indexOf(value) !== -1) {
              return "[Circular]";
            }
            switch (typeHint) {
              case "undefined":
              case "buffer":
              case "null":
                canonicalizedObj = value;
                break;
              case "array":
                withStack(value, function() {
                  canonicalizedObj = value.map(function(item) {
                    return exports2.canonicalize(item, stack);
                  });
                });
                break;
              case "function":
                for (prop in value) {
                  canonicalizedObj = {};
                  break;
                }
                if (!canonicalizedObj) {
                  canonicalizedObj = emptyRepresentation(value, typeHint);
                  break;
                }
              /* falls through */
              case "null-prototype":
              case "object":
                canonicalizedObj = canonicalizedObj || {};
                if (typeHint === "null-prototype" && Symbol.toStringTag in value) {
                  canonicalizedObj["[Symbol.toStringTag]"] = value[Symbol.toStringTag];
                }
                withStack(value, function() {
                  Object.keys(value).sort().forEach(function(key) {
                    canonicalizedObj[key] = exports2.canonicalize(value[key], stack);
                  });
                });
                break;
              case "date":
              case "number":
              case "regexp":
              case "boolean":
              case "symbol":
                canonicalizedObj = value;
                break;
              default:
                canonicalizedObj = value + "";
            }
            return canonicalizedObj;
          };
          exports2.stackTraceFilter = function() {
            var is = typeof document === "undefined" ? { node: true } : { browser: true };
            var slash = path.sep;
            var cwd2;
            if (is.node) {
              cwd2 = exports2.cwd() + slash;
            } else {
              cwd2 = (typeof location === "undefined" ? window.location : location).href.replace(/\/[^/]*$/, "/");
              slash = "/";
            }
            function isMochaInternal(line2) {
              return ~line2.indexOf("node_modules" + slash + "mocha" + slash) || ~line2.indexOf(slash + "mocha.js") || ~line2.indexOf(slash + "mocha.min.js");
            }
            function isNodeInternal(line2) {
              return ~line2.indexOf("(timers.js:") || ~line2.indexOf("(events.js:") || ~line2.indexOf("(node.js:") || ~line2.indexOf("(module.js:") || ~line2.indexOf("GeneratorFunctionPrototype.next (native)") || false;
            }
            return function(stack) {
              stack = stack.split("\n");
              stack = stack.reduce(function(list2, line2) {
                if (isMochaInternal(line2)) {
                  return list2;
                }
                if (is.node && isNodeInternal(line2)) {
                  return list2;
                }
                if (/:\d+:\d+\)?$/.test(line2)) {
                  line2 = line2.replace("(" + cwd2, "(");
                }
                list2.push(line2);
                return list2;
              }, []);
              return stack.join("\n");
            };
          };
          exports2.isPromise = function isPromise(value) {
            return typeof value === "object" && value !== null && typeof value.then === "function";
          };
          exports2.clamp = function clamp(value, range) {
            return Math.min(Math.max(value, range[0]), range[1]);
          };
          exports2.noop = function() {
          };
          exports2.createMap = function(obj) {
            return Object.assign.apply(
              null,
              [/* @__PURE__ */ Object.create(null)].concat(Array.prototype.slice.call(arguments))
            );
          };
          exports2.defineConstants = function(obj) {
            if (canonicalType(obj) !== "object" || !Object.keys(obj).length) {
              throw new TypeError("Invalid argument; expected a non-empty object");
            }
            return Object.freeze(exports2.createMap(obj));
          };
          exports2.cwd = function cwd2() {
            return process2.cwd();
          };
          exports2.isBrowser = function isBrowser() {
            return Boolean(browser$2);
          };
          exports2.castArray = function castArray(value) {
            if (value === void 0) {
              return [];
            }
            if (value === null) {
              return [null];
            }
            if (typeof value === "object" && (typeof value[Symbol.iterator] === "function" || value.length !== void 0)) {
              return Array.from(value);
            }
            return [value];
          };
          exports2.constants = exports2.defineConstants({
            MOCHA_ID_PROP_NAME: MOCHA_ID_PROP_NAME2
          });
          const uniqueIDBase = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_";
          exports2.uniqueID = () => {
            let id = "";
            for (let i = 0; i < 21; i++) {
              id += uniqueIDBase[Math.random() * 64 | 0];
            }
            return id;
          };
          exports2.assignNewMochaID = (obj) => {
            const id = exports2.uniqueID();
            Object.defineProperty(obj, MOCHA_ID_PROP_NAME2, {
              get() {
                return id;
              }
            });
            return obj;
          };
          exports2.getMochaID = (obj) => obj && typeof obj === "object" ? obj[MOCHA_ID_PROP_NAME2] : void 0;
          exports2.breakCircularDeps = (inputObj) => {
            const seen = /* @__PURE__ */ new Set();
            function _breakCircularDeps(obj) {
              if (obj && typeof obj !== "object") {
                return obj;
              }
              if (seen.has(obj)) {
                return "[Circular]";
              }
              seen.add(obj);
              for (const k in obj) {
                const descriptor = Object.getOwnPropertyDescriptor(obj, k);
                if (descriptor && descriptor.writable) {
                  obj[k] = _breakCircularDeps(obj[k]);
                }
              }
              seen.delete(obj);
              return obj;
            }
            return _breakCircularDeps(inputObj);
          };
        })(utils$3);
        var _nodeResolve_empty = {};
        var _nodeResolve_empty$1 = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          "default": _nodeResolve_empty
        });
        var require$$18 = /* @__PURE__ */ getAugmentedNamespace(_nodeResolve_empty$1);
        var browser$1 = {
          info: "\u2139\uFE0F",
          success: "\u2705",
          warning: "\u26A0\uFE0F",
          error: "\u274C\uFE0F"
        };
        var require$$0 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_events);
        var pending = Pending$2;
        function Pending$2(message) {
          this.message = message;
        }
        var browser = { exports: {} };
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        var ms = function(val, options) {
          options = options || {};
          var type3 = typeof val;
          if (type3 === "string" && val.length > 0) {
            return parse(val);
          } else if (type3 === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
          );
        };
        function parse(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str
          );
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type3 = (match[2] || "ms").toLowerCase();
          switch (type3) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "weeks":
            case "week":
            case "w":
              return n * w;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return void 0;
          }
        }
        function fmtShort(ms2) {
          var msAbs = Math.abs(ms2);
          if (msAbs >= d) {
            return Math.round(ms2 / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms2 / h) + "h";
          }
          if (msAbs >= m) {
            return Math.round(ms2 / m) + "m";
          }
          if (msAbs >= s) {
            return Math.round(ms2 / s) + "s";
          }
          return ms2 + "ms";
        }
        function fmtLong(ms2) {
          var msAbs = Math.abs(ms2);
          if (msAbs >= d) {
            return plural(ms2, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms2, msAbs, h, "hour");
          }
          if (msAbs >= m) {
            return plural(ms2, msAbs, m, "minute");
          }
          if (msAbs >= s) {
            return plural(ms2, msAbs, s, "second");
          }
          return ms2 + " ms";
        }
        function plural(ms2, msAbs, n, name2) {
          var isPlural = msAbs >= n * 1.5;
          return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
        }
        function setup(env2) {
          createDebug.debug = createDebug;
          createDebug.default = createDebug;
          createDebug.coerce = coerce;
          createDebug.disable = disable;
          createDebug.enable = enable;
          createDebug.enabled = enabled;
          createDebug.humanize = ms;
          createDebug.destroy = destroy;
          Object.keys(env2).forEach((key) => {
            createDebug[key] = env2[key];
          });
          createDebug.names = [];
          createDebug.skips = [];
          createDebug.formatters = {};
          function selectColor(namespace) {
            let hash = 0;
            for (let i = 0; i < namespace.length; i++) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0;
            }
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
          }
          createDebug.selectColor = selectColor;
          function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            let namespacesCache;
            let enabledCache;
            function debug3(...args) {
              if (!debug3.enabled) {
                return;
              }
              const self2 = debug3;
              const curr = Number(/* @__PURE__ */ new Date());
              const ms2 = curr - (prevTime || curr);
              self2.diff = ms2;
              self2.prev = prevTime;
              self2.curr = curr;
              prevTime = curr;
              args[0] = createDebug.coerce(args[0]);
              if (typeof args[0] !== "string") {
                args.unshift("%O");
              }
              let index = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format3) => {
                if (match === "%%") {
                  return "%";
                }
                index++;
                const formatter = createDebug.formatters[format3];
                if (typeof formatter === "function") {
                  const val = args[index];
                  match = formatter.call(self2, val);
                  args.splice(index, 1);
                  index--;
                }
                return match;
              });
              createDebug.formatArgs.call(self2, args);
              const logFn = self2.log || createDebug.log;
              logFn.apply(self2, args);
            }
            debug3.namespace = namespace;
            debug3.useColors = createDebug.useColors();
            debug3.color = createDebug.selectColor(namespace);
            debug3.extend = extend;
            debug3.destroy = createDebug.destroy;
            Object.defineProperty(debug3, "enabled", {
              enumerable: true,
              configurable: false,
              get: () => {
                if (enableOverride !== null) {
                  return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                  namespacesCache = createDebug.namespaces;
                  enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
              },
              set: (v2) => {
                enableOverride = v2;
              }
            });
            if (typeof createDebug.init === "function") {
              createDebug.init(debug3);
            }
            return debug3;
          }
          function extend(namespace, delimiter2) {
            const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
            newDebug.log = this.log;
            return newDebug;
          }
          function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;
            createDebug.names = [];
            createDebug.skips = [];
            let i;
            const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
            const len = split.length;
            for (i = 0; i < len; i++) {
              if (!split[i]) {
                continue;
              }
              namespaces = split[i].replace(/\*/g, ".*?");
              if (namespaces[0] === "-") {
                createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
              } else {
                createDebug.names.push(new RegExp("^" + namespaces + "$"));
              }
            }
          }
          function disable() {
            const namespaces = [
              ...createDebug.names.map(toNamespace),
              ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
            ].join(",");
            createDebug.enable("");
            return namespaces;
          }
          function enabled(name2) {
            if (name2[name2.length - 1] === "*") {
              return true;
            }
            let i;
            let len;
            for (i = 0, len = createDebug.skips.length; i < len; i++) {
              if (createDebug.skips[i].test(name2)) {
                return false;
              }
            }
            for (i = 0, len = createDebug.names.length; i < len; i++) {
              if (createDebug.names[i].test(name2)) {
                return true;
              }
            }
            return false;
          }
          function toNamespace(regexp) {
            return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          function coerce(val) {
            if (val instanceof Error) {
              return val.stack || val.message;
            }
            return val;
          }
          function destroy() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
          createDebug.enable(createDebug.load());
          return createDebug;
        }
        var common$1 = setup;
        (function(module3, exports2) {
          exports2.formatArgs = formatArgs;
          exports2.save = save;
          exports2.load = load;
          exports2.useColors = useColors;
          exports2.storage = localstorage();
          exports2.destroy = /* @__PURE__ */ (() => {
            let warned = false;
            return () => {
              if (!warned) {
                warned = true;
                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
              }
            };
          })();
          exports2.colors = [
            "#0000CC",
            "#0000FF",
            "#0033CC",
            "#0033FF",
            "#0066CC",
            "#0066FF",
            "#0099CC",
            "#0099FF",
            "#00CC00",
            "#00CC33",
            "#00CC66",
            "#00CC99",
            "#00CCCC",
            "#00CCFF",
            "#3300CC",
            "#3300FF",
            "#3333CC",
            "#3333FF",
            "#3366CC",
            "#3366FF",
            "#3399CC",
            "#3399FF",
            "#33CC00",
            "#33CC33",
            "#33CC66",
            "#33CC99",
            "#33CCCC",
            "#33CCFF",
            "#6600CC",
            "#6600FF",
            "#6633CC",
            "#6633FF",
            "#66CC00",
            "#66CC33",
            "#9900CC",
            "#9900FF",
            "#9933CC",
            "#9933FF",
            "#99CC00",
            "#99CC33",
            "#CC0000",
            "#CC0033",
            "#CC0066",
            "#CC0099",
            "#CC00CC",
            "#CC00FF",
            "#CC3300",
            "#CC3333",
            "#CC3366",
            "#CC3399",
            "#CC33CC",
            "#CC33FF",
            "#CC6600",
            "#CC6633",
            "#CC9900",
            "#CC9933",
            "#CCCC00",
            "#CCCC33",
            "#FF0000",
            "#FF0033",
            "#FF0066",
            "#FF0099",
            "#FF00CC",
            "#FF00FF",
            "#FF3300",
            "#FF3333",
            "#FF3366",
            "#FF3399",
            "#FF33CC",
            "#FF33FF",
            "#FF6600",
            "#FF6633",
            "#FF9900",
            "#FF9933",
            "#FFCC00",
            "#FFCC33"
          ];
          function useColors() {
            if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
              return true;
            }
            if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
              return false;
            }
            return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
            typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
            // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
            typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
            typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
          }
          function formatArgs(args) {
            args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module3.exports.humanize(this.diff);
            if (!this.useColors) {
              return;
            }
            const c = "color: " + this.color;
            args.splice(1, 0, c, "color: inherit");
            let index = 0;
            let lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match) => {
              if (match === "%%") {
                return;
              }
              index++;
              if (match === "%c") {
                lastC = index;
              }
            });
            args.splice(lastC, 0, c);
          }
          exports2.log = console.debug || console.log || (() => {
          });
          function save(namespaces) {
            try {
              if (namespaces) {
                exports2.storage.setItem("debug", namespaces);
              } else {
                exports2.storage.removeItem("debug");
              }
            } catch (error) {
            }
          }
          function load() {
            let r;
            try {
              r = exports2.storage.getItem("debug");
            } catch (error) {
            }
            if (!r && typeof process2 !== "undefined" && "env" in process2) {
              r = process2.env.DEBUG;
            }
            return r;
          }
          function localstorage() {
            try {
              return localStorage;
            } catch (error) {
            }
          }
          module3.exports = common$1(exports2);
          const { formatters } = module3.exports;
          formatters.j = function(v2) {
            try {
              return JSON.stringify(v2);
            } catch (error) {
              return "[UnexpectedJSONParseError]: " + error.message;
            }
          };
        })(browser, browser.exports);
        const { format: format2 } = require$$0$1;
        const emitWarning = (msg, type3) => {
          if (process2.emitWarning) {
            process2.emitWarning(msg, type3);
          } else {
            nextTick$1(function() {
              console.warn(type3 + ": " + msg);
            });
          }
        };
        const deprecate = (msg) => {
          msg = String(msg);
          if (msg && !deprecate.cache[msg]) {
            deprecate.cache[msg] = true;
            emitWarning(msg, "DeprecationWarning");
          }
        };
        deprecate.cache = {};
        const warn = (msg) => {
          if (msg) {
            emitWarning(msg);
          }
        };
        var constants$4 = {
          /**
           * An unrecoverable error.
           * @constant
           * @default
           */
          FATAL: "ERR_MOCHA_FATAL",
          /**
           * The type of an argument to a function call is invalid
           * @constant
           * @default
           */
          INVALID_ARG_TYPE: "ERR_MOCHA_INVALID_ARG_TYPE",
          /**
           * The value of an argument to a function call is invalid
           * @constant
           * @default
           */
          INVALID_ARG_VALUE: "ERR_MOCHA_INVALID_ARG_VALUE",
          /**
           * Something was thrown, but it wasn't an `Error`
           * @constant
           * @default
           */
          INVALID_EXCEPTION: "ERR_MOCHA_INVALID_EXCEPTION",
          /**
           * An interface (e.g., `Mocha.interfaces`) is unknown or invalid
           * @constant
           * @default
           */
          INVALID_INTERFACE: "ERR_MOCHA_INVALID_INTERFACE",
          /**
           * A reporter (.e.g, `Mocha.reporters`) is unknown or invalid
           * @constant
           * @default
           */
          INVALID_REPORTER: "ERR_MOCHA_INVALID_REPORTER",
          /**
           * `done()` was called twice in a `Test` or `Hook` callback
           * @constant
           * @default
           */
          MULTIPLE_DONE: "ERR_MOCHA_MULTIPLE_DONE",
          /**
           * No files matched the pattern provided by the user
           * @constant
           * @default
           */
          NO_FILES_MATCH_PATTERN: "ERR_MOCHA_NO_FILES_MATCH_PATTERN",
          /**
           * Known, but unsupported behavior of some kind
           * @constant
           * @default
           */
          UNSUPPORTED: "ERR_MOCHA_UNSUPPORTED",
          /**
           * Invalid state transition occurring in `Mocha` instance
           * @constant
           * @default
           */
          INSTANCE_ALREADY_RUNNING: "ERR_MOCHA_INSTANCE_ALREADY_RUNNING",
          /**
           * Invalid state transition occurring in `Mocha` instance
           * @constant
           * @default
           */
          INSTANCE_ALREADY_DISPOSED: "ERR_MOCHA_INSTANCE_ALREADY_DISPOSED",
          /**
           * Use of `only()` w/ `--forbid-only` results in this error.
           * @constant
           * @default
           */
          FORBIDDEN_EXCLUSIVITY: "ERR_MOCHA_FORBIDDEN_EXCLUSIVITY",
          /**
           * To be thrown when a user-defined plugin implementation (e.g., `mochaHooks`) is invalid
           * @constant
           * @default
           */
          INVALID_PLUGIN_IMPLEMENTATION: "ERR_MOCHA_INVALID_PLUGIN_IMPLEMENTATION",
          /**
           * To be thrown when a builtin or third-party plugin definition (the _definition_ of `mochaHooks`) is invalid
           * @constant
           * @default
           */
          INVALID_PLUGIN_DEFINITION: "ERR_MOCHA_INVALID_PLUGIN_DEFINITION",
          /**
           * When a runnable exceeds its allowed run time.
           * @constant
           * @default
           */
          TIMEOUT: "ERR_MOCHA_TIMEOUT",
          /**
           * Input file is not able to be parsed
           * @constant
           * @default
           */
          UNPARSABLE_FILE: "ERR_MOCHA_UNPARSABLE_FILE"
        };
        const MOCHA_ERRORS = new Set(Object.values(constants$4));
        function createNoFilesMatchPatternError(message, pattern) {
          var err = new Error(message);
          err.code = constants$4.NO_FILES_MATCH_PATTERN;
          err.pattern = pattern;
          return err;
        }
        function createInvalidReporterError(message, reporter2) {
          var err = new TypeError(message);
          err.code = constants$4.INVALID_REPORTER;
          err.reporter = reporter2;
          return err;
        }
        function createInvalidInterfaceError(message, ui2) {
          var err = new Error(message);
          err.code = constants$4.INVALID_INTERFACE;
          err.interface = ui2;
          return err;
        }
        function createUnsupportedError$2(message) {
          var err = new Error(message);
          err.code = constants$4.UNSUPPORTED;
          return err;
        }
        function createMissingArgumentError$1(message, argument, expected) {
          return createInvalidArgumentTypeError$1(message, argument, expected);
        }
        function createInvalidArgumentTypeError$1(message, argument, expected) {
          var err = new TypeError(message);
          err.code = constants$4.INVALID_ARG_TYPE;
          err.argument = argument;
          err.expected = expected;
          err.actual = typeof argument;
          return err;
        }
        function createInvalidArgumentValueError(message, argument, value, reason) {
          var err = new TypeError(message);
          err.code = constants$4.INVALID_ARG_VALUE;
          err.argument = argument;
          err.value = value;
          err.reason = typeof reason !== "undefined" ? reason : "is invalid";
          return err;
        }
        function createInvalidExceptionError$2(message, value) {
          var err = new Error(message);
          err.code = constants$4.INVALID_EXCEPTION;
          err.valueType = typeof value;
          err.value = value;
          return err;
        }
        function createFatalError$1(message, value) {
          var err = new Error(message);
          err.code = constants$4.FATAL;
          err.valueType = typeof value;
          err.value = value;
          return err;
        }
        function createInvalidLegacyPluginError(message, pluginType, pluginId) {
          switch (pluginType) {
            case "reporter":
              return createInvalidReporterError(message, pluginId);
            case "ui":
              return createInvalidInterfaceError(message, pluginId);
            default:
              throw new Error('unknown pluginType "' + pluginType + '"');
          }
        }
        function createInvalidPluginError(...args) {
          deprecate("Use createInvalidLegacyPluginError() instead");
          return createInvalidLegacyPluginError(...args);
        }
        function createMochaInstanceAlreadyDisposedError(message, cleanReferencesAfterRun, instance) {
          var err = new Error(message);
          err.code = constants$4.INSTANCE_ALREADY_DISPOSED;
          err.cleanReferencesAfterRun = cleanReferencesAfterRun;
          err.instance = instance;
          return err;
        }
        function createMochaInstanceAlreadyRunningError(message, instance) {
          var err = new Error(message);
          err.code = constants$4.INSTANCE_ALREADY_RUNNING;
          err.instance = instance;
          return err;
        }
        function createMultipleDoneError$1(runnable2, originalErr) {
          var title2;
          try {
            title2 = format2("<%s>", runnable2.fullTitle());
            if (runnable2.parent.root) {
              title2 += " (of root suite)";
            }
          } catch (ignored) {
            title2 = format2("<%s> (of unknown suite)", runnable2.title);
          }
          var message = format2(
            "done() called multiple times in %s %s",
            runnable2.type ? runnable2.type : "unknown runnable",
            title2
          );
          if (runnable2.file) {
            message += format2(" of file %s", runnable2.file);
          }
          if (originalErr) {
            message += format2("; in addition, done() received error: %s", originalErr);
          }
          var err = new Error(message);
          err.code = constants$4.MULTIPLE_DONE;
          err.valueType = typeof originalErr;
          err.value = originalErr;
          return err;
        }
        function createForbiddenExclusivityError$1(mocha3) {
          var err = new Error(
            mocha3.isWorker ? "`.only` is not supported in parallel mode" : "`.only` forbidden by --forbid-only"
          );
          err.code = constants$4.FORBIDDEN_EXCLUSIVITY;
          return err;
        }
        function createInvalidPluginDefinitionError(msg, pluginDef) {
          const err = new Error(msg);
          err.code = constants$4.INVALID_PLUGIN_DEFINITION;
          err.pluginDef = pluginDef;
          return err;
        }
        function createInvalidPluginImplementationError(msg, { pluginDef, pluginImpl } = {}) {
          const err = new Error(msg);
          err.code = constants$4.INVALID_PLUGIN_IMPLEMENTATION;
          err.pluginDef = pluginDef;
          err.pluginImpl = pluginImpl;
          return err;
        }
        function createTimeoutError$1(msg, timeout2, file) {
          const err = new Error(msg);
          err.code = constants$4.TIMEOUT;
          err.timeout = timeout2;
          err.file = file;
          return err;
        }
        function createUnparsableFileError(message, filename) {
          var err = new Error(message);
          err.code = constants$4.UNPARSABLE_FILE;
          return err;
        }
        const isMochaError$1 = (err) => Boolean(err && typeof err === "object" && MOCHA_ERRORS.has(err.code));
        var errors$2 = {
          constants: constants$4,
          createFatalError: createFatalError$1,
          createForbiddenExclusivityError: createForbiddenExclusivityError$1,
          createInvalidArgumentTypeError: createInvalidArgumentTypeError$1,
          createInvalidArgumentValueError,
          createInvalidExceptionError: createInvalidExceptionError$2,
          createInvalidInterfaceError,
          createInvalidLegacyPluginError,
          createInvalidPluginDefinitionError,
          createInvalidPluginError,
          createInvalidPluginImplementationError,
          createInvalidReporterError,
          createMissingArgumentError: createMissingArgumentError$1,
          createMochaInstanceAlreadyDisposedError,
          createMochaInstanceAlreadyRunningError,
          createMultipleDoneError: createMultipleDoneError$1,
          createNoFilesMatchPatternError,
          createTimeoutError: createTimeoutError$1,
          createUnparsableFileError,
          createUnsupportedError: createUnsupportedError$2,
          deprecate,
          isMochaError: isMochaError$1,
          warn
        };
        var EventEmitter$1 = require$$0.EventEmitter;
        var Pending$1 = pending;
        var debug$1 = browser.exports("mocha:runnable");
        var milliseconds = ms$1;
        var utils$2 = utils$3;
        const {
          createInvalidExceptionError: createInvalidExceptionError$1,
          createMultipleDoneError,
          createTimeoutError
        } = errors$2;
        var Date$3 = commonjsGlobal.Date;
        var setTimeout$2 = commonjsGlobal.setTimeout;
        var clearTimeout$1 = commonjsGlobal.clearTimeout;
        var toString2 = Object.prototype.toString;
        var MAX_TIMEOUT = Math.pow(2, 31) - 1;
        var runnable = Runnable$3;
        function Runnable$3(title2, fn) {
          this.title = title2;
          this.fn = fn;
          this.body = (fn || "").toString();
          this.async = fn && fn.length;
          this.sync = !this.async;
          this._timeout = 2e3;
          this._slow = 75;
          this._retries = -1;
          utils$2.assignNewMochaID(this);
          Object.defineProperty(this, "id", {
            get() {
              return utils$2.getMochaID(this);
            }
          });
          this.reset();
        }
        utils$2.inherits(Runnable$3, EventEmitter$1);
        Runnable$3.prototype.reset = function() {
          this.timedOut = false;
          this._currentRetry = 0;
          this.pending = false;
          delete this.state;
          delete this.err;
        };
        Runnable$3.prototype.timeout = function(ms2) {
          if (!arguments.length) {
            return this._timeout;
          }
          if (typeof ms2 === "string") {
            ms2 = milliseconds(ms2);
          }
          var range = [0, MAX_TIMEOUT];
          ms2 = utils$2.clamp(ms2, range);
          if (ms2 === range[0] || ms2 === range[1]) {
            this._timeout = 0;
          } else {
            this._timeout = ms2;
          }
          debug$1("timeout %d", this._timeout);
          if (this.timer) {
            this.resetTimeout();
          }
          return this;
        };
        Runnable$3.prototype.slow = function(ms2) {
          if (!arguments.length || typeof ms2 === "undefined") {
            return this._slow;
          }
          if (typeof ms2 === "string") {
            ms2 = milliseconds(ms2);
          }
          debug$1("slow %d", ms2);
          this._slow = ms2;
          return this;
        };
        Runnable$3.prototype.skip = function() {
          this.pending = true;
          throw new Pending$1("sync skip; aborting execution");
        };
        Runnable$3.prototype.isPending = function() {
          return this.pending || this.parent && this.parent.isPending();
        };
        Runnable$3.prototype.isFailed = function() {
          return !this.isPending() && this.state === constants$3.STATE_FAILED;
        };
        Runnable$3.prototype.isPassed = function() {
          return !this.isPending() && this.state === constants$3.STATE_PASSED;
        };
        Runnable$3.prototype.retries = function(n) {
          if (!arguments.length) {
            return this._retries;
          }
          this._retries = n;
        };
        Runnable$3.prototype.currentRetry = function(n) {
          if (!arguments.length) {
            return this._currentRetry;
          }
          this._currentRetry = n;
        };
        Runnable$3.prototype.fullTitle = function() {
          return this.titlePath().join(" ");
        };
        Runnable$3.prototype.titlePath = function() {
          return this.parent.titlePath().concat([this.title]);
        };
        Runnable$3.prototype.clearTimeout = function() {
          clearTimeout$1(this.timer);
        };
        Runnable$3.prototype.resetTimeout = function() {
          var self2 = this;
          var ms2 = this.timeout() || MAX_TIMEOUT;
          this.clearTimeout();
          this.timer = setTimeout$2(function() {
            if (self2.timeout() === 0) {
              return;
            }
            self2.callback(self2._timeoutError(ms2));
            self2.timedOut = true;
          }, ms2);
        };
        Runnable$3.prototype.globals = function(globals2) {
          if (!arguments.length) {
            return this._allowedGlobals;
          }
          this._allowedGlobals = globals2;
        };
        Runnable$3.prototype.run = function(fn) {
          var self2 = this;
          var start = new Date$3();
          var ctx = this.ctx;
          var finished;
          var errorWasHandled = false;
          if (this.isPending()) return fn();
          if (ctx && ctx.runnable) {
            ctx.runnable(this);
          }
          function multiple(err) {
            if (errorWasHandled) {
              return;
            }
            errorWasHandled = true;
            self2.emit("error", createMultipleDoneError(self2, err));
          }
          function done2(err) {
            var ms2 = self2.timeout();
            if (self2.timedOut) {
              return;
            }
            if (finished) {
              return multiple(err);
            }
            self2.clearTimeout();
            self2.duration = new Date$3() - start;
            finished = true;
            if (!err && self2.duration > ms2 && ms2 > 0) {
              err = self2._timeoutError(ms2);
            }
            fn(err);
          }
          this.callback = done2;
          if (this.fn && typeof this.fn.call !== "function") {
            done2(
              new TypeError(
                "A runnable must be passed a function as its second argument."
              )
            );
            return;
          }
          if (this.async) {
            this.resetTimeout();
            this.skip = function asyncSkip() {
              this.pending = true;
              done2();
              throw new Pending$1("async skip; aborting execution");
            };
            try {
              callFnAsync(this.fn);
            } catch (err) {
              errorWasHandled = true;
              if (err instanceof Pending$1) {
                return;
              } else if (this.allowUncaught) {
                throw err;
              }
              done2(Runnable$3.toValueOrError(err));
            }
            return;
          }
          try {
            callFn(this.fn);
          } catch (err) {
            errorWasHandled = true;
            if (err instanceof Pending$1) {
              return done2();
            } else if (this.allowUncaught) {
              throw err;
            }
            done2(Runnable$3.toValueOrError(err));
          }
          function callFn(fn2) {
            var result = fn2.call(ctx);
            if (result && typeof result.then === "function") {
              self2.resetTimeout();
              result.then(
                function() {
                  done2();
                  return null;
                },
                function(reason) {
                  done2(reason || new Error("Promise rejected with no or falsy reason"));
                }
              );
            } else {
              if (self2.asyncOnly) {
                return done2(
                  new Error(
                    "--async-only option in use without declaring `done()` or returning a promise"
                  )
                );
              }
              done2();
            }
          }
          function callFnAsync(fn2) {
            var result = fn2.call(ctx, function(err) {
              if (err instanceof Error || toString2.call(err) === "[object Error]") {
                return done2(err);
              }
              if (err) {
                if (Object.prototype.toString.call(err) === "[object Object]") {
                  return done2(
                    new Error("done() invoked with non-Error: " + JSON.stringify(err))
                  );
                }
                return done2(new Error("done() invoked with non-Error: " + err));
              }
              if (result && utils$2.isPromise(result)) {
                return done2(
                  new Error(
                    "Resolution method is overspecified. Specify a callback *or* return a Promise; not both."
                  )
                );
              }
              done2();
            });
          }
        };
        Runnable$3.prototype._timeoutError = function(ms2) {
          let msg = `Timeout of ${ms2}ms exceeded. For async tests and hooks, ensure "done()" is called; if returning a Promise, ensure it resolves.`;
          if (this.file) {
            msg += " (" + this.file + ")";
          }
          return createTimeoutError(msg, ms2, this.file);
        };
        var constants$3 = utils$2.defineConstants(
          /**
           * {@link Runnable}-related constants.
           * @public
           * @memberof Runnable
           * @readonly
           * @static
           * @alias constants
           * @enum {string}
           */
          {
            /**
             * Value of `state` prop when a `Runnable` has failed
             */
            STATE_FAILED: "failed",
            /**
             * Value of `state` prop when a `Runnable` has passed
             */
            STATE_PASSED: "passed",
            /**
             * Value of `state` prop when a `Runnable` has been skipped by user
             */
            STATE_PENDING: "pending"
          }
        );
        Runnable$3.toValueOrError = function(value) {
          return value || createInvalidExceptionError$1(
            "Runnable failed with falsy or undefined exception. Please throw an Error instead.",
            value
          );
        };
        Runnable$3.constants = constants$3;
        var suite = { exports: {} };
        var Runnable$2 = runnable;
        const { inherits, constants: constants$2 } = utils$3;
        const { MOCHA_ID_PROP_NAME: MOCHA_ID_PROP_NAME$1 } = constants$2;
        var hook = Hook;
        function Hook(title2, fn) {
          Runnable$2.call(this, title2, fn);
          this.type = "hook";
        }
        inherits(Hook, Runnable$2);
        Hook.prototype.reset = function() {
          Runnable$2.prototype.reset.call(this);
          delete this._error;
        };
        Hook.prototype.error = function(err) {
          if (!arguments.length) {
            err = this._error;
            this._error = null;
            return err;
          }
          this._error = err;
        };
        Hook.prototype.serialize = function serialize() {
          return {
            $$currentRetry: this.currentRetry(),
            $$fullTitle: this.fullTitle(),
            $$isPending: Boolean(this.isPending()),
            $$titlePath: this.titlePath(),
            ctx: this.ctx && this.ctx.currentTest ? {
              currentTest: {
                title: this.ctx.currentTest.title,
                [MOCHA_ID_PROP_NAME$1]: this.ctx.currentTest.id
              }
            } : {},
            duration: this.duration,
            file: this.file,
            parent: {
              $$fullTitle: this.parent.fullTitle(),
              [MOCHA_ID_PROP_NAME$1]: this.parent.id
            },
            state: this.state,
            title: this.title,
            type: this.type,
            [MOCHA_ID_PROP_NAME$1]: this.id
          };
        };
        (function(module3, exports2) {
          const { EventEmitter: EventEmitter2 } = require$$0;
          const Hook2 = hook;
          var {
            assignNewMochaID,
            clamp,
            constants: utilsConstants,
            defineConstants,
            getMochaID,
            inherits: inherits2,
            isString: isString2
          } = utils$3;
          const debug3 = browser.exports("mocha:suite");
          const milliseconds2 = ms$1;
          const errors3 = errors$2;
          const { MOCHA_ID_PROP_NAME: MOCHA_ID_PROP_NAME2 } = utilsConstants;
          module3.exports = Suite2;
          Suite2.create = function(parent, title2) {
            var suite2 = new Suite2(title2, parent.ctx);
            suite2.parent = parent;
            title2 = suite2.fullTitle();
            parent.addSuite(suite2);
            return suite2;
          };
          function Suite2(title2, parentContext, isRoot) {
            if (!isString2(title2)) {
              throw errors3.createInvalidArgumentTypeError(
                'Suite argument "title" must be a string. Received type "' + typeof title2 + '"',
                "title",
                "string"
              );
            }
            this.title = title2;
            function Context2() {
            }
            Context2.prototype = parentContext;
            this.ctx = new Context2();
            this.suites = [];
            this.tests = [];
            this.root = isRoot === true;
            this.pending = false;
            this._retries = -1;
            this._beforeEach = [];
            this._beforeAll = [];
            this._afterEach = [];
            this._afterAll = [];
            this._timeout = 2e3;
            this._slow = 75;
            this._bail = false;
            this._onlyTests = [];
            this._onlySuites = [];
            assignNewMochaID(this);
            Object.defineProperty(this, "id", {
              get() {
                return getMochaID(this);
              }
            });
            this.reset();
          }
          inherits2(Suite2, EventEmitter2);
          Suite2.prototype.reset = function() {
            this.delayed = false;
            function doReset(thingToReset) {
              thingToReset.reset();
            }
            this.suites.forEach(doReset);
            this.tests.forEach(doReset);
            this._beforeEach.forEach(doReset);
            this._afterEach.forEach(doReset);
            this._beforeAll.forEach(doReset);
            this._afterAll.forEach(doReset);
          };
          Suite2.prototype.clone = function() {
            var suite2 = new Suite2(this.title);
            debug3("clone");
            suite2.ctx = this.ctx;
            suite2.root = this.root;
            suite2.timeout(this.timeout());
            suite2.retries(this.retries());
            suite2.slow(this.slow());
            suite2.bail(this.bail());
            return suite2;
          };
          Suite2.prototype.timeout = function(ms2) {
            if (!arguments.length) {
              return this._timeout;
            }
            if (typeof ms2 === "string") {
              ms2 = milliseconds2(ms2);
            }
            var INT_MAX = Math.pow(2, 31) - 1;
            var range = [0, INT_MAX];
            ms2 = clamp(ms2, range);
            debug3("timeout %d", ms2);
            this._timeout = parseInt(ms2, 10);
            return this;
          };
          Suite2.prototype.retries = function(n) {
            if (!arguments.length) {
              return this._retries;
            }
            debug3("retries %d", n);
            this._retries = parseInt(n, 10) || 0;
            return this;
          };
          Suite2.prototype.slow = function(ms2) {
            if (!arguments.length) {
              return this._slow;
            }
            if (typeof ms2 === "string") {
              ms2 = milliseconds2(ms2);
            }
            debug3("slow %d", ms2);
            this._slow = ms2;
            return this;
          };
          Suite2.prototype.bail = function(bail) {
            if (!arguments.length) {
              return this._bail;
            }
            debug3("bail %s", bail);
            this._bail = bail;
            return this;
          };
          Suite2.prototype.isPending = function() {
            return this.pending || this.parent && this.parent.isPending();
          };
          Suite2.prototype._createHook = function(title2, fn) {
            var hook2 = new Hook2(title2, fn);
            hook2.parent = this;
            hook2.timeout(this.timeout());
            hook2.retries(this.retries());
            hook2.slow(this.slow());
            hook2.ctx = this.ctx;
            hook2.file = this.file;
            return hook2;
          };
          Suite2.prototype.beforeAll = function(title2, fn) {
            if (this.isPending()) {
              return this;
            }
            if (typeof title2 === "function") {
              fn = title2;
              title2 = fn.name;
            }
            title2 = '"before all" hook' + (title2 ? ": " + title2 : "");
            var hook2 = this._createHook(title2, fn);
            this._beforeAll.push(hook2);
            this.emit(constants2.EVENT_SUITE_ADD_HOOK_BEFORE_ALL, hook2);
            return this;
          };
          Suite2.prototype.afterAll = function(title2, fn) {
            if (this.isPending()) {
              return this;
            }
            if (typeof title2 === "function") {
              fn = title2;
              title2 = fn.name;
            }
            title2 = '"after all" hook' + (title2 ? ": " + title2 : "");
            var hook2 = this._createHook(title2, fn);
            this._afterAll.push(hook2);
            this.emit(constants2.EVENT_SUITE_ADD_HOOK_AFTER_ALL, hook2);
            return this;
          };
          Suite2.prototype.beforeEach = function(title2, fn) {
            if (this.isPending()) {
              return this;
            }
            if (typeof title2 === "function") {
              fn = title2;
              title2 = fn.name;
            }
            title2 = '"before each" hook' + (title2 ? ": " + title2 : "");
            var hook2 = this._createHook(title2, fn);
            this._beforeEach.push(hook2);
            this.emit(constants2.EVENT_SUITE_ADD_HOOK_BEFORE_EACH, hook2);
            return this;
          };
          Suite2.prototype.afterEach = function(title2, fn) {
            if (this.isPending()) {
              return this;
            }
            if (typeof title2 === "function") {
              fn = title2;
              title2 = fn.name;
            }
            title2 = '"after each" hook' + (title2 ? ": " + title2 : "");
            var hook2 = this._createHook(title2, fn);
            this._afterEach.push(hook2);
            this.emit(constants2.EVENT_SUITE_ADD_HOOK_AFTER_EACH, hook2);
            return this;
          };
          Suite2.prototype.addSuite = function(suite2) {
            suite2.parent = this;
            suite2.root = false;
            suite2.timeout(this.timeout());
            suite2.retries(this.retries());
            suite2.slow(this.slow());
            suite2.bail(this.bail());
            this.suites.push(suite2);
            this.emit(constants2.EVENT_SUITE_ADD_SUITE, suite2);
            return this;
          };
          Suite2.prototype.addTest = function(test3) {
            test3.parent = this;
            test3.timeout(this.timeout());
            test3.retries(this.retries());
            test3.slow(this.slow());
            test3.ctx = this.ctx;
            this.tests.push(test3);
            this.emit(constants2.EVENT_SUITE_ADD_TEST, test3);
            return this;
          };
          Suite2.prototype.fullTitle = function() {
            return this.titlePath().join(" ");
          };
          Suite2.prototype.titlePath = function() {
            var result = [];
            if (this.parent) {
              result = result.concat(this.parent.titlePath());
            }
            if (!this.root) {
              result.push(this.title);
            }
            return result;
          };
          Suite2.prototype.total = function() {
            return this.suites.reduce(function(sum, suite2) {
              return sum + suite2.total();
            }, 0) + this.tests.length;
          };
          Suite2.prototype.eachTest = function(fn) {
            this.tests.forEach(fn);
            this.suites.forEach(function(suite2) {
              suite2.eachTest(fn);
            });
            return this;
          };
          Suite2.prototype.run = function run() {
            if (this.root) {
              this.emit(constants2.EVENT_ROOT_SUITE_RUN);
            }
          };
          Suite2.prototype.hasOnly = function hasOnly() {
            return this._onlyTests.length > 0 || this._onlySuites.length > 0 || this.suites.some(function(suite2) {
              return suite2.hasOnly();
            });
          };
          Suite2.prototype.filterOnly = function filterOnly() {
            if (this._onlyTests.length) {
              this.tests = this._onlyTests;
              this.suites = [];
            } else {
              this.tests = [];
              this._onlySuites.forEach(function(onlySuite) {
                if (onlySuite.hasOnly()) {
                  onlySuite.filterOnly();
                }
              });
              var onlySuites = this._onlySuites;
              this.suites = this.suites.filter(function(childSuite) {
                return onlySuites.indexOf(childSuite) !== -1 || childSuite.filterOnly();
              });
            }
            return this.tests.length > 0 || this.suites.length > 0;
          };
          Suite2.prototype.appendOnlySuite = function(suite2) {
            this._onlySuites.push(suite2);
          };
          Suite2.prototype.markOnly = function() {
            this.parent && this.parent.appendOnlySuite(this);
          };
          Suite2.prototype.appendOnlyTest = function(test3) {
            this._onlyTests.push(test3);
          };
          Suite2.prototype.getHooks = function getHooks(name2) {
            return this["_" + name2];
          };
          Suite2.prototype.dispose = function() {
            this.suites.forEach(function(suite2) {
              suite2.dispose();
            });
            this.cleanReferences();
          };
          Suite2.prototype.cleanReferences = function cleanReferences() {
            function cleanArrReferences(arr) {
              for (var i2 = 0; i2 < arr.length; i2++) {
                delete arr[i2].fn;
              }
            }
            if (Array.isArray(this._beforeAll)) {
              cleanArrReferences(this._beforeAll);
            }
            if (Array.isArray(this._beforeEach)) {
              cleanArrReferences(this._beforeEach);
            }
            if (Array.isArray(this._afterAll)) {
              cleanArrReferences(this._afterAll);
            }
            if (Array.isArray(this._afterEach)) {
              cleanArrReferences(this._afterEach);
            }
            for (var i = 0; i < this.tests.length; i++) {
              delete this.tests[i].fn;
            }
          };
          Suite2.prototype.serialize = function serialize() {
            return {
              _bail: this._bail,
              $$fullTitle: this.fullTitle(),
              $$isPending: Boolean(this.isPending()),
              root: this.root,
              title: this.title,
              [MOCHA_ID_PROP_NAME2]: this.id,
              parent: this.parent ? { [MOCHA_ID_PROP_NAME2]: this.parent.id } : null
            };
          };
          var constants2 = defineConstants(
            /**
             * {@link Suite}-related constants.
             * @public
             * @memberof Suite
             * @alias constants
             * @readonly
             * @static
             * @enum {string}
             */
            {
              /**
               * Event emitted after a test file has been loaded. Not emitted in browser.
               */
              EVENT_FILE_POST_REQUIRE: "post-require",
              /**
               * Event emitted before a test file has been loaded. In browser, this is emitted once an interface has been selected.
               */
              EVENT_FILE_PRE_REQUIRE: "pre-require",
              /**
               * Event emitted immediately after a test file has been loaded. Not emitted in browser.
               */
              EVENT_FILE_REQUIRE: "require",
              /**
               * Event emitted when `global.run()` is called (use with `delay` option).
               */
              EVENT_ROOT_SUITE_RUN: "run",
              /**
               * Namespace for collection of a `Suite`'s "after all" hooks.
               */
              HOOK_TYPE_AFTER_ALL: "afterAll",
              /**
               * Namespace for collection of a `Suite`'s "after each" hooks.
               */
              HOOK_TYPE_AFTER_EACH: "afterEach",
              /**
               * Namespace for collection of a `Suite`'s "before all" hooks.
               */
              HOOK_TYPE_BEFORE_ALL: "beforeAll",
              /**
               * Namespace for collection of a `Suite`'s "before each" hooks.
               */
              HOOK_TYPE_BEFORE_EACH: "beforeEach",
              /**
               * Emitted after a child `Suite` has been added to a `Suite`.
               */
              EVENT_SUITE_ADD_SUITE: "suite",
              /**
               * Emitted after an "after all" `Hook` has been added to a `Suite`.
               */
              EVENT_SUITE_ADD_HOOK_AFTER_ALL: "afterAll",
              /**
               * Emitted after an "after each" `Hook` has been added to a `Suite`.
               */
              EVENT_SUITE_ADD_HOOK_AFTER_EACH: "afterEach",
              /**
               * Emitted after an "before all" `Hook` has been added to a `Suite`.
               */
              EVENT_SUITE_ADD_HOOK_BEFORE_ALL: "beforeAll",
              /**
               * Emitted after an "before each" `Hook` has been added to a `Suite`.
               */
              EVENT_SUITE_ADD_HOOK_BEFORE_EACH: "beforeEach",
              /**
               * Emitted after a `Test` has been added to a `Suite`.
               */
              EVENT_SUITE_ADD_TEST: "test"
            }
          );
          Suite2.constants = constants2;
        })(suite);
        var EventEmitter = require$$0.EventEmitter;
        var Pending = pending;
        var utils$1 = utils$3;
        var debug2 = browser.exports("mocha:runner");
        var Runnable$1 = runnable;
        var Suite$2 = suite.exports;
        var HOOK_TYPE_BEFORE_EACH = Suite$2.constants.HOOK_TYPE_BEFORE_EACH;
        var HOOK_TYPE_AFTER_EACH = Suite$2.constants.HOOK_TYPE_AFTER_EACH;
        var HOOK_TYPE_AFTER_ALL = Suite$2.constants.HOOK_TYPE_AFTER_ALL;
        var HOOK_TYPE_BEFORE_ALL = Suite$2.constants.HOOK_TYPE_BEFORE_ALL;
        var EVENT_ROOT_SUITE_RUN = Suite$2.constants.EVENT_ROOT_SUITE_RUN;
        var STATE_FAILED = Runnable$1.constants.STATE_FAILED;
        var STATE_PASSED = Runnable$1.constants.STATE_PASSED;
        var STATE_PENDING = Runnable$1.constants.STATE_PENDING;
        var stackFilter = utils$1.stackTraceFilter();
        var stringify = utils$1.stringify;
        const {
          createInvalidExceptionError,
          createUnsupportedError: createUnsupportedError$1,
          createFatalError,
          isMochaError,
          constants: errorConstants
        } = errors$2;
        var globals = [
          "setTimeout",
          "clearTimeout",
          "setInterval",
          "clearInterval",
          "XMLHttpRequest",
          "Date",
          "setImmediate",
          "clearImmediate"
        ];
        var constants$1 = utils$1.defineConstants(
          /**
           * {@link Runner}-related constants.
           * @public
           * @memberof Runner
           * @readonly
           * @alias constants
           * @static
           * @enum {string}
           */
          {
            /**
             * Emitted when {@link Hook} execution begins
             */
            EVENT_HOOK_BEGIN: "hook",
            /**
             * Emitted when {@link Hook} execution ends
             */
            EVENT_HOOK_END: "hook end",
            /**
             * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)
             */
            EVENT_RUN_BEGIN: "start",
            /**
             * Emitted when Root {@link Suite} execution has been delayed via `delay` option
             */
            EVENT_DELAY_BEGIN: "waiting",
            /**
             * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`
             */
            EVENT_DELAY_END: "ready",
            /**
             * Emitted when Root {@link Suite} execution ends
             */
            EVENT_RUN_END: "end",
            /**
             * Emitted when {@link Suite} execution begins
             */
            EVENT_SUITE_BEGIN: "suite",
            /**
             * Emitted when {@link Suite} execution ends
             */
            EVENT_SUITE_END: "suite end",
            /**
             * Emitted when {@link Test} execution begins
             */
            EVENT_TEST_BEGIN: "test",
            /**
             * Emitted when {@link Test} execution ends
             */
            EVENT_TEST_END: "test end",
            /**
             * Emitted when {@link Test} execution fails
             */
            EVENT_TEST_FAIL: "fail",
            /**
             * Emitted when {@link Test} execution succeeds
             */
            EVENT_TEST_PASS: "pass",
            /**
             * Emitted when {@link Test} becomes pending
             */
            EVENT_TEST_PENDING: "pending",
            /**
             * Emitted when {@link Test} execution has failed, but will retry
             */
            EVENT_TEST_RETRY: "retry",
            /**
             * Initial state of Runner
             */
            STATE_IDLE: "idle",
            /**
             * State set to this value when the Runner has started running
             */
            STATE_RUNNING: "running",
            /**
             * State set to this value when the Runner has stopped
             */
            STATE_STOPPED: "stopped"
          }
        );
        class Runner extends EventEmitter {
          /**
           * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.
           *
           * @extends external:EventEmitter
           * @public
           * @class
           * @param {Suite} suite - Root suite
           * @param {Object} [opts] - Settings object
           * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.
           * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.
           * @param {boolean} [opts.dryRun] - Whether to report tests without running them.
           * @param {boolean} [opts.failZero] - Whether to fail test run if zero tests encountered.
           */
          constructor(suite2, opts = {}) {
            super();
            var self2 = this;
            this._globals = [];
            this._abort = false;
            this.suite = suite2;
            this._opts = opts;
            this.state = constants$1.STATE_IDLE;
            this.total = suite2.total();
            this.failures = 0;
            this._eventListeners = /* @__PURE__ */ new Map();
            this.on(constants$1.EVENT_TEST_END, function(test3) {
              if (test3.type === "test" && test3.retriedTest() && test3.parent) {
                var idx = test3.parent.tests && test3.parent.tests.indexOf(test3.retriedTest());
                if (idx > -1) test3.parent.tests[idx] = test3;
              }
              self2.checkGlobals(test3);
            });
            this.on(constants$1.EVENT_HOOK_END, function(hook2) {
              self2.checkGlobals(hook2);
            });
            this._defaultGrep = /.*/;
            this.grep(this._defaultGrep);
            this.globals(this.globalProps());
            this.uncaught = this._uncaught.bind(this);
            this.unhandled = (reason, promise) => {
              if (isMochaError(reason)) {
                debug2(
                  "trapped unhandled rejection coming out of Mocha; forwarding to uncaught handler:",
                  reason
                );
                this.uncaught(reason);
              } else {
                debug2(
                  "trapped unhandled rejection from (probably) user code; re-emitting on process"
                );
                this._removeEventListener(
                  process2,
                  "unhandledRejection",
                  this.unhandled
                );
                try {
                  process2.emit("unhandledRejection", reason, promise);
                } finally {
                  this._addEventListener(process2, "unhandledRejection", this.unhandled);
                }
              }
            };
          }
        }
        Runner.immediately = commonjsGlobal.setImmediate || nextTick$1;
        Runner.prototype._addEventListener = function(target, eventName, listener) {
          debug2(
            "_addEventListener(): adding for event %s; %d current listeners",
            eventName,
            target.listenerCount(eventName)
          );
          if (this._eventListeners.has(target) && this._eventListeners.get(target).has(eventName) && this._eventListeners.get(target).get(eventName).has(listener)) {
            debug2(
              "warning: tried to attach duplicate event listener for %s",
              eventName
            );
            return;
          }
          target.on(eventName, listener);
          const targetListeners = this._eventListeners.has(target) ? this._eventListeners.get(target) : /* @__PURE__ */ new Map();
          const targetEventListeners = targetListeners.has(eventName) ? targetListeners.get(eventName) : /* @__PURE__ */ new Set();
          targetEventListeners.add(listener);
          targetListeners.set(eventName, targetEventListeners);
          this._eventListeners.set(target, targetListeners);
        };
        Runner.prototype._removeEventListener = function(target, eventName, listener) {
          target.removeListener(eventName, listener);
          if (this._eventListeners.has(target)) {
            const targetListeners = this._eventListeners.get(target);
            if (targetListeners.has(eventName)) {
              const targetEventListeners = targetListeners.get(eventName);
              targetEventListeners.delete(listener);
              if (!targetEventListeners.size) {
                targetListeners.delete(eventName);
              }
            }
            if (!targetListeners.size) {
              this._eventListeners.delete(target);
            }
          } else {
            debug2("trying to remove listener for untracked object %s", target);
          }
        };
        Runner.prototype.dispose = function() {
          this.removeAllListeners();
          this._eventListeners.forEach((targetListeners, target) => {
            targetListeners.forEach((targetEventListeners, eventName) => {
              targetEventListeners.forEach((listener) => {
                target.removeListener(eventName, listener);
              });
            });
          });
          this._eventListeners.clear();
        };
        Runner.prototype.grep = function(re, invert) {
          debug2("grep(): setting to %s", re);
          this._grep = re;
          this._invert = invert;
          this.total = this.grepTotal(this.suite);
          return this;
        };
        Runner.prototype.grepTotal = function(suite2) {
          var self2 = this;
          var total = 0;
          suite2.eachTest(function(test3) {
            var match = self2._grep.test(test3.fullTitle());
            if (self2._invert) {
              match = !match;
            }
            if (match) {
              total++;
            }
          });
          return total;
        };
        Runner.prototype.globalProps = function() {
          var props = Object.keys(commonjsGlobal);
          for (var i = 0; i < globals.length; ++i) {
            if (~props.indexOf(globals[i])) {
              continue;
            }
            props.push(globals[i]);
          }
          return props;
        };
        Runner.prototype.globals = function(arr) {
          if (!arguments.length) {
            return this._globals;
          }
          debug2("globals(): setting to %O", arr);
          this._globals = this._globals.concat(arr);
          return this;
        };
        Runner.prototype.checkGlobals = function(test3) {
          if (!this.checkLeaks) {
            return;
          }
          var ok = this._globals;
          var globals2 = this.globalProps();
          var leaks;
          if (test3) {
            ok = ok.concat(test3._allowedGlobals || []);
          }
          if (this.prevGlobalsLength === globals2.length) {
            return;
          }
          this.prevGlobalsLength = globals2.length;
          leaks = filterLeaks(ok, globals2);
          this._globals = this._globals.concat(leaks);
          if (leaks.length) {
            var msg = `global leak(s) detected: ${leaks.map((e) => `'${e}'`).join(", ")}`;
            this.fail(test3, new Error(msg));
          }
        };
        Runner.prototype.fail = function(test3, err, force) {
          force = force === true;
          if (test3.isPending() && !force) {
            return;
          }
          if (this.state === constants$1.STATE_STOPPED) {
            if (err.code === errorConstants.MULTIPLE_DONE) {
              throw err;
            }
            throw createFatalError(
              "Test failed after root suite execution completed!",
              err
            );
          }
          ++this.failures;
          debug2("total number of failures: %d", this.failures);
          test3.state = STATE_FAILED;
          if (!isError(err)) {
            err = thrown2Error(err);
          }
          if (!this.fullStackTrace) {
            const alreadyFiltered = /* @__PURE__ */ new Set();
            let currentErr = err;
            while (currentErr && currentErr.stack && !alreadyFiltered.has(currentErr)) {
              alreadyFiltered.add(currentErr);
              try {
                currentErr.stack = stackFilter(currentErr.stack);
              } catch (ignore) {
              }
              currentErr = currentErr.cause;
            }
          }
          this.emit(constants$1.EVENT_TEST_FAIL, test3, err);
        };
        Runner.prototype.hook = function(name2, fn) {
          if (this._opts.dryRun) return fn();
          var suite2 = this.suite;
          var hooks = suite2.getHooks(name2);
          var self2 = this;
          function next(i) {
            var hook2 = hooks[i];
            if (!hook2) {
              return fn();
            }
            self2.currentRunnable = hook2;
            if (name2 === HOOK_TYPE_BEFORE_ALL) {
              hook2.ctx.currentTest = hook2.parent.tests[0];
            } else if (name2 === HOOK_TYPE_AFTER_ALL) {
              hook2.ctx.currentTest = hook2.parent.tests[hook2.parent.tests.length - 1];
            } else {
              hook2.ctx.currentTest = self2.test;
            }
            setHookTitle(hook2);
            hook2.allowUncaught = self2.allowUncaught;
            self2.emit(constants$1.EVENT_HOOK_BEGIN, hook2);
            if (!hook2.listeners("error").length) {
              self2._addEventListener(hook2, "error", function(err) {
                self2.fail(hook2, err);
              });
            }
            hook2.run(function cbHookRun(err) {
              var testError = hook2.error();
              if (testError) {
                self2.fail(self2.test, testError);
              }
              if (hook2.pending) {
                if (name2 === HOOK_TYPE_AFTER_EACH) {
                  if (self2.test) {
                    self2.test.pending = true;
                  }
                } else if (name2 === HOOK_TYPE_BEFORE_EACH) {
                  if (self2.test) {
                    self2.test.pending = true;
                  }
                  self2.emit(constants$1.EVENT_HOOK_END, hook2);
                  hook2.pending = false;
                  return fn(new Error("abort hookDown"));
                } else if (name2 === HOOK_TYPE_BEFORE_ALL) {
                  suite2.tests.forEach(function(test3) {
                    test3.pending = true;
                  });
                  suite2.suites.forEach(function(suite3) {
                    suite3.pending = true;
                  });
                  hooks = [];
                } else {
                  hook2.pending = false;
                  var errForbid = createUnsupportedError$1("`this.skip` forbidden");
                  self2.fail(hook2, errForbid);
                  return fn(errForbid);
                }
              } else if (err) {
                self2.fail(hook2, err);
                return fn(err);
              }
              self2.emit(constants$1.EVENT_HOOK_END, hook2);
              delete hook2.ctx.currentTest;
              setHookTitle(hook2);
              next(++i);
            });
            function setHookTitle(hook3) {
              hook3.originalTitle = hook3.originalTitle || hook3.title;
              if (hook3.ctx && hook3.ctx.currentTest) {
                hook3.title = `${hook3.originalTitle} for "${hook3.ctx.currentTest.title}"`;
              } else {
                var parentTitle;
                if (hook3.parent.title) {
                  parentTitle = hook3.parent.title;
                } else {
                  parentTitle = hook3.parent.root ? "{root}" : "";
                }
                hook3.title = `${hook3.originalTitle} in "${parentTitle}"`;
              }
            }
          }
          Runner.immediately(function() {
            next(0);
          });
        };
        Runner.prototype.hooks = function(name2, suites, fn) {
          var self2 = this;
          var orig = this.suite;
          function next(suite2) {
            self2.suite = suite2;
            if (!suite2) {
              self2.suite = orig;
              return fn();
            }
            self2.hook(name2, function(err) {
              if (err) {
                var errSuite = self2.suite;
                self2.suite = orig;
                return fn(err, errSuite);
              }
              next(suites.pop());
            });
          }
          next(suites.pop());
        };
        Runner.prototype.hookUp = function(name2, fn) {
          var suites = [this.suite].concat(this.parents()).reverse();
          this.hooks(name2, suites, fn);
        };
        Runner.prototype.hookDown = function(name2, fn) {
          var suites = [this.suite].concat(this.parents());
          this.hooks(name2, suites, fn);
        };
        Runner.prototype.parents = function() {
          var suite2 = this.suite;
          var suites = [];
          while (suite2.parent) {
            suite2 = suite2.parent;
            suites.push(suite2);
          }
          return suites;
        };
        Runner.prototype.runTest = function(fn) {
          if (this._opts.dryRun) return Runner.immediately(fn);
          var self2 = this;
          var test3 = this.test;
          if (!test3) {
            return;
          }
          if (this.asyncOnly) {
            test3.asyncOnly = true;
          }
          this._addEventListener(test3, "error", function(err) {
            self2.fail(test3, err);
          });
          if (this.allowUncaught) {
            test3.allowUncaught = true;
            return test3.run(fn);
          }
          try {
            test3.run(fn);
          } catch (err) {
            fn(err);
          }
        };
        Runner.prototype.runTests = function(suite2, fn) {
          var self2 = this;
          var tests = suite2.tests.slice();
          var test3;
          function hookErr(_, errSuite, after) {
            var orig = self2.suite;
            self2.suite = after ? errSuite.parent : errSuite;
            if (self2.suite) {
              self2.hookUp(HOOK_TYPE_AFTER_EACH, function(err2, errSuite2) {
                self2.suite = orig;
                if (err2) {
                  return hookErr(err2, errSuite2, true);
                }
                fn(errSuite);
              });
            } else {
              self2.suite = orig;
              fn(errSuite);
            }
          }
          function next(err, errSuite) {
            if (self2.failures && suite2._bail) {
              tests = [];
            }
            if (self2._abort) {
              return fn();
            }
            if (err) {
              return hookErr(err, errSuite, true);
            }
            test3 = tests.shift();
            if (!test3) {
              return fn();
            }
            var match = self2._grep.test(test3.fullTitle());
            if (self2._invert) {
              match = !match;
            }
            if (!match) {
              if (self2._grep !== self2._defaultGrep) {
                Runner.immediately(next);
              } else {
                next();
              }
              return;
            }
            if (test3.isPending()) {
              if (self2.forbidPending) {
                self2.fail(test3, new Error("Pending test forbidden"), true);
              } else {
                test3.state = STATE_PENDING;
                self2.emit(constants$1.EVENT_TEST_PENDING, test3);
              }
              self2.emit(constants$1.EVENT_TEST_END, test3);
              return next();
            }
            self2.emit(constants$1.EVENT_TEST_BEGIN, self2.test = test3);
            self2.hookDown(HOOK_TYPE_BEFORE_EACH, function(err2, errSuite2) {
              if (test3.isPending()) {
                if (self2.forbidPending) {
                  self2.fail(test3, new Error("Pending test forbidden"), true);
                } else {
                  test3.state = STATE_PENDING;
                  self2.emit(constants$1.EVENT_TEST_PENDING, test3);
                }
                self2.emit(constants$1.EVENT_TEST_END, test3);
                var origSuite = self2.suite;
                self2.suite = errSuite2 || self2.suite;
                return self2.hookUp(HOOK_TYPE_AFTER_EACH, function(e, eSuite) {
                  self2.suite = origSuite;
                  next(e, eSuite);
                });
              }
              if (err2) {
                return hookErr(err2, errSuite2, false);
              }
              self2.currentRunnable = self2.test;
              self2.runTest(function(err3) {
                test3 = self2.test;
                if (test3.pending) {
                  if (self2.forbidPending) {
                    self2.fail(test3, new Error("Pending test forbidden"), true);
                  } else {
                    test3.state = STATE_PENDING;
                    self2.emit(constants$1.EVENT_TEST_PENDING, test3);
                  }
                  self2.emit(constants$1.EVENT_TEST_END, test3);
                  return self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
                } else if (err3) {
                  var retry = test3.currentRetry();
                  if (retry < test3.retries()) {
                    var clonedTest = test3.clone();
                    clonedTest.currentRetry(retry + 1);
                    tests.unshift(clonedTest);
                    self2.emit(constants$1.EVENT_TEST_RETRY, test3, err3);
                    return self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
                  } else {
                    self2.fail(test3, err3);
                  }
                  self2.emit(constants$1.EVENT_TEST_END, test3);
                  return self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
                }
                test3.state = STATE_PASSED;
                self2.emit(constants$1.EVENT_TEST_PASS, test3);
                self2.emit(constants$1.EVENT_TEST_END, test3);
                self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
              });
            });
          }
          this.next = next;
          this.hookErr = hookErr;
          next();
        };
        Runner.prototype.runSuite = function(suite2, fn) {
          var i = 0;
          var self2 = this;
          var total = this.grepTotal(suite2);
          debug2("runSuite(): running %s", suite2.fullTitle());
          if (!total || self2.failures && suite2._bail) {
            debug2("runSuite(): bailing");
            return fn();
          }
          this.emit(constants$1.EVENT_SUITE_BEGIN, this.suite = suite2);
          function next(errSuite) {
            if (errSuite) {
              if (errSuite === suite2) {
                return done2();
              }
              return done2(errSuite);
            }
            if (self2._abort) {
              return done2();
            }
            var curr = suite2.suites[i++];
            if (!curr) {
              return done2();
            }
            if (self2._grep !== self2._defaultGrep) {
              Runner.immediately(function() {
                self2.runSuite(curr, next);
              });
            } else {
              self2.runSuite(curr, next);
            }
          }
          function done2(errSuite) {
            self2.suite = suite2;
            self2.nextSuite = next;
            delete self2.test;
            self2.hook(HOOK_TYPE_AFTER_ALL, function() {
              self2.emit(constants$1.EVENT_SUITE_END, suite2);
              fn(errSuite);
            });
          }
          this.nextSuite = next;
          this.hook(HOOK_TYPE_BEFORE_ALL, function(err) {
            if (err) {
              return done2();
            }
            self2.runTests(suite2, next);
          });
        };
        Runner.prototype._uncaught = function(err) {
          if (!(this instanceof Runner)) {
            throw createFatalError(
              "Runner#uncaught() called with invalid context",
              this
            );
          }
          if (err instanceof Pending) {
            debug2("uncaught(): caught a Pending");
            return;
          }
          if (this.allowUncaught && !utils$1.isBrowser()) {
            debug2("uncaught(): bubbling exception due to --allow-uncaught");
            throw err;
          }
          if (this.state === constants$1.STATE_STOPPED) {
            debug2("uncaught(): throwing after run has completed!");
            throw err;
          }
          if (err) {
            debug2("uncaught(): got truthy exception %O", err);
          } else {
            debug2("uncaught(): undefined/falsy exception");
            err = createInvalidExceptionError(
              "Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger",
              err
            );
          }
          if (!isError(err)) {
            err = thrown2Error(err);
            debug2('uncaught(): converted "error" %o to Error', err);
          }
          err.uncaught = true;
          var runnable2 = this.currentRunnable;
          if (!runnable2) {
            runnable2 = new Runnable$1("Uncaught error outside test suite");
            debug2("uncaught(): no current Runnable; created a phony one");
            runnable2.parent = this.suite;
            if (this.state === constants$1.STATE_RUNNING) {
              debug2("uncaught(): failing gracefully");
              this.fail(runnable2, err);
            } else {
              debug2("uncaught(): test run has not yet started; unrecoverable");
              this.emit(constants$1.EVENT_RUN_BEGIN);
              this.fail(runnable2, err);
              this.emit(constants$1.EVENT_RUN_END);
            }
            return;
          }
          runnable2.clearTimeout();
          if (runnable2.isFailed()) {
            debug2("uncaught(): Runnable has already failed");
            return;
          } else if (runnable2.isPending()) {
            debug2("uncaught(): pending Runnable wound up failing!");
            this.fail(runnable2, err, true);
            return;
          }
          if (runnable2.isPassed()) {
            debug2("uncaught(): Runnable has already passed; bailing gracefully");
            this.fail(runnable2, err);
            this.abort();
          } else {
            debug2("uncaught(): forcing Runnable to complete with Error");
            return runnable2.callback(err);
          }
        };
        Runner.prototype.run = function(fn, opts = {}) {
          var rootSuite = this.suite;
          var options = opts.options || {};
          debug2("run(): got options: %O", options);
          fn = fn || function() {
          };
          const end = () => {
            if (!this.total && this._opts.failZero) this.failures = 1;
            debug2("run(): root suite completed; emitting %s", constants$1.EVENT_RUN_END);
            this.emit(constants$1.EVENT_RUN_END);
          };
          const begin = () => {
            debug2("run(): emitting %s", constants$1.EVENT_RUN_BEGIN);
            this.emit(constants$1.EVENT_RUN_BEGIN);
            debug2("run(): emitted %s", constants$1.EVENT_RUN_BEGIN);
            this.runSuite(rootSuite, end);
          };
          const prepare = () => {
            debug2("run(): starting");
            if (rootSuite.hasOnly()) {
              rootSuite.filterOnly();
              debug2("run(): filtered exclusive Runnables");
            }
            this.state = constants$1.STATE_RUNNING;
            if (this._opts.delay) {
              this.emit(constants$1.EVENT_DELAY_END);
              debug2('run(): "delay" ended');
            }
            return begin();
          };
          if (this._opts.cleanReferencesAfterRun) {
            this.on(constants$1.EVENT_SUITE_END, (suite2) => {
              suite2.cleanReferences();
            });
          }
          this.on(constants$1.EVENT_RUN_END, function() {
            this.state = constants$1.STATE_STOPPED;
            debug2("run(): emitted %s", constants$1.EVENT_RUN_END);
            fn(this.failures);
          });
          this._removeEventListener(process2, "uncaughtException", this.uncaught);
          this._removeEventListener(process2, "unhandledRejection", this.unhandled);
          this._addEventListener(process2, "uncaughtException", this.uncaught);
          this._addEventListener(process2, "unhandledRejection", this.unhandled);
          if (this._opts.delay) {
            this.emit(constants$1.EVENT_DELAY_BEGIN, rootSuite);
            rootSuite.once(EVENT_ROOT_SUITE_RUN, prepare);
            debug2("run(): waiting for green light due to --delay");
          } else {
            Runner.immediately(prepare);
          }
          return this;
        };
        Runner.prototype.linkPartialObjects = function(value) {
          return this;
        };
        Runner.prototype.runAsync = async function runAsync(opts = {}) {
          return new Promise((resolve2) => {
            this.run(resolve2, opts);
          });
        };
        Runner.prototype.abort = function() {
          debug2("abort(): aborting");
          this._abort = true;
          return this;
        };
        Runner.prototype.isParallelMode = function isParallelMode() {
          return false;
        };
        Runner.prototype.workerReporter = function() {
          throw createUnsupportedError$1("workerReporter() not supported in serial mode");
        };
        function filterLeaks(ok, globals2) {
          return globals2.filter(function(key) {
            if (/^\d+/.test(key)) {
              return false;
            }
            if (commonjsGlobal.navigator && /^getInterface/.test(key)) {
              return false;
            }
            if (commonjsGlobal.navigator && /^\d+/.test(key)) {
              return false;
            }
            if (/^mocha-/.test(key)) {
              return false;
            }
            var matched = ok.filter(function(ok2) {
              if (~ok2.indexOf("*")) {
                return key.indexOf(ok2.split("*")[0]) === 0;
              }
              return key === ok2;
            });
            return !matched.length && (!commonjsGlobal.navigator || key !== "onerror");
          });
        }
        function isError(err) {
          return err instanceof Error || err && typeof err.message === "string";
        }
        function thrown2Error(err) {
          return new Error(
            `the ${utils$1.canonicalType(err)} ${stringify(
              err
            )} was thrown, throw an Error :)`
          );
        }
        Runner.constants = constants$1;
        var runner2 = Runner;
        (function(module3, exports2) {
          var diff2 = lib;
          var milliseconds2 = ms$1;
          var utils2 = utils$3;
          var supportsColor = require$$18;
          var symbols = browser$1;
          var constants2 = runner2.constants;
          var EVENT_TEST_PASS2 = constants2.EVENT_TEST_PASS;
          var EVENT_TEST_FAIL2 = constants2.EVENT_TEST_FAIL;
          const isBrowser = utils2.isBrowser();
          function getBrowserWindowSize() {
            if ("innerHeight" in commonjsGlobal) {
              return [commonjsGlobal.innerHeight, commonjsGlobal.innerWidth];
            }
            return [640, 480];
          }
          exports2 = module3.exports = Base;
          var isatty = isBrowser || process2.stdout.isTTY && process2.stderr.isTTY;
          var consoleLog = console.log;
          exports2.useColors = !isBrowser && (supportsColor.stdout || process2.env.MOCHA_COLORS !== void 0);
          exports2.inlineDiffs = false;
          exports2.maxDiffSize = 8192;
          exports2.colors = {
            pass: 90,
            fail: 31,
            "bright pass": 92,
            "bright fail": 91,
            "bright yellow": 93,
            pending: 36,
            suite: 0,
            "error title": 0,
            "error message": 31,
            "error stack": 90,
            checkmark: 32,
            fast: 90,
            medium: 33,
            slow: 31,
            green: 32,
            light: 90,
            "diff gutter": 90,
            "diff added": 32,
            "diff removed": 31,
            "diff added inline": "30;42",
            "diff removed inline": "30;41"
          };
          exports2.symbols = {
            ok: symbols.success,
            err: symbols.error,
            dot: ".",
            comma: ",",
            bang: "!"
          };
          var color = exports2.color = function(type3, str) {
            if (!exports2.useColors) {
              return String(str);
            }
            return "\x1B[" + exports2.colors[type3] + "m" + str + "\x1B[0m";
          };
          exports2.window = {
            width: 75
          };
          if (isatty) {
            if (isBrowser) {
              exports2.window.width = getBrowserWindowSize()[1];
            } else {
              exports2.window.width = process2.stdout.getWindowSize(1)[0];
            }
          }
          exports2.cursor = {
            hide: function() {
              isatty && process2.stdout.write("\x1B[?25l");
            },
            show: function() {
              isatty && process2.stdout.write("\x1B[?25h");
            },
            deleteLine: function() {
              isatty && process2.stdout.write("\x1B[2K");
            },
            beginningOfLine: function() {
              isatty && process2.stdout.write("\x1B[0G");
            },
            CR: function() {
              if (isatty) {
                exports2.cursor.deleteLine();
                exports2.cursor.beginningOfLine();
              } else {
                process2.stdout.write("\r");
              }
            }
          };
          var showDiff = exports2.showDiff = function(err) {
            return err && err.showDiff !== false && sameType(err.actual, err.expected) && err.expected !== void 0;
          };
          function stringifyDiffObjs(err) {
            if (!utils2.isString(err.actual) || !utils2.isString(err.expected)) {
              err.actual = utils2.stringify(err.actual);
              err.expected = utils2.stringify(err.expected);
            }
          }
          var generateDiff = exports2.generateDiff = function(actual, expected) {
            try {
              var maxLen = exports2.maxDiffSize;
              var skipped = 0;
              if (maxLen > 0) {
                skipped = Math.max(actual.length - maxLen, expected.length - maxLen);
                actual = actual.slice(0, maxLen);
                expected = expected.slice(0, maxLen);
              }
              let result = exports2.inlineDiffs ? inlineDiff(actual, expected) : unifiedDiff(actual, expected);
              if (skipped > 0) {
                result = `${result}
      [mocha] output truncated to ${maxLen} characters, see "maxDiffSize" reporter-option
`;
              }
              return result;
            } catch (err) {
              var msg = "\n      " + color("diff added", "+ expected") + " " + color("diff removed", "- actual:  failed to generate Mocha diff") + "\n";
              return msg;
            }
          };
          var getFullErrorStack = function(err, seen) {
            if (seen && seen.has(err)) {
              return { message: "", msg: "<circular>", stack: "" };
            }
            var message;
            if (typeof err.inspect === "function") {
              message = err.inspect() + "";
            } else if (err.message && typeof err.message.toString === "function") {
              message = err.message + "";
            } else {
              message = "";
            }
            var msg;
            var stack = err.stack || message;
            var index = message ? stack.indexOf(message) : -1;
            if (index === -1) {
              msg = message;
            } else {
              index += message.length;
              msg = stack.slice(0, index);
              stack = stack.slice(index + 1);
              if (err.cause) {
                seen = seen || /* @__PURE__ */ new Set();
                seen.add(err);
                const causeStack = getFullErrorStack(err.cause, seen);
                stack += "\n   Caused by: " + causeStack.msg + (causeStack.stack ? "\n" + causeStack.stack : "");
              }
            }
            return {
              message,
              msg,
              stack
            };
          };
          exports2.list = function(failures) {
            var multipleErr, multipleTest;
            Base.consoleLog();
            failures.forEach(function(test3, i) {
              var fmt = color("error title", "  %s) %s:\n") + color("error message", "     %s") + color("error stack", "\n%s\n");
              var err;
              if (test3.err && test3.err.multiple) {
                if (multipleTest !== test3) {
                  multipleTest = test3;
                  multipleErr = [test3.err].concat(test3.err.multiple);
                }
                err = multipleErr.shift();
              } else {
                err = test3.err;
              }
              var { message, msg, stack } = getFullErrorStack(err);
              if (err.uncaught) {
                msg = "Uncaught " + msg;
              }
              if (!exports2.hideDiff && showDiff(err)) {
                stringifyDiffObjs(err);
                fmt = color("error title", "  %s) %s:\n%s") + color("error stack", "\n%s\n");
                var match = message.match(/^([^:]+): expected/);
                msg = "\n      " + color("error message", match ? match[1] : msg);
                msg += generateDiff(err.actual, err.expected);
              }
              stack = stack.replace(/^/gm, "  ");
              var testTitle = "";
              test3.titlePath().forEach(function(str, index) {
                if (index !== 0) {
                  testTitle += "\n     ";
                }
                for (var i2 = 0; i2 < index; i2++) {
                  testTitle += "  ";
                }
                testTitle += str;
              });
              Base.consoleLog(fmt, i + 1, testTitle, msg, stack);
            });
          };
          function Base(runner3, options) {
            var failures = this.failures = [];
            if (!runner3) {
              throw new TypeError("Missing runner argument");
            }
            this.options = options || {};
            this.runner = runner3;
            this.stats = runner3.stats;
            var maxDiffSizeOpt = this.options.reporterOption && this.options.reporterOption.maxDiffSize;
            if (maxDiffSizeOpt !== void 0 && !isNaN(Number(maxDiffSizeOpt))) {
              exports2.maxDiffSize = Number(maxDiffSizeOpt);
            }
            runner3.on(EVENT_TEST_PASS2, function(test3) {
              if (test3.duration > test3.slow()) {
                test3.speed = "slow";
              } else if (test3.duration > test3.slow() / 2) {
                test3.speed = "medium";
              } else {
                test3.speed = "fast";
              }
            });
            runner3.on(EVENT_TEST_FAIL2, function(test3, err) {
              if (showDiff(err)) {
                stringifyDiffObjs(err);
              }
              if (test3.err && err instanceof Error) {
                test3.err.multiple = (test3.err.multiple || []).concat(err);
              } else {
                test3.err = err;
              }
              failures.push(test3);
            });
          }
          Base.prototype.epilogue = function() {
            var stats = this.stats;
            var fmt;
            Base.consoleLog();
            fmt = color("bright pass", " ") + color("green", " %d passing") + color("light", " (%s)");
            Base.consoleLog(fmt, stats.passes || 0, milliseconds2(stats.duration));
            if (stats.pending) {
              fmt = color("pending", " ") + color("pending", " %d pending");
              Base.consoleLog(fmt, stats.pending);
            }
            if (stats.failures) {
              fmt = color("fail", "  %d failing");
              Base.consoleLog(fmt, stats.failures);
              Base.list(this.failures);
              Base.consoleLog();
            }
            Base.consoleLog();
          };
          function pad2(str, len) {
            str = String(str);
            return Array(len - str.length + 1).join(" ") + str;
          }
          function inlineDiff(actual, expected) {
            var msg = errorDiff(actual, expected);
            var lines = msg.split("\n");
            if (lines.length > 4) {
              var width = String(lines.length).length;
              msg = lines.map(function(str, i) {
                return pad2(++i, width) + " | " + str;
              }).join("\n");
            }
            msg = "\n" + color("diff removed inline", "actual") + " " + color("diff added inline", "expected") + "\n\n" + msg + "\n";
            msg = msg.replace(/^/gm, "      ");
            return msg;
          }
          function unifiedDiff(actual, expected) {
            var indent = "      ";
            function cleanUp(line2) {
              if (line2[0] === "+") {
                return indent + colorLines("diff added", line2);
              }
              if (line2[0] === "-") {
                return indent + colorLines("diff removed", line2);
              }
              if (line2.match(/@@/)) {
                return "--";
              }
              if (line2.match(/\\ No newline/)) {
                return null;
              }
              return indent + line2;
            }
            function notBlank(line2) {
              return typeof line2 !== "undefined" && line2 !== null;
            }
            var msg = diff2.createPatch("string", actual, expected);
            var lines = msg.split("\n").splice(5);
            return "\n      " + colorLines("diff added", "+ expected") + " " + colorLines("diff removed", "- actual") + "\n\n" + lines.map(cleanUp).filter(notBlank).join("\n");
          }
          function errorDiff(actual, expected) {
            return diff2.diffWordsWithSpace(actual, expected).map(function(str) {
              if (str.added) {
                return colorLines("diff added inline", str.value);
              }
              if (str.removed) {
                return colorLines("diff removed inline", str.value);
              }
              return str.value;
            }).join("");
          }
          function colorLines(name2, str) {
            return str.split("\n").map(function(str2) {
              return color(name2, str2);
            }).join("\n");
          }
          var objToString = Object.prototype.toString;
          function sameType(a, b) {
            return objToString.call(a) === objToString.call(b);
          }
          Base.consoleLog = consoleLog;
          Base.abstract = true;
        })(base$1, base$1.exports);
        var dot = { exports: {} };
        (function(module3, exports2) {
          var Base = base$1.exports;
          var inherits2 = utils$3.inherits;
          var constants2 = runner2.constants;
          var EVENT_TEST_PASS2 = constants2.EVENT_TEST_PASS;
          var EVENT_TEST_FAIL2 = constants2.EVENT_TEST_FAIL;
          var EVENT_RUN_BEGIN2 = constants2.EVENT_RUN_BEGIN;
          var EVENT_TEST_PENDING2 = constants2.EVENT_TEST_PENDING;
          var EVENT_RUN_END2 = constants2.EVENT_RUN_END;
          module3.exports = Dot;
          function Dot(runner3, options) {
            Base.call(this, runner3, options);
            var self2 = this;
            var width = Base.window.width * 0.75 | 0;
            var n = -1;
            runner3.on(EVENT_RUN_BEGIN2, function() {
              process2.stdout.write("\n");
            });
            runner3.on(EVENT_TEST_PENDING2, function() {
              if (++n % width === 0) {
                process2.stdout.write("\n  ");
              }
              process2.stdout.write(Base.color("pending", Base.symbols.comma));
            });
            runner3.on(EVENT_TEST_PASS2, function(test3) {
              if (++n % width === 0) {
                process2.stdout.write("\n  ");
              }
              if (test3.speed === "slow") {
                process2.stdout.write(Base.color("bright yellow", Base.symbols.dot));
              } else {
                process2.stdout.write(Base.color(test3.speed, Base.symbols.dot));
              }
            });
            runner3.on(EVENT_TEST_FAIL2, function() {
              if (++n % width === 0) {
                process2.stdout.write("\n  ");
              }
              process2.stdout.write(Base.color("fail", Base.symbols.bang));
            });
            runner3.once(EVENT_RUN_END2, function() {
              process2.stdout.write("\n");
              self2.epilogue();
            });
          }
          inherits2(Dot, Base);
          Dot.description = "dot matrix representation";
        })(dot);
        var doc = { exports: {} };
        (function(module3, exports2) {
          var Base = base$1.exports;
          var utils2 = utils$3;
          var constants2 = runner2.constants;
          var EVENT_TEST_PASS2 = constants2.EVENT_TEST_PASS;
          var EVENT_TEST_FAIL2 = constants2.EVENT_TEST_FAIL;
          var EVENT_SUITE_BEGIN2 = constants2.EVENT_SUITE_BEGIN;
          var EVENT_SUITE_END = constants2.EVENT_SUITE_END;
          module3.exports = Doc;
          function Doc(runner3, options) {
            Base.call(this, runner3, options);
            var indents = 2;
            function indent() {
              return Array(indents).join("  ");
            }
            runner3.on(EVENT_SUITE_BEGIN2, function(suite2) {
              if (suite2.root) {
                return;
              }
              ++indents;
              Base.consoleLog('%s<section class="suite">', indent());
              ++indents;
              Base.consoleLog("%s<h1>%s</h1>", indent(), utils2.escape(suite2.title));
              Base.consoleLog("%s<dl>", indent());
            });
            runner3.on(EVENT_SUITE_END, function(suite2) {
              if (suite2.root) {
                return;
              }
              Base.consoleLog("%s</dl>", indent());
              --indents;
              Base.consoleLog("%s</section>", indent());
              --indents;
            });
            runner3.on(EVENT_TEST_PASS2, function(test3) {
              Base.consoleLog("%s  <dt>%s</dt>", indent(), utils2.escape(test3.title));
              Base.consoleLog("%s  <dt>%s</dt>", indent(), utils2.escape(test3.file));
              var code = utils2.escape(utils2.clean(test3.body));
              Base.consoleLog("%s  <dd><pre><code>%s</code></pre></dd>", indent(), code);
            });
            runner3.on(EVENT_TEST_FAIL2, function(test3, err) {
              Base.consoleLog(
                '%s  <dt class="error">%s</dt>',
                indent(),
                utils2.escape(test3.title)
              );
              Base.consoleLog(
                '%s  <dt class="error">%s</dt>',
                indent(),
                utils2.escape(test3.file)
              );
              var code = utils2.escape(utils2.clean(test3.body));
              Base.consoleLog(
                '%s  <dd class="error"><pre><code>%s</code></pre></dd>',
                indent(),
                code
              );
              Base.consoleLog(
                '%s  <dd class="error">%s</dd>',
                indent(),
                utils2.escape(err)
              );
            });
          }
          Doc.description = "HTML documentation";
        })(doc);
        var tap = { exports: {} };
        (function(module3, exports2) {
          var util = require$$0$1;
          var Base = base$1.exports;
          var constants2 = runner2.constants;
          var EVENT_TEST_PASS2 = constants2.EVENT_TEST_PASS;
          var EVENT_TEST_FAIL2 = constants2.EVENT_TEST_FAIL;
          var EVENT_RUN_BEGIN2 = constants2.EVENT_RUN_BEGIN;
          var EVENT_RUN_END2 = constants2.EVENT_RUN_END;
          var EVENT_TEST_PENDING2 = constants2.EVENT_TEST_PENDING;
          var EVENT_TEST_END2 = constants2.EVENT_TEST_END;
          var inherits2 = utils$3.inherits;
          var sprintf = util.format;
          module3.exports = TAP;
          function TAP(runner3, options) {
            Base.call(this, runner3, options);
            var self2 = this;
            var n = 1;
            var tapVersion = "12";
            if (options && options.reporterOptions) {
              if (options.reporterOptions.tapVersion) {
                tapVersion = options.reporterOptions.tapVersion.toString();
              }
            }
            this._producer = createProducer(tapVersion);
            runner3.once(EVENT_RUN_BEGIN2, function() {
              self2._producer.writeVersion();
            });
            runner3.on(EVENT_TEST_END2, function() {
              ++n;
            });
            runner3.on(EVENT_TEST_PENDING2, function(test3) {
              self2._producer.writePending(n, test3);
            });
            runner3.on(EVENT_TEST_PASS2, function(test3) {
              self2._producer.writePass(n, test3);
            });
            runner3.on(EVENT_TEST_FAIL2, function(test3, err) {
              self2._producer.writeFail(n, test3, err);
            });
            runner3.once(EVENT_RUN_END2, function() {
              self2._producer.writeEpilogue(runner3.stats);
            });
          }
          inherits2(TAP, Base);
          function title2(test3) {
            return test3.fullTitle().replace(/#/g, "");
          }
          function println(format3, varArgs) {
            var vargs = Array.from(arguments);
            vargs[0] += "\n";
            process2.stdout.write(sprintf.apply(null, vargs));
          }
          function createProducer(tapVersion) {
            var producers = {
              12: new TAP12Producer(),
              13: new TAP13Producer()
            };
            var producer = producers[tapVersion];
            if (!producer) {
              throw new Error(
                "invalid or unsupported TAP version: " + JSON.stringify(tapVersion)
              );
            }
            return producer;
          }
          function TAPProducer() {
          }
          TAPProducer.prototype.writeVersion = function() {
          };
          TAPProducer.prototype.writePlan = function(ntests) {
            println("%d..%d", 1, ntests);
          };
          TAPProducer.prototype.writePass = function(n, test3) {
            println("ok %d %s", n, title2(test3));
          };
          TAPProducer.prototype.writePending = function(n, test3) {
            println("ok %d %s # SKIP -", n, title2(test3));
          };
          TAPProducer.prototype.writeFail = function(n, test3, err) {
            println("not ok %d %s", n, title2(test3));
          };
          TAPProducer.prototype.writeEpilogue = function(stats) {
            println("# tests " + (stats.passes + stats.failures));
            println("# pass " + stats.passes);
            println("# fail " + stats.failures);
            this.writePlan(stats.passes + stats.failures + stats.pending);
          };
          function TAP12Producer() {
            this.writeFail = function(n, test3, err) {
              TAPProducer.prototype.writeFail.call(this, n, test3, err);
              if (err.message) {
                println(err.message.replace(/^/gm, "  "));
              }
              if (err.stack) {
                println(err.stack.replace(/^/gm, "  "));
              }
            };
          }
          inherits2(TAP12Producer, TAPProducer);
          function TAP13Producer() {
            this.writeVersion = function() {
              println("TAP version 13");
            };
            this.writeFail = function(n, test3, err) {
              TAPProducer.prototype.writeFail.call(this, n, test3, err);
              var emitYamlBlock = err.message != null || err.stack != null;
              if (emitYamlBlock) {
                println(indent(1) + "---");
                if (err.message) {
                  println(indent(2) + "message: |-");
                  println(err.message.replace(/^/gm, indent(3)));
                }
                if (err.stack) {
                  println(indent(2) + "stack: |-");
                  println(err.stack.replace(/^/gm, indent(3)));
                }
                println(indent(1) + "...");
              }
            };
            function indent(level) {
              return Array(level + 1).join("  ");
            }
          }
          inherits2(TAP13Producer, TAPProducer);
          TAP.description = "TAP-compatible output";
        })(tap);
        var json = { exports: {} };
        var _polyfillNode_fs = {};
        var _polyfillNode_fs$1 = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          "default": _polyfillNode_fs
        });
        var require$$2 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_fs$1);
        (function(module3, exports2) {
          var Base = base$1.exports;
          var fs = require$$2;
          var path = require$$1;
          const createUnsupportedError2 = errors$2.createUnsupportedError;
          const utils2 = utils$3;
          var constants2 = runner2.constants;
          var EVENT_TEST_PASS2 = constants2.EVENT_TEST_PASS;
          var EVENT_TEST_PENDING2 = constants2.EVENT_TEST_PENDING;
          var EVENT_TEST_FAIL2 = constants2.EVENT_TEST_FAIL;
          var EVENT_TEST_END2 = constants2.EVENT_TEST_END;
          var EVENT_RUN_END2 = constants2.EVENT_RUN_END;
          module3.exports = JSONReporter;
          function JSONReporter(runner3, options = {}) {
            Base.call(this, runner3, options);
            var self2 = this;
            var tests = [];
            var pending2 = [];
            var failures = [];
            var passes = [];
            var output;
            if (options.reporterOption && options.reporterOption.output) {
              if (utils2.isBrowser()) {
                throw createUnsupportedError2("file output not supported in browser");
              }
              output = options.reporterOption.output;
            }
            runner3.on(EVENT_TEST_END2, function(test3) {
              tests.push(test3);
            });
            runner3.on(EVENT_TEST_PASS2, function(test3) {
              passes.push(test3);
            });
            runner3.on(EVENT_TEST_FAIL2, function(test3) {
              failures.push(test3);
            });
            runner3.on(EVENT_TEST_PENDING2, function(test3) {
              pending2.push(test3);
            });
            runner3.once(EVENT_RUN_END2, function() {
              var obj = {
                stats: self2.stats,
                tests: tests.map(clean),
                pending: pending2.map(clean),
                failures: failures.map(clean),
                passes: passes.map(clean)
              };
              runner3.testResults = obj;
              var json2 = JSON.stringify(obj, null, 2);
              if (output) {
                try {
                  fs.mkdirSync(path.dirname(output), { recursive: true });
                  fs.writeFileSync(output, json2);
                } catch (err) {
                  console.error(
                    `${Base.symbols.err} [mocha] writing output to "${output}" failed: ${err.message}
`
                  );
                  process2.stdout.write(json2);
                }
              } else {
                process2.stdout.write(json2);
              }
            });
          }
          function clean(test3) {
            var err = test3.err || {};
            if (err instanceof Error) {
              err = errorJSON(err);
            }
            return {
              title: test3.title,
              fullTitle: test3.fullTitle(),
              file: test3.file,
              duration: test3.duration,
              currentRetry: test3.currentRetry(),
              speed: test3.speed,
              err: cleanCycles(err)
            };
          }
          function cleanCycles(obj) {
            var cache = [];
            return JSON.parse(
              JSON.stringify(obj, function(key, value) {
                if (typeof value === "object" && value !== null) {
                  if (cache.indexOf(value) !== -1) {
                    return "" + value;
                  }
                  cache.push(value);
                }
                return value;
              })
            );
          }
          function errorJSON(err) {
            var res = {};
            Object.getOwnPropertyNames(err).forEach(function(key) {
              res[key] = err[key];
            }, err);
            return res;
          }
          JSONReporter.description = "single JSON object";
        })(json);
        var html2 = { exports: {} };
        (function(module3, exports2) {
          var Base = base$1.exports;
          var utils2 = utils$3;
          var escapeRe = escapeStringRegexp;
          var constants2 = runner2.constants;
          var EVENT_TEST_PASS2 = constants2.EVENT_TEST_PASS;
          var EVENT_TEST_FAIL2 = constants2.EVENT_TEST_FAIL;
          var EVENT_SUITE_BEGIN2 = constants2.EVENT_SUITE_BEGIN;
          var EVENT_SUITE_END = constants2.EVENT_SUITE_END;
          var EVENT_TEST_PENDING2 = constants2.EVENT_TEST_PENDING;
          var escape2 = utils2.escape;
          var Date2 = commonjsGlobal.Date;
          module3.exports = HTML;
          var statsTemplate = '<ul id="mocha-stats"><li class="result"></li><li class="progress-contain"><progress class="progress-element" max="100" value="0"></progress><svg class="progress-ring"><circle class="ring-flatlight" stroke-dasharray="100%,0%"/><circle class="ring-highlight" stroke-dasharray="0%,100%"/></svg><div class="progress-text">0%</div></li><li class="passes"><a href="javascript:void(0);">passes:</a> <em>0</em></li><li class="failures"><a href="javascript:void(0);">failures:</a> <em>0</em></li><li class="duration">duration: <em>0</em>s</li></ul>';
          var playIcon = "&#x2023;";
          function HTML(runner3, options) {
            Base.call(this, runner3, options);
            var self2 = this;
            var stats = this.stats;
            var stat = fragment(statsTemplate);
            var items = stat.getElementsByTagName("li");
            const resultIndex = 0;
            const progressIndex = 1;
            const passesIndex = 2;
            const failuresIndex = 3;
            const durationIndex = 4;
            var resultIndicator = items[resultIndex];
            const passesStat = items[passesIndex];
            const passesCount = passesStat.getElementsByTagName("em")[0];
            const passesLink = passesStat.getElementsByTagName("a")[0];
            const failuresStat = items[failuresIndex];
            const failuresCount = failuresStat.getElementsByTagName("em")[0];
            const failuresLink = failuresStat.getElementsByTagName("a")[0];
            var duration = items[durationIndex].getElementsByTagName("em")[0];
            var report = fragment('<ul id="mocha-report"></ul>');
            var stack = [report];
            var progressText = items[progressIndex].getElementsByTagName("div")[0];
            var progressBar = items[progressIndex].getElementsByTagName("progress")[0];
            var progressRing = [
              items[progressIndex].getElementsByClassName("ring-flatlight")[0],
              items[progressIndex].getElementsByClassName("ring-highlight")[0]
            ];
            var root = document.getElementById("mocha");
            if (!root) {
              return error("#mocha div missing, add it to your document");
            }
            on2(passesLink, "click", function(evt) {
              evt.preventDefault();
              unhide();
              var name2 = /pass/.test(report.className) ? "" : " pass";
              report.className = report.className.replace(/fail|pass/g, "") + name2;
              if (report.className.trim()) {
                hideSuitesWithout("test pass");
              }
            });
            on2(failuresLink, "click", function(evt) {
              evt.preventDefault();
              unhide();
              var name2 = /fail/.test(report.className) ? "" : " fail";
              report.className = report.className.replace(/fail|pass/g, "") + name2;
              if (report.className.trim()) {
                hideSuitesWithout("test fail");
              }
            });
            root.appendChild(stat);
            root.appendChild(report);
            runner3.on(EVENT_SUITE_BEGIN2, function(suite2) {
              if (suite2.root) {
                return;
              }
              var url = self2.suiteURL(suite2);
              var el = fragment(
                '<li class="suite"><h1><a href="%s">%s</a></h1></li>',
                url,
                escape2(suite2.title)
              );
              stack[0].appendChild(el);
              stack.unshift(document.createElement("ul"));
              el.appendChild(stack[0]);
            });
            runner3.on(EVENT_SUITE_END, function(suite2) {
              if (suite2.root) {
                if (stats.failures === 0) {
                  text(resultIndicator, "\u2713");
                  stat.className += " pass";
                }
                updateStats();
                return;
              }
              stack.shift();
            });
            runner3.on(EVENT_TEST_PASS2, function(test3) {
              var url = self2.testURL(test3);
              var markup = '<li class="test pass %e"><h2>%e<span class="duration">%ems</span> <a href="%s" class="replay">' + playIcon + "</a></h2></li>";
              var el = fragment(markup, test3.speed, test3.title, test3.duration, url);
              self2.addCodeToggle(el, test3.body);
              appendToStack(el);
              updateStats();
            });
            runner3.on(EVENT_TEST_FAIL2, function(test3) {
              text(resultIndicator, "\u2716");
              stat.className += " fail";
              var el = fragment(
                '<li class="test fail"><h2>%e <a href="%e" class="replay">' + playIcon + "</a></h2></li>",
                test3.title,
                self2.testURL(test3)
              );
              var stackString;
              var message = test3.err.toString();
              if (message === "[object Error]") {
                message = test3.err.message;
              }
              if (test3.err.stack) {
                var indexOfMessage = test3.err.stack.indexOf(test3.err.message);
                if (indexOfMessage === -1) {
                  stackString = test3.err.stack;
                } else {
                  stackString = test3.err.stack.slice(
                    test3.err.message.length + indexOfMessage
                  );
                }
              } else if (test3.err.sourceURL && test3.err.line !== void 0) {
                stackString = "\n(" + test3.err.sourceURL + ":" + test3.err.line + ")";
              }
              stackString = stackString || "";
              if (test3.err.htmlMessage && stackString) {
                el.appendChild(
                  fragment(
                    '<div class="html-error">%s\n<pre class="error">%e</pre></div>',
                    test3.err.htmlMessage,
                    stackString
                  )
                );
              } else if (test3.err.htmlMessage) {
                el.appendChild(
                  fragment('<div class="html-error">%s</div>', test3.err.htmlMessage)
                );
              } else {
                el.appendChild(
                  fragment('<pre class="error">%e%e</pre>', message, stackString)
                );
              }
              self2.addCodeToggle(el, test3.body);
              appendToStack(el);
              updateStats();
            });
            runner3.on(EVENT_TEST_PENDING2, function(test3) {
              var el = fragment(
                '<li class="test pass pending"><h2>%e</h2></li>',
                test3.title
              );
              appendToStack(el);
              updateStats();
            });
            function appendToStack(el) {
              if (stack[0]) {
                stack[0].appendChild(el);
              }
            }
            function updateStats() {
              var percent = stats.tests / runner3.total * 100 | 0;
              progressBar.value = percent;
              if (progressText) {
                var decimalPlaces = Math.ceil(Math.log10(runner3.total / 100));
                text(
                  progressText,
                  percent.toFixed(Math.min(Math.max(decimalPlaces, 0), 100)) + "%"
                );
              }
              if (progressRing) {
                var radius = parseFloat(getComputedStyle(progressRing[0]).getPropertyValue("r"));
                var wholeArc = Math.PI * 2 * radius;
                var highlightArc = percent * (wholeArc / 100);
                progressRing[0].style["stroke-dasharray"] = `0,${highlightArc}px,${wholeArc}px`;
                progressRing[1].style["stroke-dasharray"] = `${highlightArc}px,${wholeArc}px`;
              }
              var ms2 = new Date2() - stats.start;
              text(passesCount, stats.passes);
              text(failuresCount, stats.failures);
              text(duration, (ms2 / 1e3).toFixed(2));
            }
          }
          function makeUrl(s2) {
            var search = window.location.search;
            if (search) {
              search = search.replace(/[?&](?:f?grep|invert)=[^&\s]*/g, "").replace(/^&/, "?");
            }
            return window.location.pathname + (search ? search + "&" : "?") + "grep=" + encodeURIComponent(s2);
          }
          HTML.prototype.suiteURL = function(suite2) {
            return makeUrl("^" + escapeRe(suite2.fullTitle()) + " ");
          };
          HTML.prototype.testURL = function(test3) {
            return makeUrl("^" + escapeRe(test3.fullTitle()) + "$");
          };
          HTML.prototype.addCodeToggle = function(el, contents) {
            var h2 = el.getElementsByTagName("h2")[0];
            on2(h2, "click", function() {
              pre.style.display = pre.style.display === "none" ? "block" : "none";
            });
            var pre = fragment("<pre><code>%e</code></pre>", utils2.clean(contents));
            el.appendChild(pre);
            pre.style.display = "none";
          };
          function error(msg) {
            document.body.appendChild(fragment('<div id="mocha-error">%s</div>', msg));
          }
          function fragment(html3) {
            var args = arguments;
            var div = document.createElement("div");
            var i = 1;
            div.innerHTML = html3.replace(/%([se])/g, function(_, type3) {
              switch (type3) {
                case "s":
                  return String(args[i++]);
                case "e":
                  return escape2(args[i++]);
              }
            });
            return div.firstChild;
          }
          function hideSuitesWithout(classname) {
            var suites = document.getElementsByClassName("suite");
            for (var i = 0; i < suites.length; i++) {
              var els = suites[i].getElementsByClassName(classname);
              if (!els.length) {
                suites[i].className += " hidden";
              }
            }
          }
          function unhide() {
            var els = document.getElementsByClassName("suite hidden");
            while (els.length > 0) {
              els[0].className = els[0].className.replace("suite hidden", "suite");
            }
          }
          function text(el, contents) {
            if (el.textContent) {
              el.textContent = contents;
            } else {
              el.innerText = contents;
            }
          }
          function on2(el, event, fn) {
            if (el.addEventListener) {
              el.addEventListener(event, fn, false);
            } else {
              el.attachEvent("on" + event, fn);
            }
          }
          HTML.browserOnly = true;
        })(html2);
        var list = { exports: {} };
        (function(module3, exports2) {
          var Base = base$1.exports;
          var inherits2 = utils$3.inherits;
          var constants2 = runner2.constants;
          var EVENT_RUN_BEGIN2 = constants2.EVENT_RUN_BEGIN;
          var EVENT_RUN_END2 = constants2.EVENT_RUN_END;
          var EVENT_TEST_BEGIN = constants2.EVENT_TEST_BEGIN;
          var EVENT_TEST_FAIL2 = constants2.EVENT_TEST_FAIL;
          var EVENT_TEST_PASS2 = constants2.EVENT_TEST_PASS;
          var EVENT_TEST_PENDING2 = constants2.EVENT_TEST_PENDING;
          var color = Base.color;
          var cursor = Base.cursor;
          module3.exports = List;
          function List(runner3, options) {
            Base.call(this, runner3, options);
            var self2 = this;
            var n = 0;
            runner3.on(EVENT_RUN_BEGIN2, function() {
              Base.consoleLog();
            });
            runner3.on(EVENT_TEST_BEGIN, function(test3) {
              process2.stdout.write(color("pass", "    " + test3.fullTitle() + ": "));
            });
            runner3.on(EVENT_TEST_PENDING2, function(test3) {
              var fmt = color("checkmark", "  -") + color("pending", " %s");
              Base.consoleLog(fmt, test3.fullTitle());
            });
            runner3.on(EVENT_TEST_PASS2, function(test3) {
              var fmt = color("checkmark", "  " + Base.symbols.ok) + color("pass", " %s: ") + color(test3.speed, "%dms");
              cursor.CR();
              Base.consoleLog(fmt, test3.fullTitle(), test3.duration);
            });
            runner3.on(EVENT_TEST_FAIL2, function(test3) {
              cursor.CR();
              Base.consoleLog(color("fail", "  %d) %s"), ++n, test3.fullTitle());
            });
            runner3.once(EVENT_RUN_END2, self2.epilogue.bind(self2));
          }
          inherits2(List, Base);
          List.description = 'like "spec" reporter but flat';
        })(list);
        var min = { exports: {} };
        (function(module3, exports2) {
          var Base = base$1.exports;
          var inherits2 = utils$3.inherits;
          var constants2 = runner2.constants;
          var EVENT_RUN_END2 = constants2.EVENT_RUN_END;
          var EVENT_RUN_BEGIN2 = constants2.EVENT_RUN_BEGIN;
          module3.exports = Min;
          function Min(runner3, options) {
            Base.call(this, runner3, options);
            runner3.on(EVENT_RUN_BEGIN2, function() {
              process2.stdout.write("\x1B[2J");
              process2.stdout.write("\x1B[1;3H");
            });
            runner3.once(EVENT_RUN_END2, this.epilogue.bind(this));
          }
          inherits2(Min, Base);
          Min.description = "essentially just a summary";
        })(min);
        var spec = { exports: {} };
        (function(module3, exports2) {
          var Base = base$1.exports;
          var constants2 = runner2.constants;
          var EVENT_RUN_BEGIN2 = constants2.EVENT_RUN_BEGIN;
          var EVENT_RUN_END2 = constants2.EVENT_RUN_END;
          var EVENT_SUITE_BEGIN2 = constants2.EVENT_SUITE_BEGIN;
          var EVENT_SUITE_END = constants2.EVENT_SUITE_END;
          var EVENT_TEST_FAIL2 = constants2.EVENT_TEST_FAIL;
          var EVENT_TEST_PASS2 = constants2.EVENT_TEST_PASS;
          var EVENT_TEST_PENDING2 = constants2.EVENT_TEST_PENDING;
          var inherits2 = utils$3.inherits;
          var color = Base.color;
          module3.exports = Spec;
          function Spec(runner3, options) {
            Base.call(this, runner3, options);
            var self2 = this;
            var indents = 0;
            var n = 0;
            function indent() {
              return Array(indents).join("  ");
            }
            runner3.on(EVENT_RUN_BEGIN2, function() {
              Base.consoleLog();
            });
            runner3.on(EVENT_SUITE_BEGIN2, function(suite2) {
              ++indents;
              Base.consoleLog(color("suite", "%s%s"), indent(), suite2.title);
            });
            runner3.on(EVENT_SUITE_END, function() {
              --indents;
              if (indents === 1) {
                Base.consoleLog();
              }
            });
            runner3.on(EVENT_TEST_PENDING2, function(test3) {
              var fmt = indent() + color("pending", "  - %s");
              Base.consoleLog(fmt, test3.title);
            });
            runner3.on(EVENT_TEST_PASS2, function(test3) {
              var fmt;
              if (test3.speed === "fast") {
                fmt = indent() + color("checkmark", "  " + Base.symbols.ok) + color("pass", " %s");
                Base.consoleLog(fmt, test3.title);
              } else {
                fmt = indent() + color("checkmark", "  " + Base.symbols.ok) + color("pass", " %s") + color(test3.speed, " (%dms)");
                Base.consoleLog(fmt, test3.title, test3.duration);
              }
            });
            runner3.on(EVENT_TEST_FAIL2, function(test3) {
              Base.consoleLog(indent() + color("fail", "  %d) %s"), ++n, test3.title);
            });
            runner3.once(EVENT_RUN_END2, self2.epilogue.bind(self2));
          }
          inherits2(Spec, Base);
          Spec.description = "hierarchical & verbose [default]";
        })(spec);
        var nyan = { exports: {} };
        (function(module3, exports2) {
          var Base = base$1.exports;
          var constants2 = runner2.constants;
          var inherits2 = utils$3.inherits;
          var EVENT_RUN_BEGIN2 = constants2.EVENT_RUN_BEGIN;
          var EVENT_TEST_PENDING2 = constants2.EVENT_TEST_PENDING;
          var EVENT_TEST_PASS2 = constants2.EVENT_TEST_PASS;
          var EVENT_RUN_END2 = constants2.EVENT_RUN_END;
          var EVENT_TEST_FAIL2 = constants2.EVENT_TEST_FAIL;
          module3.exports = NyanCat;
          function NyanCat(runner3, options) {
            Base.call(this, runner3, options);
            var self2 = this;
            var width = Base.window.width * 0.75 | 0;
            var nyanCatWidth = this.nyanCatWidth = 11;
            this.colorIndex = 0;
            this.numberOfLines = 4;
            this.rainbowColors = self2.generateColors();
            this.scoreboardWidth = 5;
            this.tick = 0;
            this.trajectories = [[], [], [], []];
            this.trajectoryWidthMax = width - nyanCatWidth;
            runner3.on(EVENT_RUN_BEGIN2, function() {
              Base.cursor.hide();
              self2.draw();
            });
            runner3.on(EVENT_TEST_PENDING2, function() {
              self2.draw();
            });
            runner3.on(EVENT_TEST_PASS2, function() {
              self2.draw();
            });
            runner3.on(EVENT_TEST_FAIL2, function() {
              self2.draw();
            });
            runner3.once(EVENT_RUN_END2, function() {
              Base.cursor.show();
              for (var i = 0; i < self2.numberOfLines; i++) {
                process2.stdout.write("\n");
              }
              self2.epilogue();
            });
          }
          inherits2(NyanCat, Base);
          NyanCat.prototype.draw = function() {
            this.appendRainbow();
            this.drawScoreboard();
            this.drawRainbow();
            this.drawNyanCat();
            this.tick = !this.tick;
          };
          NyanCat.prototype.drawScoreboard = function() {
            var stats = this.stats;
            function draw(type3, n) {
              process2.stdout.write(" ");
              process2.stdout.write(Base.color(type3, n));
              process2.stdout.write("\n");
            }
            draw("green", stats.passes);
            draw("fail", stats.failures);
            draw("pending", stats.pending);
            process2.stdout.write("\n");
            this.cursorUp(this.numberOfLines);
          };
          NyanCat.prototype.appendRainbow = function() {
            var segment = this.tick ? "_" : "-";
            var rainbowified = this.rainbowify(segment);
            for (var index = 0; index < this.numberOfLines; index++) {
              var trajectory = this.trajectories[index];
              if (trajectory.length >= this.trajectoryWidthMax) {
                trajectory.shift();
              }
              trajectory.push(rainbowified);
            }
          };
          NyanCat.prototype.drawRainbow = function() {
            var self2 = this;
            this.trajectories.forEach(function(line2) {
              process2.stdout.write("\x1B[" + self2.scoreboardWidth + "C");
              process2.stdout.write(line2.join(""));
              process2.stdout.write("\n");
            });
            this.cursorUp(this.numberOfLines);
          };
          NyanCat.prototype.drawNyanCat = function() {
            var self2 = this;
            var startWidth = this.scoreboardWidth + this.trajectories[0].length;
            var dist = "\x1B[" + startWidth + "C";
            var padding = "";
            process2.stdout.write(dist);
            process2.stdout.write("_,------,");
            process2.stdout.write("\n");
            process2.stdout.write(dist);
            padding = self2.tick ? "  " : "   ";
            process2.stdout.write("_|" + padding + "/\\_/\\ ");
            process2.stdout.write("\n");
            process2.stdout.write(dist);
            padding = self2.tick ? "_" : "__";
            var tail = self2.tick ? "~" : "^";
            process2.stdout.write(tail + "|" + padding + this.face() + " ");
            process2.stdout.write("\n");
            process2.stdout.write(dist);
            padding = self2.tick ? " " : "  ";
            process2.stdout.write(padding + '""  "" ');
            process2.stdout.write("\n");
            this.cursorUp(this.numberOfLines);
          };
          NyanCat.prototype.face = function() {
            var stats = this.stats;
            if (stats.failures) {
              return "( x .x)";
            } else if (stats.pending) {
              return "( o .o)";
            } else if (stats.passes) {
              return "( ^ .^)";
            }
            return "( - .-)";
          };
          NyanCat.prototype.cursorUp = function(n) {
            process2.stdout.write("\x1B[" + n + "A");
          };
          NyanCat.prototype.cursorDown = function(n) {
            process2.stdout.write("\x1B[" + n + "B");
          };
          NyanCat.prototype.generateColors = function() {
            var colors = [];
            for (var i = 0; i < 6 * 7; i++) {
              var pi3 = Math.floor(Math.PI / 3);
              var n = i * (1 / 6);
              var r = Math.floor(3 * Math.sin(n) + 3);
              var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);
              var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);
              colors.push(36 * r + 6 * g + b + 16);
            }
            return colors;
          };
          NyanCat.prototype.rainbowify = function(str) {
            if (!Base.useColors) {
              return str;
            }
            var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];
            this.colorIndex += 1;
            return "\x1B[38;5;" + color + "m" + str + "\x1B[0m";
          };
          NyanCat.description = '"nyan cat"';
        })(nyan);
        var xunit = { exports: {} };
        (function(module3, exports2) {
          var Base = base$1.exports;
          var utils2 = utils$3;
          var fs = require$$2;
          var path = require$$1;
          var errors3 = errors$2;
          var createUnsupportedError2 = errors3.createUnsupportedError;
          var constants2 = runner2.constants;
          var EVENT_TEST_PASS2 = constants2.EVENT_TEST_PASS;
          var EVENT_TEST_FAIL2 = constants2.EVENT_TEST_FAIL;
          var EVENT_RUN_END2 = constants2.EVENT_RUN_END;
          var EVENT_TEST_PENDING2 = constants2.EVENT_TEST_PENDING;
          var STATE_FAILED2 = runnable.constants.STATE_FAILED;
          var inherits2 = utils2.inherits;
          var escape2 = utils2.escape;
          var Date2 = commonjsGlobal.Date;
          module3.exports = XUnit;
          function XUnit(runner3, options) {
            Base.call(this, runner3, options);
            var stats = this.stats;
            var tests = [];
            var self2 = this;
            var suiteName;
            var DEFAULT_SUITE_NAME = "Mocha Tests";
            if (options && options.reporterOptions) {
              if (options.reporterOptions.output) {
                if (!fs.createWriteStream) {
                  throw createUnsupportedError2("file output not supported in browser");
                }
                fs.mkdirSync(path.dirname(options.reporterOptions.output), {
                  recursive: true
                });
                self2.fileStream = fs.createWriteStream(options.reporterOptions.output);
              }
              suiteName = options.reporterOptions.suiteName;
            }
            suiteName = suiteName || DEFAULT_SUITE_NAME;
            runner3.on(EVENT_TEST_PENDING2, function(test3) {
              tests.push(test3);
            });
            runner3.on(EVENT_TEST_PASS2, function(test3) {
              tests.push(test3);
            });
            runner3.on(EVENT_TEST_FAIL2, function(test3) {
              tests.push(test3);
            });
            runner3.once(EVENT_RUN_END2, function() {
              self2.write(
                tag(
                  "testsuite",
                  {
                    name: suiteName,
                    tests: stats.tests,
                    failures: 0,
                    errors: stats.failures,
                    skipped: stats.tests - stats.failures - stats.passes,
                    timestamp: new Date2().toUTCString(),
                    time: stats.duration / 1e3 || 0
                  },
                  false
                )
              );
              tests.forEach(function(t) {
                self2.test(t);
              });
              self2.write("</testsuite>");
            });
          }
          inherits2(XUnit, Base);
          XUnit.prototype.done = function(failures, fn) {
            if (this.fileStream) {
              this.fileStream.end(function() {
                fn(failures);
              });
            } else {
              fn(failures);
            }
          };
          XUnit.prototype.write = function(line2) {
            if (this.fileStream) {
              this.fileStream.write(line2 + "\n");
            } else if (typeof process2 === "object" && process2.stdout) {
              process2.stdout.write(line2 + "\n");
            } else {
              Base.consoleLog(line2);
            }
          };
          XUnit.prototype.test = function(test3) {
            Base.useColors = false;
            var attrs = {
              classname: test3.parent.fullTitle(),
              name: test3.title,
              file: test3.file,
              time: test3.duration / 1e3 || 0
            };
            if (test3.state === STATE_FAILED2) {
              var err = test3.err;
              var diff2 = !Base.hideDiff && Base.showDiff(err) ? "\n" + Base.generateDiff(err.actual, err.expected) : "";
              this.write(
                tag(
                  "testcase",
                  attrs,
                  false,
                  tag(
                    "failure",
                    {},
                    false,
                    escape2(err.message) + escape2(diff2) + "\n" + escape2(err.stack)
                  )
                )
              );
            } else if (test3.isPending()) {
              this.write(tag("testcase", attrs, false, tag("skipped", {}, true)));
            } else {
              this.write(tag("testcase", attrs, true));
            }
          };
          function tag(name2, attrs, close, content) {
            var end = close ? "/>" : ">";
            var pairs = [];
            var tag2;
            for (var key in attrs) {
              if (Object.prototype.hasOwnProperty.call(attrs, key)) {
                pairs.push(key + '="' + escape2(attrs[key]) + '"');
              }
            }
            tag2 = "<" + name2 + (pairs.length ? " " + pairs.join(" ") : "") + end;
            if (content) {
              tag2 += content + "</" + name2 + end;
            }
            return tag2;
          }
          XUnit.description = "XUnit-compatible XML output";
        })(xunit);
        var markdown = { exports: {} };
        (function(module3, exports2) {
          var Base = base$1.exports;
          var utils2 = utils$3;
          var constants2 = runner2.constants;
          var EVENT_RUN_END2 = constants2.EVENT_RUN_END;
          var EVENT_SUITE_BEGIN2 = constants2.EVENT_SUITE_BEGIN;
          var EVENT_SUITE_END = constants2.EVENT_SUITE_END;
          var EVENT_TEST_PASS2 = constants2.EVENT_TEST_PASS;
          var SUITE_PREFIX = "$";
          module3.exports = Markdown;
          function Markdown(runner3, options) {
            Base.call(this, runner3, options);
            var level = 0;
            var buf = "";
            function title2(str) {
              return Array(level).join("#") + " " + str;
            }
            function mapTOC(suite2, obj) {
              var ret = obj;
              var key = SUITE_PREFIX + suite2.title;
              obj = obj[key] = obj[key] || { suite: suite2 };
              suite2.suites.forEach(function(suite3) {
                mapTOC(suite3, obj);
              });
              return ret;
            }
            function stringifyTOC(obj, level2) {
              ++level2;
              var buf2 = "";
              var link;
              for (var key in obj) {
                if (key === "suite") {
                  continue;
                }
                if (key !== SUITE_PREFIX) {
                  link = " - [" + key.substring(1) + "]";
                  link += "(#" + utils2.slug(obj[key].suite.fullTitle()) + ")\n";
                  buf2 += Array(level2).join("  ") + link;
                }
                buf2 += stringifyTOC(obj[key], level2);
              }
              return buf2;
            }
            function generateTOC(suite2) {
              var obj = mapTOC(suite2, {});
              return stringifyTOC(obj, 0);
            }
            generateTOC(runner3.suite);
            runner3.on(EVENT_SUITE_BEGIN2, function(suite2) {
              ++level;
              var slug = utils2.slug(suite2.fullTitle());
              buf += '<a name="' + slug + '"></a>\n';
              buf += title2(suite2.title) + "\n";
            });
            runner3.on(EVENT_SUITE_END, function() {
              --level;
            });
            runner3.on(EVENT_TEST_PASS2, function(test3) {
              var code = utils2.clean(test3.body);
              buf += test3.title + ".\n";
              buf += "\n```js\n";
              buf += code + "\n";
              buf += "```\n\n";
            });
            runner3.once(EVENT_RUN_END2, function() {
              process2.stdout.write("# TOC\n");
              process2.stdout.write(generateTOC(runner3.suite));
              process2.stdout.write(buf);
            });
          }
          Markdown.description = "GitHub Flavored Markdown";
        })(markdown);
        var progress = { exports: {} };
        (function(module3, exports2) {
          var Base = base$1.exports;
          var constants2 = runner2.constants;
          var EVENT_RUN_BEGIN2 = constants2.EVENT_RUN_BEGIN;
          var EVENT_TEST_END2 = constants2.EVENT_TEST_END;
          var EVENT_RUN_END2 = constants2.EVENT_RUN_END;
          var inherits2 = utils$3.inherits;
          var color = Base.color;
          var cursor = Base.cursor;
          module3.exports = Progress;
          Base.colors.progress = 90;
          function Progress(runner3, options) {
            Base.call(this, runner3, options);
            var self2 = this;
            var width = Base.window.width * 0.5 | 0;
            var total = runner3.total;
            var complete = 0;
            var lastN = -1;
            options = options || {};
            var reporterOptions = options.reporterOptions || {};
            options.open = reporterOptions.open || "[";
            options.complete = reporterOptions.complete || "\u25AC";
            options.incomplete = reporterOptions.incomplete || Base.symbols.dot;
            options.close = reporterOptions.close || "]";
            options.verbose = reporterOptions.verbose || false;
            runner3.on(EVENT_RUN_BEGIN2, function() {
              process2.stdout.write("\n");
              cursor.hide();
            });
            runner3.on(EVENT_TEST_END2, function() {
              complete++;
              var percent = complete / total;
              var n = width * percent | 0;
              var i = width - n;
              if (n === lastN && !options.verbose) {
                return;
              }
              lastN = n;
              cursor.CR();
              process2.stdout.write("\x1B[J");
              process2.stdout.write(color("progress", "  " + options.open));
              process2.stdout.write(Array(n).join(options.complete));
              process2.stdout.write(Array(i).join(options.incomplete));
              process2.stdout.write(color("progress", options.close));
              if (options.verbose) {
                process2.stdout.write(color("progress", " " + complete + " of " + total));
              }
            });
            runner3.once(EVENT_RUN_END2, function() {
              cursor.show();
              process2.stdout.write("\n");
              self2.epilogue();
            });
          }
          inherits2(Progress, Base);
          Progress.description = "a progress bar";
        })(progress);
        var landing = { exports: {} };
        (function(module3, exports2) {
          var Base = base$1.exports;
          var inherits2 = utils$3.inherits;
          var constants2 = runner2.constants;
          var EVENT_RUN_BEGIN2 = constants2.EVENT_RUN_BEGIN;
          var EVENT_RUN_END2 = constants2.EVENT_RUN_END;
          var EVENT_TEST_END2 = constants2.EVENT_TEST_END;
          var STATE_FAILED2 = runnable.constants.STATE_FAILED;
          var cursor = Base.cursor;
          var color = Base.color;
          module3.exports = Landing;
          Base.colors.plane = 0;
          Base.colors["plane crash"] = 31;
          Base.colors.runway = 90;
          function Landing(runner3, options) {
            Base.call(this, runner3, options);
            var self2 = this;
            var width = Base.window.width * 0.75 | 0;
            var stream = process2.stdout;
            var plane = color("plane", "\u2708");
            var crashed = -1;
            var n = 0;
            var total = 0;
            function runway() {
              var buf = Array(width).join("-");
              return "  " + color("runway", buf);
            }
            runner3.on(EVENT_RUN_BEGIN2, function() {
              stream.write("\n\n\n  ");
              cursor.hide();
            });
            runner3.on(EVENT_TEST_END2, function(test3) {
              var col = crashed === -1 ? width * ++n / ++total | 0 : crashed;
              if (test3.state === STATE_FAILED2) {
                plane = color("plane crash", "\u2708");
                crashed = col;
              }
              stream.write("\x1B[" + (width + 1) + "D\x1B[2A");
              stream.write(runway());
              stream.write("\n  ");
              stream.write(color("runway", Array(col).join("\u22C5")));
              stream.write(plane);
              stream.write(color("runway", Array(width - col).join("\u22C5") + "\n"));
              stream.write(runway());
              stream.write("\x1B[0m");
            });
            runner3.once(EVENT_RUN_END2, function() {
              cursor.show();
              process2.stdout.write("\n");
              self2.epilogue();
            });
            process2.once("SIGINT", function() {
              cursor.show();
              nextTick$1(function() {
                process2.kill(process2.pid, "SIGINT");
              });
            });
          }
          inherits2(Landing, Base);
          Landing.description = "Unicode landing strip";
        })(landing);
        var jsonStream = { exports: {} };
        (function(module3, exports2) {
          var Base = base$1.exports;
          var constants2 = runner2.constants;
          var EVENT_TEST_PASS2 = constants2.EVENT_TEST_PASS;
          var EVENT_TEST_FAIL2 = constants2.EVENT_TEST_FAIL;
          var EVENT_RUN_BEGIN2 = constants2.EVENT_RUN_BEGIN;
          var EVENT_RUN_END2 = constants2.EVENT_RUN_END;
          module3.exports = JSONStream;
          function JSONStream(runner3, options) {
            Base.call(this, runner3, options);
            var self2 = this;
            var total = runner3.total;
            runner3.once(EVENT_RUN_BEGIN2, function() {
              writeEvent(["start", { total }]);
            });
            runner3.on(EVENT_TEST_PASS2, function(test3) {
              writeEvent(["pass", clean(test3)]);
            });
            runner3.on(EVENT_TEST_FAIL2, function(test3, err) {
              test3 = clean(test3);
              test3.err = err.message;
              test3.stack = err.stack || null;
              writeEvent(["fail", test3]);
            });
            runner3.once(EVENT_RUN_END2, function() {
              writeEvent(["end", self2.stats]);
            });
          }
          function writeEvent(event) {
            process2.stdout.write(JSON.stringify(event) + "\n");
          }
          function clean(test3) {
            return {
              title: test3.title,
              fullTitle: test3.fullTitle(),
              file: test3.file,
              duration: test3.duration,
              currentRetry: test3.currentRetry(),
              speed: test3.speed
            };
          }
          JSONStream.description = "newline delimited JSON events";
        })(jsonStream);
        (function(exports2) {
          exports2.Base = exports2.base = base$1.exports;
          exports2.Dot = exports2.dot = dot.exports;
          exports2.Doc = exports2.doc = doc.exports;
          exports2.TAP = exports2.tap = tap.exports;
          exports2.JSON = exports2.json = json.exports;
          exports2.HTML = exports2.html = html2.exports;
          exports2.List = exports2.list = list.exports;
          exports2.Min = exports2.min = min.exports;
          exports2.Spec = exports2.spec = spec.exports;
          exports2.Nyan = exports2.nyan = nyan.exports;
          exports2.XUnit = exports2.xunit = xunit.exports;
          exports2.Markdown = exports2.markdown = markdown.exports;
          exports2.Progress = exports2.progress = progress.exports;
          exports2.Landing = exports2.landing = landing.exports;
          exports2.JSONStream = exports2["json-stream"] = jsonStream.exports;
        })(reporters);
        var diff = true;
        var extension = [
          "js",
          "cjs",
          "mjs"
        ];
        var reporter = "spec";
        var slow = 75;
        var timeout = 2e3;
        var ui = "bdd";
        var require$$4 = {
          diff,
          extension,
          "package": "./package.json",
          reporter,
          slow,
          timeout,
          ui,
          "watch-ignore": [
            "node_modules",
            ".git"
          ]
        };
        var constants = runner2.constants;
        var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
        var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
        var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
        var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
        var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
        var EVENT_RUN_END = constants.EVENT_RUN_END;
        var EVENT_TEST_END = constants.EVENT_TEST_END;
        var Date$2 = commonjsGlobal.Date;
        function createStatsCollector(runner3) {
          var stats = {
            suites: 0,
            tests: 0,
            passes: 0,
            pending: 0,
            failures: 0
          };
          if (!runner3) {
            throw new TypeError("Missing runner argument");
          }
          runner3.stats = stats;
          runner3.once(EVENT_RUN_BEGIN, function() {
            stats.start = new Date$2();
          });
          runner3.on(EVENT_SUITE_BEGIN, function(suite2) {
            suite2.root || stats.suites++;
          });
          runner3.on(EVENT_TEST_PASS, function() {
            stats.passes++;
          });
          runner3.on(EVENT_TEST_FAIL, function() {
            stats.failures++;
          });
          runner3.on(EVENT_TEST_PENDING, function() {
            stats.pending++;
          });
          runner3.on(EVENT_TEST_END, function() {
            stats.tests++;
          });
          runner3.once(EVENT_RUN_END, function() {
            stats.end = new Date$2();
            stats.duration = stats.end - stats.start;
          });
        }
        var statsCollector = createStatsCollector;
        var interfaces = {};
        var bdd = { exports: {} };
        var Runnable = runnable;
        var utils = utils$3;
        var errors$1 = errors$2;
        var createInvalidArgumentTypeError = errors$1.createInvalidArgumentTypeError;
        var isString = utils.isString;
        const { MOCHA_ID_PROP_NAME } = utils.constants;
        var test2 = Test$4;
        function Test$4(title2, fn) {
          if (!isString(title2)) {
            throw createInvalidArgumentTypeError(
              'Test argument "title" should be a string. Received type "' + typeof title2 + '"',
              "title",
              "string"
            );
          }
          this.type = "test";
          Runnable.call(this, title2, fn);
          this.reset();
        }
        utils.inherits(Test$4, Runnable);
        Test$4.prototype.reset = function() {
          Runnable.prototype.reset.call(this);
          this.pending = !this.fn;
          delete this.state;
        };
        Test$4.prototype.retriedTest = function(n) {
          if (!arguments.length) {
            return this._retriedTest;
          }
          this._retriedTest = n;
        };
        Test$4.prototype.markOnly = function() {
          this.parent.appendOnlyTest(this);
        };
        Test$4.prototype.clone = function() {
          var test3 = new Test$4(this.title, this.fn);
          test3.timeout(this.timeout());
          test3.slow(this.slow());
          test3.retries(this.retries());
          test3.currentRetry(this.currentRetry());
          test3.retriedTest(this.retriedTest() || this);
          test3.globals(this.globals());
          test3.parent = this.parent;
          test3.file = this.file;
          test3.ctx = this.ctx;
          return test3;
        };
        Test$4.prototype.serialize = function serialize() {
          return {
            $$currentRetry: this._currentRetry,
            $$fullTitle: this.fullTitle(),
            $$isPending: Boolean(this.pending),
            $$retriedTest: this._retriedTest || null,
            $$slow: this._slow,
            $$titlePath: this.titlePath(),
            body: this.body,
            duration: this.duration,
            err: this.err,
            parent: {
              $$fullTitle: this.parent.fullTitle(),
              [MOCHA_ID_PROP_NAME]: this.parent.id
            },
            speed: this.speed,
            state: this.state,
            title: this.title,
            type: this.type,
            file: this.file,
            [MOCHA_ID_PROP_NAME]: this.id
          };
        };
        var Suite$1 = suite.exports;
        var errors2 = errors$2;
        var createMissingArgumentError = errors2.createMissingArgumentError;
        var createUnsupportedError = errors2.createUnsupportedError;
        var createForbiddenExclusivityError = errors2.createForbiddenExclusivityError;
        var common = function(suites, context2, mocha3) {
          function shouldBeTested(suite2) {
            return !mocha3.options.grep || mocha3.options.grep && mocha3.options.grep.test(suite2.fullTitle()) && !mocha3.options.invert;
          }
          return {
            /**
             * This is only present if flag --delay is passed into Mocha. It triggers
             * root suite execution.
             *
             * @param {Suite} suite The root suite.
             * @return {Function} A function which runs the root suite
             */
            runWithSuite: function runWithSuite(suite2) {
              return function run() {
                suite2.run();
              };
            },
            /**
             * Execute before running tests.
             *
             * @param {string} name
             * @param {Function} fn
             */
            before: function(name2, fn) {
              suites[0].beforeAll(name2, fn);
            },
            /**
             * Execute after running tests.
             *
             * @param {string} name
             * @param {Function} fn
             */
            after: function(name2, fn) {
              suites[0].afterAll(name2, fn);
            },
            /**
             * Execute before each test case.
             *
             * @param {string} name
             * @param {Function} fn
             */
            beforeEach: function(name2, fn) {
              suites[0].beforeEach(name2, fn);
            },
            /**
             * Execute after each test case.
             *
             * @param {string} name
             * @param {Function} fn
             */
            afterEach: function(name2, fn) {
              suites[0].afterEach(name2, fn);
            },
            suite: {
              /**
               * Create an exclusive Suite; convenience function
               * See docstring for create() below.
               *
               * @param {Object} opts
               * @returns {Suite}
               */
              only: function only(opts) {
                if (mocha3.options.forbidOnly) {
                  throw createForbiddenExclusivityError(mocha3);
                }
                opts.isOnly = true;
                return this.create(opts);
              },
              /**
               * Create a Suite, but skip it; convenience function
               * See docstring for create() below.
               *
               * @param {Object} opts
               * @returns {Suite}
               */
              skip: function skip(opts) {
                opts.pending = true;
                return this.create(opts);
              },
              /**
               * Creates a suite.
               *
               * @param {Object} opts Options
               * @param {string} opts.title Title of Suite
               * @param {Function} [opts.fn] Suite Function (not always applicable)
               * @param {boolean} [opts.pending] Is Suite pending?
               * @param {string} [opts.file] Filepath where this Suite resides
               * @param {boolean} [opts.isOnly] Is Suite exclusive?
               * @returns {Suite}
               */
              create: function create3(opts) {
                var suite2 = Suite$1.create(suites[0], opts.title);
                suite2.pending = Boolean(opts.pending);
                suite2.file = opts.file;
                suites.unshift(suite2);
                if (opts.isOnly) {
                  suite2.markOnly();
                }
                if (suite2.pending && mocha3.options.forbidPending && shouldBeTested(suite2)) {
                  throw createUnsupportedError("Pending test forbidden");
                }
                if (typeof opts.fn === "function") {
                  opts.fn.call(suite2);
                  suites.shift();
                } else if (typeof opts.fn === "undefined" && !suite2.pending) {
                  throw createMissingArgumentError(
                    'Suite "' + suite2.fullTitle() + '" was defined but no callback was supplied. Supply a callback or explicitly skip the suite.',
                    "callback",
                    "function"
                  );
                } else if (!opts.fn && suite2.pending) {
                  suites.shift();
                }
                return suite2;
              }
            },
            test: {
              /**
               * Exclusive test-case.
               *
               * @param {Object} mocha
               * @param {Function} test
               * @returns {*}
               */
              only: function(mocha4, test3) {
                if (mocha4.options.forbidOnly) {
                  throw createForbiddenExclusivityError(mocha4);
                }
                test3.markOnly();
                return test3;
              },
              /**
               * Pending test case.
               *
               * @param {string} title
               */
              skip: function(title2) {
                context2.test(title2);
              }
            }
          };
        };
        var Test$3 = test2;
        var EVENT_FILE_PRE_REQUIRE$2 = suite.exports.constants.EVENT_FILE_PRE_REQUIRE;
        bdd.exports = function bddInterface(suite2) {
          var suites = [suite2];
          suite2.on(EVENT_FILE_PRE_REQUIRE$2, function(context2, file, mocha3) {
            var common$12 = common(suites, context2, mocha3);
            context2.before = common$12.before;
            context2.after = common$12.after;
            context2.beforeEach = common$12.beforeEach;
            context2.afterEach = common$12.afterEach;
            context2.run = mocha3.options.delay && common$12.runWithSuite(suite2);
            context2.describe = context2.context = function(title2, fn) {
              return common$12.suite.create({
                title: title2,
                file,
                fn
              });
            };
            context2.xdescribe = context2.xcontext = context2.describe.skip = function(title2, fn) {
              return common$12.suite.skip({
                title: title2,
                file,
                fn
              });
            };
            context2.describe.only = function(title2, fn) {
              return common$12.suite.only({
                title: title2,
                file,
                fn
              });
            };
            context2.it = context2.specify = function(title2, fn) {
              var suite3 = suites[0];
              if (suite3.isPending()) {
                fn = null;
              }
              var test3 = new Test$3(title2, fn);
              test3.file = file;
              suite3.addTest(test3);
              return test3;
            };
            context2.it.only = function(title2, fn) {
              return common$12.test.only(mocha3, context2.it(title2, fn));
            };
            context2.xit = context2.xspecify = context2.it.skip = function(title2) {
              return context2.it(title2);
            };
          });
        };
        bdd.exports.description = "BDD or RSpec style [default]";
        var tdd = { exports: {} };
        var Test$2 = test2;
        var EVENT_FILE_PRE_REQUIRE$1 = suite.exports.constants.EVENT_FILE_PRE_REQUIRE;
        tdd.exports = function(suite2) {
          var suites = [suite2];
          suite2.on(EVENT_FILE_PRE_REQUIRE$1, function(context2, file, mocha3) {
            var common$12 = common(suites, context2, mocha3);
            context2.setup = common$12.beforeEach;
            context2.teardown = common$12.afterEach;
            context2.suiteSetup = common$12.before;
            context2.suiteTeardown = common$12.after;
            context2.run = mocha3.options.delay && common$12.runWithSuite(suite2);
            context2.suite = function(title2, fn) {
              return common$12.suite.create({
                title: title2,
                file,
                fn
              });
            };
            context2.suite.skip = function(title2, fn) {
              return common$12.suite.skip({
                title: title2,
                file,
                fn
              });
            };
            context2.suite.only = function(title2, fn) {
              return common$12.suite.only({
                title: title2,
                file,
                fn
              });
            };
            context2.test = function(title2, fn) {
              var suite3 = suites[0];
              if (suite3.isPending()) {
                fn = null;
              }
              var test3 = new Test$2(title2, fn);
              test3.file = file;
              suite3.addTest(test3);
              return test3;
            };
            context2.test.only = function(title2, fn) {
              return common$12.test.only(mocha3, context2.test(title2, fn));
            };
            context2.test.skip = common$12.test.skip;
          });
        };
        tdd.exports.description = `traditional "suite"/"test" instead of BDD's "describe"/"it"`;
        var qunit = { exports: {} };
        var Test$1 = test2;
        var EVENT_FILE_PRE_REQUIRE = suite.exports.constants.EVENT_FILE_PRE_REQUIRE;
        qunit.exports = function qUnitInterface(suite2) {
          var suites = [suite2];
          suite2.on(EVENT_FILE_PRE_REQUIRE, function(context2, file, mocha3) {
            var common$12 = common(suites, context2, mocha3);
            context2.before = common$12.before;
            context2.after = common$12.after;
            context2.beforeEach = common$12.beforeEach;
            context2.afterEach = common$12.afterEach;
            context2.run = mocha3.options.delay && common$12.runWithSuite(suite2);
            context2.suite = function(title2) {
              if (suites.length > 1) {
                suites.shift();
              }
              return common$12.suite.create({
                title: title2,
                file,
                fn: false
              });
            };
            context2.suite.only = function(title2) {
              if (suites.length > 1) {
                suites.shift();
              }
              return common$12.suite.only({
                title: title2,
                file,
                fn: false
              });
            };
            context2.test = function(title2, fn) {
              var test3 = new Test$1(title2, fn);
              test3.file = file;
              suites[0].addTest(test3);
              return test3;
            };
            context2.test.only = function(title2, fn) {
              return common$12.test.only(mocha3, context2.test(title2, fn));
            };
            context2.test.skip = common$12.test.skip;
          });
        };
        qunit.exports.description = "QUnit style";
        var exports$1 = { exports: {} };
        var Suite = suite.exports;
        var Test = test2;
        exports$1.exports = function(suite2) {
          var suites = [suite2];
          suite2.on(Suite.constants.EVENT_FILE_REQUIRE, visit);
          function visit(obj, file) {
            var suite3;
            for (var key in obj) {
              if (typeof obj[key] === "function") {
                var fn = obj[key];
                switch (key) {
                  case "before":
                    suites[0].beforeAll(fn);
                    break;
                  case "after":
                    suites[0].afterAll(fn);
                    break;
                  case "beforeEach":
                    suites[0].beforeEach(fn);
                    break;
                  case "afterEach":
                    suites[0].afterEach(fn);
                    break;
                  default:
                    var test3 = new Test(key, fn);
                    test3.file = file;
                    suites[0].addTest(test3);
                }
              } else {
                suite3 = Suite.create(suites[0], key);
                suites.unshift(suite3);
                visit(obj[key], file);
                suites.shift();
              }
            }
          }
        };
        exports$1.exports.description = 'Node.js module ("exports") style';
        interfaces.bdd = bdd.exports;
        interfaces.tdd = tdd.exports;
        interfaces.qunit = qunit.exports;
        interfaces.exports = exports$1.exports;
        var context = Context;
        function Context() {
        }
        Context.prototype.runnable = function(runnable2) {
          if (!arguments.length) {
            return this._runnable;
          }
          this.test = this._runnable = runnable2;
          return this;
        };
        Context.prototype.timeout = function(ms2) {
          if (!arguments.length) {
            return this.runnable().timeout();
          }
          this.runnable().timeout(ms2);
          return this;
        };
        Context.prototype.slow = function(ms2) {
          if (!arguments.length) {
            return this.runnable().slow();
          }
          this.runnable().slow(ms2);
          return this;
        };
        Context.prototype.skip = function() {
          this.runnable().skip();
        };
        Context.prototype.retries = function(n) {
          if (!arguments.length) {
            return this.runnable().retries();
          }
          this.runnable().retries(n);
          return this;
        };
        var name = "mocha";
        var version = "10.8.2";
        var homepage = "https://mochajs.org/";
        var notifyLogo = "https://ibin.co/4QuRuGjXvl36.png";
        var require$$17 = {
          name,
          version,
          homepage,
          notifyLogo
        };
        (function(module3, exports2) {
          var escapeRe = escapeStringRegexp;
          var path = require$$1;
          var builtinReporters = reporters;
          var utils2 = utils$3;
          var mocharc = require$$4;
          var Suite2 = suite.exports;
          var esmUtils = require$$18;
          var createStatsCollector2 = statsCollector;
          const {
            createInvalidReporterError: createInvalidReporterError2,
            createInvalidInterfaceError: createInvalidInterfaceError2,
            createMochaInstanceAlreadyDisposedError: createMochaInstanceAlreadyDisposedError2,
            createMochaInstanceAlreadyRunningError: createMochaInstanceAlreadyRunningError2,
            createUnsupportedError: createUnsupportedError2
          } = errors$2;
          const { EVENT_FILE_PRE_REQUIRE: EVENT_FILE_PRE_REQUIRE2, EVENT_FILE_POST_REQUIRE, EVENT_FILE_REQUIRE } = Suite2.constants;
          var debug3 = browser.exports("mocha:mocha");
          exports2 = module3.exports = Mocha2;
          var mochaStates = utils2.defineConstants({
            /**
             * Initial state of the mocha instance
             * @private
             */
            INIT: "init",
            /**
             * Mocha instance is running tests
             * @private
             */
            RUNNING: "running",
            /**
             * Mocha instance is done running tests and references to test functions and hooks are cleaned.
             * You can reset this state by unloading the test files.
             * @private
             */
            REFERENCES_CLEANED: "referencesCleaned",
            /**
             * Mocha instance is disposed and can no longer be used.
             * @private
             */
            DISPOSED: "disposed"
          });
          if (!utils2.isBrowser() && typeof module3.paths !== "undefined") {
            var cwd2 = utils2.cwd();
            module3.paths.push(cwd2, path.join(cwd2, "node_modules"));
          }
          exports2.utils = utils2;
          exports2.interfaces = interfaces;
          exports2.reporters = builtinReporters;
          exports2.Runnable = runnable;
          exports2.Context = context;
          exports2.Runner = runner2;
          exports2.Suite = Suite2;
          exports2.Hook = hook;
          exports2.Test = test2;
          let currentContext;
          exports2.afterEach = function(...args) {
            return (currentContext.afterEach || currentContext.teardown).apply(
              this,
              args
            );
          };
          exports2.after = function(...args) {
            return (currentContext.after || currentContext.suiteTeardown).apply(
              this,
              args
            );
          };
          exports2.beforeEach = function(...args) {
            return (currentContext.beforeEach || currentContext.setup).apply(this, args);
          };
          exports2.before = function(...args) {
            return (currentContext.before || currentContext.suiteSetup).apply(this, args);
          };
          exports2.describe = function(...args) {
            return (currentContext.describe || currentContext.suite).apply(this, args);
          };
          exports2.describe.only = function(...args) {
            return (currentContext.describe || currentContext.suite).only.apply(
              this,
              args
            );
          };
          exports2.describe.skip = function(...args) {
            return (currentContext.describe || currentContext.suite).skip.apply(
              this,
              args
            );
          };
          exports2.it = function(...args) {
            return (currentContext.it || currentContext.test).apply(this, args);
          };
          exports2.it.only = function(...args) {
            return (currentContext.it || currentContext.test).only.apply(this, args);
          };
          exports2.it.skip = function(...args) {
            return (currentContext.it || currentContext.test).skip.apply(this, args);
          };
          exports2.xdescribe = exports2.describe.skip;
          exports2.xit = exports2.it.skip;
          exports2.setup = exports2.beforeEach;
          exports2.suiteSetup = exports2.before;
          exports2.suiteTeardown = exports2.after;
          exports2.suite = exports2.describe;
          exports2.teardown = exports2.afterEach;
          exports2.test = exports2.it;
          exports2.run = function(...args) {
            return currentContext.run.apply(this, args);
          };
          function Mocha2(options = {}) {
            options = { ...mocharc, ...options };
            this.files = [];
            this.options = options;
            this.suite = new exports2.Suite("", new exports2.Context(), true);
            this._cleanReferencesAfterRun = true;
            this._state = mochaStates.INIT;
            this.grep(options.grep).fgrep(options.fgrep).ui(options.ui).reporter(
              options.reporter,
              options.reporterOption || options.reporterOptions
              // for backwards compatibility
            ).slow(options.slow).global(options.global);
            if (typeof options.timeout !== "undefined") {
              this.timeout(options.timeout === false ? 0 : options.timeout);
            }
            if ("retries" in options) {
              this.retries(options.retries);
            }
            [
              "allowUncaught",
              "asyncOnly",
              "bail",
              "checkLeaks",
              "color",
              "delay",
              "diff",
              "dryRun",
              "passOnFailingTestSuite",
              "failZero",
              "forbidOnly",
              "forbidPending",
              "fullTrace",
              "inlineDiffs",
              "invert"
            ].forEach(function(opt) {
              if (options[opt]) {
                this[opt]();
              }
            }, this);
            if (options.rootHooks) {
              this.rootHooks(options.rootHooks);
            }
            this._runnerClass = exports2.Runner;
            this._lazyLoadFiles = false;
            this.isWorker = Boolean(options.isWorker);
            this.globalSetup(options.globalSetup).globalTeardown(options.globalTeardown).enableGlobalSetup(options.enableGlobalSetup).enableGlobalTeardown(options.enableGlobalTeardown);
            if (options.parallel && (typeof options.jobs === "undefined" || options.jobs > 1)) {
              debug3("attempting to enable parallel mode");
              this.parallelMode(true);
            }
          }
          Mocha2.prototype.bail = function(bail) {
            this.suite.bail(bail !== false);
            return this;
          };
          Mocha2.prototype.addFile = function(file) {
            this.files.push(file);
            return this;
          };
          Mocha2.prototype.reporter = function(reporterName, reporterOptions) {
            if (typeof reporterName === "function") {
              this._reporter = reporterName;
            } else {
              reporterName = reporterName || "spec";
              var reporter2;
              if (builtinReporters[reporterName]) {
                reporter2 = builtinReporters[reporterName];
              }
              if (!reporter2) {
                let foundReporter;
                try {
                  foundReporter = __require.resolve(reporterName);
                  reporter2 = commonjsRequire(foundReporter);
                } catch (err) {
                  if (foundReporter) {
                    throw createInvalidReporterError2(err.message, foundReporter);
                  }
                  try {
                    reporter2 = commonjsRequire(path.resolve(reporterName));
                  } catch (e) {
                    throw createInvalidReporterError2(e.message, reporterName);
                  }
                }
              }
              this._reporter = reporter2;
            }
            this.options.reporterOption = reporterOptions;
            this.options.reporterOptions = reporterOptions;
            return this;
          };
          Mocha2.prototype.ui = function(ui2) {
            var bindInterface;
            if (typeof ui2 === "function") {
              bindInterface = ui2;
            } else {
              ui2 = ui2 || "bdd";
              bindInterface = exports2.interfaces[ui2];
              if (!bindInterface) {
                try {
                  bindInterface = commonjsRequire(ui2);
                } catch (err) {
                  throw createInvalidInterfaceError2(`invalid interface '${ui2}'`, ui2);
                }
              }
            }
            bindInterface(this.suite);
            this.suite.on(EVENT_FILE_PRE_REQUIRE2, function(context2) {
              currentContext = context2;
            });
            return this;
          };
          Mocha2.prototype.loadFiles = function(fn) {
            var self2 = this;
            var suite2 = this.suite;
            this.files.forEach(function(file) {
              file = path.resolve(file);
              suite2.emit(EVENT_FILE_PRE_REQUIRE2, commonjsGlobal, file, self2);
              suite2.emit(EVENT_FILE_REQUIRE, commonjsRequire(file), file, self2);
              suite2.emit(EVENT_FILE_POST_REQUIRE, commonjsGlobal, file, self2);
            });
            fn && fn();
          };
          Mocha2.prototype.loadFilesAsync = function({ esmDecorator } = {}) {
            var self2 = this;
            var suite2 = this.suite;
            this.lazyLoadFiles(true);
            return esmUtils.loadFilesAsync(
              this.files,
              function(file) {
                suite2.emit(EVENT_FILE_PRE_REQUIRE2, commonjsGlobal, file, self2);
              },
              function(file, resultModule) {
                suite2.emit(EVENT_FILE_REQUIRE, resultModule, file, self2);
                suite2.emit(EVENT_FILE_POST_REQUIRE, commonjsGlobal, file, self2);
              },
              esmDecorator
            );
          };
          Mocha2.unloadFile = function(file) {
            if (utils2.isBrowser()) {
              throw createUnsupportedError2(
                "unloadFile() is only supported in a Node.js environment"
              );
            }
            return require$$18.unloadFile(file);
          };
          Mocha2.prototype.unloadFiles = function() {
            if (this._state === mochaStates.DISPOSED) {
              throw createMochaInstanceAlreadyDisposedError2(
                "Mocha instance is already disposed, it cannot be used again.",
                this._cleanReferencesAfterRun,
                this
              );
            }
            this.files.forEach(function(file) {
              Mocha2.unloadFile(file);
            });
            this._state = mochaStates.INIT;
            return this;
          };
          Mocha2.prototype.fgrep = function(str) {
            if (!str) {
              return this;
            }
            return this.grep(new RegExp(escapeRe(str)));
          };
          Mocha2.prototype.grep = function(re) {
            if (utils2.isString(re)) {
              var arg = re.match(/^\/(.*)\/([gimy]{0,4})$|.*/);
              this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);
            } else {
              this.options.grep = re;
            }
            return this;
          };
          Mocha2.prototype.invert = function() {
            this.options.invert = true;
            return this;
          };
          Mocha2.prototype.checkLeaks = function(checkLeaks) {
            this.options.checkLeaks = checkLeaks !== false;
            return this;
          };
          Mocha2.prototype.cleanReferencesAfterRun = function(cleanReferencesAfterRun) {
            this._cleanReferencesAfterRun = cleanReferencesAfterRun !== false;
            return this;
          };
          Mocha2.prototype.dispose = function() {
            if (this._state === mochaStates.RUNNING) {
              throw createMochaInstanceAlreadyRunningError2(
                "Cannot dispose while the mocha instance is still running tests."
              );
            }
            this.unloadFiles();
            this._previousRunner && this._previousRunner.dispose();
            this.suite.dispose();
            this._state = mochaStates.DISPOSED;
          };
          Mocha2.prototype.fullTrace = function(fullTrace) {
            this.options.fullTrace = fullTrace !== false;
            return this;
          };
          Mocha2.prototype.global = function(global2) {
            this.options.global = (this.options.global || []).concat(global2).filter(Boolean).filter(function(elt, idx, arr) {
              return arr.indexOf(elt) === idx;
            });
            return this;
          };
          Mocha2.prototype.globals = Mocha2.prototype.global;
          Mocha2.prototype.color = function(color) {
            this.options.color = color !== false;
            return this;
          };
          Mocha2.prototype.inlineDiffs = function(inlineDiffs) {
            this.options.inlineDiffs = inlineDiffs !== false;
            return this;
          };
          Mocha2.prototype.diff = function(diff2) {
            this.options.diff = diff2 !== false;
            return this;
          };
          Mocha2.prototype.timeout = function(msecs) {
            this.suite.timeout(msecs);
            return this;
          };
          Mocha2.prototype.retries = function(retry) {
            this.suite.retries(retry);
            return this;
          };
          Mocha2.prototype.slow = function(msecs) {
            this.suite.slow(msecs);
            return this;
          };
          Mocha2.prototype.asyncOnly = function(asyncOnly) {
            this.options.asyncOnly = asyncOnly !== false;
            return this;
          };
          Mocha2.prototype.noHighlighting = function() {
            this.options.noHighlighting = true;
            return this;
          };
          Mocha2.prototype.allowUncaught = function(allowUncaught) {
            this.options.allowUncaught = allowUncaught !== false;
            return this;
          };
          Mocha2.prototype.delay = function delay() {
            this.options.delay = true;
            return this;
          };
          Mocha2.prototype.dryRun = function(dryRun) {
            this.options.dryRun = dryRun !== false;
            return this;
          };
          Mocha2.prototype.failZero = function(failZero) {
            this.options.failZero = failZero !== false;
            return this;
          };
          Mocha2.prototype.passOnFailingTestSuite = function(passOnFailingTestSuite) {
            this.options.passOnFailingTestSuite = passOnFailingTestSuite === true;
            return this;
          };
          Mocha2.prototype.forbidOnly = function(forbidOnly) {
            this.options.forbidOnly = forbidOnly !== false;
            return this;
          };
          Mocha2.prototype.forbidPending = function(forbidPending) {
            this.options.forbidPending = forbidPending !== false;
            return this;
          };
          Mocha2.prototype._guardRunningStateTransition = function() {
            if (this._state === mochaStates.RUNNING) {
              throw createMochaInstanceAlreadyRunningError2(
                "Mocha instance is currently running tests, cannot start a next test run until this one is done",
                this
              );
            }
            if (this._state === mochaStates.DISPOSED || this._state === mochaStates.REFERENCES_CLEANED) {
              throw createMochaInstanceAlreadyDisposedError2(
                "Mocha instance is already disposed, cannot start a new test run. Please create a new mocha instance. Be sure to set disable `cleanReferencesAfterRun` when you want to reuse the same mocha instance for multiple test runs.",
                this._cleanReferencesAfterRun,
                this
              );
            }
          };
          Object.defineProperty(Mocha2.prototype, "version", {
            value: require$$17.version,
            configurable: false,
            enumerable: true,
            writable: false
          });
          Mocha2.prototype.run = function(fn) {
            this._guardRunningStateTransition();
            this._state = mochaStates.RUNNING;
            if (this._previousRunner) {
              this._previousRunner.dispose();
              this.suite.reset();
            }
            if (this.files.length && !this._lazyLoadFiles) {
              this.loadFiles();
            }
            var suite2 = this.suite;
            var options = this.options;
            options.files = this.files;
            const runner3 = new this._runnerClass(suite2, {
              cleanReferencesAfterRun: this._cleanReferencesAfterRun,
              delay: options.delay,
              dryRun: options.dryRun,
              failZero: options.failZero
            });
            createStatsCollector2(runner3);
            var reporter2 = new this._reporter(runner3, options);
            runner3.checkLeaks = options.checkLeaks === true;
            runner3.fullStackTrace = options.fullTrace;
            runner3.asyncOnly = options.asyncOnly;
            runner3.allowUncaught = options.allowUncaught;
            runner3.forbidOnly = options.forbidOnly;
            runner3.forbidPending = options.forbidPending;
            if (options.grep) {
              runner3.grep(options.grep, options.invert);
            }
            if (options.global) {
              runner3.globals(options.global);
            }
            if (options.color !== void 0) {
              exports2.reporters.Base.useColors = options.color;
            }
            exports2.reporters.Base.inlineDiffs = options.inlineDiffs;
            exports2.reporters.Base.hideDiff = !options.diff;
            const done2 = (failures) => {
              this._previousRunner = runner3;
              this._state = this._cleanReferencesAfterRun ? mochaStates.REFERENCES_CLEANED : mochaStates.INIT;
              fn = fn || utils2.noop;
              if (typeof reporter2.done === "function") {
                reporter2.done(failures, fn);
              } else {
                fn(failures);
              }
            };
            const runAsync = async (runner4) => {
              const context2 = this.options.enableGlobalSetup && this.hasGlobalSetupFixtures() ? await this.runGlobalSetup(runner4) : {};
              const failureCount = await runner4.runAsync({
                files: this.files,
                options
              });
              if (this.options.enableGlobalTeardown && this.hasGlobalTeardownFixtures()) {
                await this.runGlobalTeardown(runner4, { context: context2 });
              }
              return failureCount;
            };
            runAsync(runner3).then(done2);
            return runner3;
          };
          Mocha2.prototype.rootHooks = function rootHooks({
            beforeAll = [],
            beforeEach: beforeEach2 = [],
            afterAll = [],
            afterEach: afterEach2 = []
          } = {}) {
            beforeAll = utils2.castArray(beforeAll);
            beforeEach2 = utils2.castArray(beforeEach2);
            afterAll = utils2.castArray(afterAll);
            afterEach2 = utils2.castArray(afterEach2);
            beforeAll.forEach((hook2) => {
              this.suite.beforeAll(hook2);
            });
            beforeEach2.forEach((hook2) => {
              this.suite.beforeEach(hook2);
            });
            afterAll.forEach((hook2) => {
              this.suite.afterAll(hook2);
            });
            afterEach2.forEach((hook2) => {
              this.suite.afterEach(hook2);
            });
            return this;
          };
          Mocha2.prototype.parallelMode = function parallelMode(enable = true) {
            if (utils2.isBrowser()) {
              throw createUnsupportedError2("parallel mode is only supported in Node.js");
            }
            const parallel = Boolean(enable);
            if (parallel === this.options.parallel && this._lazyLoadFiles && this._runnerClass !== exports2.Runner) {
              return this;
            }
            if (this._state !== mochaStates.INIT) {
              throw createUnsupportedError2(
                "cannot change parallel mode after having called run()"
              );
            }
            this.options.parallel = parallel;
            this._runnerClass = parallel ? require$$18 : exports2.Runner;
            return this.lazyLoadFiles(this._lazyLoadFiles || parallel);
          };
          Mocha2.prototype.lazyLoadFiles = function lazyLoadFiles(enable) {
            this._lazyLoadFiles = enable === true;
            debug3("set lazy load to %s", enable);
            return this;
          };
          Mocha2.prototype.globalSetup = function globalSetup(setupFns = []) {
            setupFns = utils2.castArray(setupFns);
            this.options.globalSetup = setupFns;
            debug3("configured %d global setup functions", setupFns.length);
            return this;
          };
          Mocha2.prototype.globalTeardown = function globalTeardown(teardownFns = []) {
            teardownFns = utils2.castArray(teardownFns);
            this.options.globalTeardown = teardownFns;
            debug3("configured %d global teardown functions", teardownFns.length);
            return this;
          };
          Mocha2.prototype.runGlobalSetup = async function runGlobalSetup(context2 = {}) {
            const { globalSetup } = this.options;
            if (globalSetup && globalSetup.length) {
              debug3("run(): global setup starting");
              await this._runGlobalFixtures(globalSetup, context2);
              debug3("run(): global setup complete");
            }
            return context2;
          };
          Mocha2.prototype.runGlobalTeardown = async function runGlobalTeardown(context2 = {}) {
            const { globalTeardown } = this.options;
            if (globalTeardown && globalTeardown.length) {
              debug3("run(): global teardown starting");
              await this._runGlobalFixtures(globalTeardown, context2);
            }
            debug3("run(): global teardown complete");
            return context2;
          };
          Mocha2.prototype._runGlobalFixtures = async function _runGlobalFixtures(fixtureFns = [], context2 = {}) {
            for await (const fixtureFn of fixtureFns) {
              await fixtureFn.call(context2);
            }
            return context2;
          };
          Mocha2.prototype.enableGlobalSetup = function enableGlobalSetup(enabled = true) {
            this.options.enableGlobalSetup = Boolean(enabled);
            return this;
          };
          Mocha2.prototype.enableGlobalTeardown = function enableGlobalTeardown(enabled = true) {
            this.options.enableGlobalTeardown = Boolean(enabled);
            return this;
          };
          Mocha2.prototype.hasGlobalSetupFixtures = function hasGlobalSetupFixtures() {
            return Boolean(this.options.globalSetup.length);
          };
          Mocha2.prototype.hasGlobalTeardownFixtures = function hasGlobalTeardownFixtures() {
            return Boolean(this.options.globalTeardown.length);
          };
        })(mocha$1, mocha$1.exports);
        process2.stdout = browserStdout({ label: false });
        var parseQuery = parseQuery$1;
        var highlightTags = highlightTags$1;
        var Mocha = mocha$1.exports;
        var mocha2 = new Mocha({ reporter: "html" });
        var Date$1 = commonjsGlobal.Date;
        var setTimeout$1 = commonjsGlobal.setTimeout;
        commonjsGlobal.setInterval;
        commonjsGlobal.clearTimeout;
        commonjsGlobal.clearInterval;
        var uncaughtExceptionHandlers = [];
        var originalOnerrorHandler = commonjsGlobal.onerror;
        process2.removeListener = function(e, fn) {
          if (e === "uncaughtException") {
            if (originalOnerrorHandler) {
              commonjsGlobal.onerror = originalOnerrorHandler;
            } else {
              commonjsGlobal.onerror = function() {
              };
            }
            var i = uncaughtExceptionHandlers.indexOf(fn);
            if (i !== -1) {
              uncaughtExceptionHandlers.splice(i, 1);
            }
          }
        };
        process2.listenerCount = function(name2) {
          if (name2 === "uncaughtException") {
            return uncaughtExceptionHandlers.length;
          }
          return 0;
        };
        process2.on = function(e, fn) {
          if (e === "uncaughtException") {
            commonjsGlobal.onerror = function(msg, url, line2, col, err) {
              fn(err || new Error(msg + " (" + url + ":" + line2 + ":" + col + ")"));
              return !mocha2.options.allowUncaught;
            };
            uncaughtExceptionHandlers.push(fn);
          }
        };
        process2.listeners = function(e) {
          if (e === "uncaughtException") {
            return uncaughtExceptionHandlers;
          }
          return [];
        };
        mocha2.suite.removeAllListeners("pre-require");
        var immediateQueue = [];
        var immediateTimeout;
        function timeslice() {
          var immediateStart = new Date$1().getTime();
          while (immediateQueue.length && new Date$1().getTime() - immediateStart < 100) {
            immediateQueue.shift()();
          }
          if (immediateQueue.length) {
            immediateTimeout = setTimeout$1(timeslice, 0);
          } else {
            immediateTimeout = null;
          }
        }
        Mocha.Runner.immediately = function(callback) {
          immediateQueue.push(callback);
          if (!immediateTimeout) {
            immediateTimeout = setTimeout$1(timeslice, 0);
          }
        };
        mocha2.throwError = function(err) {
          uncaughtExceptionHandlers.forEach(function(fn) {
            fn(err);
          });
          throw err;
        };
        mocha2.ui = function(ui2) {
          Mocha.prototype.ui.call(this, ui2);
          this.suite.emit("pre-require", commonjsGlobal, null, this);
          return this;
        };
        mocha2.setup = function(opts) {
          if (typeof opts === "string") {
            opts = { ui: opts };
          }
          if (opts.delay === true) {
            this.delay();
          }
          var self2 = this;
          Object.keys(opts).filter(function(opt) {
            return opt !== "delay";
          }).forEach(function(opt) {
            if (Object.prototype.hasOwnProperty.call(opts, opt)) {
              self2[opt](opts[opt]);
            }
          });
          return this;
        };
        mocha2.run = function(fn) {
          var options = mocha2.options;
          mocha2.globals("location");
          var query2 = parseQuery(commonjsGlobal.location.search || "");
          if (query2.grep) {
            mocha2.grep(query2.grep);
          }
          if (query2.fgrep) {
            mocha2.fgrep(query2.fgrep);
          }
          if (query2.invert) {
            mocha2.invert();
          }
          return Mocha.prototype.run.call(mocha2, function(err) {
            var document2 = commonjsGlobal.document;
            if (document2 && document2.getElementById("mocha") && options.noHighlighting !== true) {
              highlightTags("code");
            }
            if (fn) {
              fn(err);
            }
          });
        };
        Mocha.process = process2;
        commonjsGlobal.Mocha = Mocha;
        commonjsGlobal.mocha = mocha2;
        [
          "describe",
          "context",
          "it",
          "specify",
          "xdescribe",
          "xcontext",
          "xit",
          "xspecify",
          "before",
          "beforeEach",
          "afterEach",
          "after"
        ].forEach(function(key) {
          mocha2[key] = commonjsGlobal[key];
        });
        var browserEntry = mocha2;
        return browserEntry;
      }));
    }
  });

  // node_modules/.pnpm/ansi-styles@5.2.0/node_modules/ansi-styles/index.js
  var require_ansi_styles = __commonJS({
    "node_modules/.pnpm/ansi-styles@5.2.0/node_modules/ansi-styles/index.js"(exports, module2) {
      "use strict";
      var ANSI_BACKGROUND_OFFSET = 10;
      var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
      var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
      function assembleStyles() {
        const codes = /* @__PURE__ */ new Map();
        const styles2 = {
          modifier: {
            reset: [0, 0],
            // 21 isn't widely supported and 22 does the same thing
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            overline: [53, 55],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            // Bright color
            blackBright: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            // Bright color
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        };
        styles2.color.gray = styles2.color.blackBright;
        styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
        styles2.color.grey = styles2.color.blackBright;
        styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
        for (const [groupName, group] of Object.entries(styles2)) {
          for (const [styleName, style] of Object.entries(group)) {
            styles2[styleName] = {
              open: `\x1B[${style[0]}m`,
              close: `\x1B[${style[1]}m`
            };
            group[styleName] = styles2[styleName];
            codes.set(style[0], style[1]);
          }
          Object.defineProperty(styles2, groupName, {
            value: group,
            enumerable: false
          });
        }
        Object.defineProperty(styles2, "codes", {
          value: codes,
          enumerable: false
        });
        styles2.color.close = "\x1B[39m";
        styles2.bgColor.close = "\x1B[49m";
        styles2.color.ansi256 = wrapAnsi256();
        styles2.color.ansi16m = wrapAnsi16m();
        styles2.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
        styles2.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
        Object.defineProperties(styles2, {
          rgbToAnsi256: {
            value: (red, green, blue) => {
              if (red === green && green === blue) {
                if (red < 8) {
                  return 16;
                }
                if (red > 248) {
                  return 231;
                }
                return Math.round((red - 8) / 247 * 24) + 232;
              }
              return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
            },
            enumerable: false
          },
          hexToRgb: {
            value: (hex2) => {
              const matches2 = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex2.toString(16));
              if (!matches2) {
                return [0, 0, 0];
              }
              let { colorString } = matches2.groups;
              if (colorString.length === 3) {
                colorString = colorString.split("").map((character) => character + character).join("");
              }
              const integer = Number.parseInt(colorString, 16);
              return [
                integer >> 16 & 255,
                integer >> 8 & 255,
                integer & 255
              ];
            },
            enumerable: false
          },
          hexToAnsi256: {
            value: (hex2) => styles2.rgbToAnsi256(...styles2.hexToRgb(hex2)),
            enumerable: false
          }
        });
        return styles2;
      }
      Object.defineProperty(module2, "exports", {
        enumerable: true,
        get: assembleStyles
      });
    }
  });

  // node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/collections.js
  var require_collections = __commonJS({
    "node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/collections.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printIteratorEntries = printIteratorEntries;
      exports.printIteratorValues = printIteratorValues;
      exports.printListItems = printListItems;
      exports.printObjectProperties = printObjectProperties;
      var getKeysOfEnumerableProperties = (object, compareKeys) => {
        const keys = Object.keys(object).sort(compareKeys);
        if (Object.getOwnPropertySymbols) {
          Object.getOwnPropertySymbols(object).forEach((symbol) => {
            if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
              keys.push(symbol);
            }
          });
        }
        return keys;
      };
      function printIteratorEntries(iterator, config3, indentation, depth, refs, printer, separator = ": ") {
        let result = "";
        let current = iterator.next();
        if (!current.done) {
          result += config3.spacingOuter;
          const indentationNext = indentation + config3.indent;
          while (!current.done) {
            const name = printer(
              current.value[0],
              config3,
              indentationNext,
              depth,
              refs
            );
            const value = printer(
              current.value[1],
              config3,
              indentationNext,
              depth,
              refs
            );
            result += indentationNext + name + separator + value;
            current = iterator.next();
            if (!current.done) {
              result += "," + config3.spacingInner;
            } else if (!config3.min) {
              result += ",";
            }
          }
          result += config3.spacingOuter + indentation;
        }
        return result;
      }
      function printIteratorValues(iterator, config3, indentation, depth, refs, printer) {
        let result = "";
        let current = iterator.next();
        if (!current.done) {
          result += config3.spacingOuter;
          const indentationNext = indentation + config3.indent;
          while (!current.done) {
            result += indentationNext + printer(current.value, config3, indentationNext, depth, refs);
            current = iterator.next();
            if (!current.done) {
              result += "," + config3.spacingInner;
            } else if (!config3.min) {
              result += ",";
            }
          }
          result += config3.spacingOuter + indentation;
        }
        return result;
      }
      function printListItems(list, config3, indentation, depth, refs, printer) {
        let result = "";
        if (list.length) {
          result += config3.spacingOuter;
          const indentationNext = indentation + config3.indent;
          for (let i = 0; i < list.length; i++) {
            result += indentationNext;
            if (i in list) {
              result += printer(list[i], config3, indentationNext, depth, refs);
            }
            if (i < list.length - 1) {
              result += "," + config3.spacingInner;
            } else if (!config3.min) {
              result += ",";
            }
          }
          result += config3.spacingOuter + indentation;
        }
        return result;
      }
      function printObjectProperties(val, config3, indentation, depth, refs, printer) {
        let result = "";
        const keys = getKeysOfEnumerableProperties(val, config3.compareKeys);
        if (keys.length) {
          result += config3.spacingOuter;
          const indentationNext = indentation + config3.indent;
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const name = printer(key, config3, indentationNext, depth, refs);
            const value = printer(val[key], config3, indentationNext, depth, refs);
            result += indentationNext + name + ": " + value;
            if (i < keys.length - 1) {
              result += "," + config3.spacingInner;
            } else if (!config3.min) {
              result += ",";
            }
          }
          result += config3.spacingOuter + indentation;
        }
        return result;
      }
    }
  });

  // node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/AsymmetricMatcher.js
  var require_AsymmetricMatcher = __commonJS({
    "node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/AsymmetricMatcher.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.test = exports.serialize = exports.default = void 0;
      var _collections = require_collections();
      var global2 = (function() {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        } else if (typeof global2 !== "undefined") {
          return global2;
        } else if (typeof self !== "undefined") {
          return self;
        } else if (typeof window !== "undefined") {
          return window;
        } else {
          return Function("return this")();
        }
      })();
      var Symbol2 = global2["jest-symbol-do-not-touch"] || global2.Symbol;
      var asymmetricMatcher = typeof Symbol2 === "function" && Symbol2.for ? Symbol2.for("jest.asymmetricMatcher") : 1267621;
      var SPACE = " ";
      var serialize = (val, config3, indentation, depth, refs, printer) => {
        const stringedValue = val.toString();
        if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") {
          if (++depth > config3.maxDepth) {
            return "[" + stringedValue + "]";
          }
          return stringedValue + SPACE + "[" + (0, _collections.printListItems)(
            val.sample,
            config3,
            indentation,
            depth,
            refs,
            printer
          ) + "]";
        }
        if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") {
          if (++depth > config3.maxDepth) {
            return "[" + stringedValue + "]";
          }
          return stringedValue + SPACE + "{" + (0, _collections.printObjectProperties)(
            val.sample,
            config3,
            indentation,
            depth,
            refs,
            printer
          ) + "}";
        }
        if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching") {
          return stringedValue + SPACE + printer(val.sample, config3, indentation, depth, refs);
        }
        if (stringedValue === "StringContaining" || stringedValue === "StringNotContaining") {
          return stringedValue + SPACE + printer(val.sample, config3, indentation, depth, refs);
        }
        return val.toAsymmetricMatcher();
      };
      exports.serialize = serialize;
      var test2 = (val) => val && val.$$typeof === asymmetricMatcher;
      exports.test = test2;
      var plugin = {
        serialize,
        test: test2
      };
      var _default = plugin;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js
  var require_ansi_regex = __commonJS({
    "node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js"(exports, module2) {
      "use strict";
      module2.exports = ({ onlyFirst = false } = {}) => {
        const pattern = [
          "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
          "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
        ].join("|");
        return new RegExp(pattern, onlyFirst ? void 0 : "g");
      };
    }
  });

  // node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/ConvertAnsi.js
  var require_ConvertAnsi = __commonJS({
    "node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/ConvertAnsi.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.test = exports.serialize = exports.default = void 0;
      var _ansiRegex = _interopRequireDefault(require_ansi_regex());
      var _ansiStyles = _interopRequireDefault(require_ansi_styles());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var toHumanReadableAnsi = (text) => text.replace((0, _ansiRegex.default)(), (match) => {
        switch (match) {
          case _ansiStyles.default.red.close:
          case _ansiStyles.default.green.close:
          case _ansiStyles.default.cyan.close:
          case _ansiStyles.default.gray.close:
          case _ansiStyles.default.white.close:
          case _ansiStyles.default.yellow.close:
          case _ansiStyles.default.bgRed.close:
          case _ansiStyles.default.bgGreen.close:
          case _ansiStyles.default.bgYellow.close:
          case _ansiStyles.default.inverse.close:
          case _ansiStyles.default.dim.close:
          case _ansiStyles.default.bold.close:
          case _ansiStyles.default.reset.open:
          case _ansiStyles.default.reset.close:
            return "</>";
          case _ansiStyles.default.red.open:
            return "<red>";
          case _ansiStyles.default.green.open:
            return "<green>";
          case _ansiStyles.default.cyan.open:
            return "<cyan>";
          case _ansiStyles.default.gray.open:
            return "<gray>";
          case _ansiStyles.default.white.open:
            return "<white>";
          case _ansiStyles.default.yellow.open:
            return "<yellow>";
          case _ansiStyles.default.bgRed.open:
            return "<bgRed>";
          case _ansiStyles.default.bgGreen.open:
            return "<bgGreen>";
          case _ansiStyles.default.bgYellow.open:
            return "<bgYellow>";
          case _ansiStyles.default.inverse.open:
            return "<inverse>";
          case _ansiStyles.default.dim.open:
            return "<dim>";
          case _ansiStyles.default.bold.open:
            return "<bold>";
          default:
            return "";
        }
      });
      var test2 = (val) => typeof val === "string" && !!val.match((0, _ansiRegex.default)());
      exports.test = test2;
      var serialize = (val, config3, indentation, depth, refs, printer) => printer(toHumanReadableAnsi(val), config3, indentation, depth, refs);
      exports.serialize = serialize;
      var plugin = {
        serialize,
        test: test2
      };
      var _default = plugin;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/DOMCollection.js
  var require_DOMCollection = __commonJS({
    "node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/DOMCollection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.test = exports.serialize = exports.default = void 0;
      var _collections = require_collections();
      var SPACE = " ";
      var OBJECT_NAMES = ["DOMStringMap", "NamedNodeMap"];
      var ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
      var testName = (name) => OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
      var test2 = (val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
      exports.test = test2;
      var isNamedNodeMap = (collection) => collection.constructor.name === "NamedNodeMap";
      var serialize = (collection, config3, indentation, depth, refs, printer) => {
        const name = collection.constructor.name;
        if (++depth > config3.maxDepth) {
          return "[" + name + "]";
        }
        return (config3.min ? "" : name + SPACE) + (OBJECT_NAMES.indexOf(name) !== -1 ? "{" + (0, _collections.printObjectProperties)(
          isNamedNodeMap(collection) ? Array.from(collection).reduce((props, attribute) => {
            props[attribute.name] = attribute.value;
            return props;
          }, {}) : { ...collection },
          config3,
          indentation,
          depth,
          refs,
          printer
        ) + "}" : "[" + (0, _collections.printListItems)(
          Array.from(collection),
          config3,
          indentation,
          depth,
          refs,
          printer
        ) + "]");
      };
      exports.serialize = serialize;
      var plugin = {
        serialize,
        test: test2
      };
      var _default = plugin;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/lib/escapeHTML.js
  var require_escapeHTML = __commonJS({
    "node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/lib/escapeHTML.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = escapeHTML2;
      function escapeHTML2(str) {
        return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
    }
  });

  // node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/lib/markup.js
  var require_markup = __commonJS({
    "node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/lib/markup.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printText = exports.printProps = exports.printElementAsLeaf = exports.printElement = exports.printComment = exports.printChildren = void 0;
      var _escapeHTML = _interopRequireDefault(require_escapeHTML());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var printProps2 = (keys, props, config3, indentation, depth, refs, printer) => {
        const indentationNext = indentation + config3.indent;
        const colors = config3.colors;
        return keys.map((key) => {
          const value = props[key];
          let printed = printer(value, config3, indentationNext, depth, refs);
          if (typeof value !== "string") {
            if (printed.indexOf("\n") !== -1) {
              printed = config3.spacingOuter + indentationNext + printed + config3.spacingOuter + indentation;
            }
            printed = "{" + printed + "}";
          }
          return config3.spacingInner + indentation + colors.prop.open + key + colors.prop.close + "=" + colors.value.open + printed + colors.value.close;
        }).join("");
      };
      exports.printProps = printProps2;
      var printChildren2 = (children, config3, indentation, depth, refs, printer) => children.map(
        (child) => config3.spacingOuter + indentation + (typeof child === "string" ? printText2(child, config3) : printer(child, config3, indentation, depth, refs))
      ).join("");
      exports.printChildren = printChildren2;
      var printText2 = (text, config3) => {
        const contentColor = config3.colors.content;
        return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
      };
      exports.printText = printText2;
      var printComment2 = (comment, config3) => {
        const commentColor = config3.colors.comment;
        return commentColor.open + "<!--" + (0, _escapeHTML.default)(comment) + "-->" + commentColor.close;
      };
      exports.printComment = printComment2;
      var printElement2 = (type3, printedProps, printedChildren, config3, indentation) => {
        const tagColor = config3.colors.tag;
        return tagColor.open + "<" + type3 + (printedProps && tagColor.close + printedProps + config3.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config3.spacingOuter + indentation + tagColor.open + "</" + type3 : (printedProps && !config3.min ? "" : " ") + "/") + ">" + tagColor.close;
      };
      exports.printElement = printElement2;
      var printElementAsLeaf2 = (type3, config3) => {
        const tagColor = config3.colors.tag;
        return tagColor.open + "<" + type3 + tagColor.close + " \u2026" + tagColor.open + " />" + tagColor.close;
      };
      exports.printElementAsLeaf = printElementAsLeaf2;
    }
  });

  // node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/DOMElement.js
  var require_DOMElement = __commonJS({
    "node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/DOMElement.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.test = exports.serialize = exports.default = void 0;
      var _markup = require_markup();
      var ELEMENT_NODE2 = 1;
      var TEXT_NODE2 = 3;
      var COMMENT_NODE2 = 8;
      var FRAGMENT_NODE2 = 11;
      var ELEMENT_REGEXP2 = /^((HTML|SVG)\w*)?Element$/;
      var testHasAttribute = (val) => {
        try {
          return typeof val.hasAttribute === "function" && val.hasAttribute("is");
        } catch {
          return false;
        }
      };
      var testNode2 = (val) => {
        const constructorName = val.constructor.name;
        const { nodeType, tagName } = val;
        const isCustomElement2 = typeof tagName === "string" && tagName.includes("-") || testHasAttribute(val);
        return nodeType === ELEMENT_NODE2 && (ELEMENT_REGEXP2.test(constructorName) || isCustomElement2) || nodeType === TEXT_NODE2 && constructorName === "Text" || nodeType === COMMENT_NODE2 && constructorName === "Comment" || nodeType === FRAGMENT_NODE2 && constructorName === "DocumentFragment";
      };
      var test2 = (val) => {
        var _val$constructor;
        return (val === null || val === void 0 ? void 0 : (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode2(val);
      };
      exports.test = test2;
      function nodeIsText2(node) {
        return node.nodeType === TEXT_NODE2;
      }
      function nodeIsComment2(node) {
        return node.nodeType === COMMENT_NODE2;
      }
      function nodeIsFragment2(node) {
        return node.nodeType === FRAGMENT_NODE2;
      }
      var serialize = (node, config3, indentation, depth, refs, printer) => {
        if (nodeIsText2(node)) {
          return (0, _markup.printText)(node.data, config3);
        }
        if (nodeIsComment2(node)) {
          return (0, _markup.printComment)(node.data, config3);
        }
        const type3 = nodeIsFragment2(node) ? "DocumentFragment" : node.tagName.toLowerCase();
        if (++depth > config3.maxDepth) {
          return (0, _markup.printElementAsLeaf)(type3, config3);
        }
        return (0, _markup.printElement)(
          type3,
          (0, _markup.printProps)(
            nodeIsFragment2(node) ? [] : Array.from(node.attributes).map((attr) => attr.name).sort(),
            nodeIsFragment2(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => {
              props[attribute.name] = attribute.value;
              return props;
            }, {}),
            config3,
            indentation + config3.indent,
            depth,
            refs,
            printer
          ),
          (0, _markup.printChildren)(
            Array.prototype.slice.call(node.childNodes || node.children),
            config3,
            indentation + config3.indent,
            depth,
            refs,
            printer
          ),
          config3,
          indentation
        );
      };
      exports.serialize = serialize;
      var plugin = {
        serialize,
        test: test2
      };
      var _default = plugin;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/Immutable.js
  var require_Immutable = __commonJS({
    "node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/Immutable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.test = exports.serialize = exports.default = void 0;
      var _collections = require_collections();
      var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
      var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
      var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
      var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
      var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
      var IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
      var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
      var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
      var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
      var getImmutableName = (name) => "Immutable." + name;
      var printAsLeaf = (name) => "[" + name + "]";
      var SPACE = " ";
      var LAZY = "\u2026";
      var printImmutableEntries = (val, config3, indentation, depth, refs, printer, type3) => ++depth > config3.maxDepth ? printAsLeaf(getImmutableName(type3)) : getImmutableName(type3) + SPACE + "{" + (0, _collections.printIteratorEntries)(
        val.entries(),
        config3,
        indentation,
        depth,
        refs,
        printer
      ) + "}";
      function getRecordEntries(val) {
        let i = 0;
        return {
          next() {
            if (i < val._keys.length) {
              const key = val._keys[i++];
              return {
                done: false,
                value: [key, val.get(key)]
              };
            }
            return {
              done: true,
              value: void 0
            };
          }
        };
      }
      var printImmutableRecord = (val, config3, indentation, depth, refs, printer) => {
        const name = getImmutableName(val._name || "Record");
        return ++depth > config3.maxDepth ? printAsLeaf(name) : name + SPACE + "{" + (0, _collections.printIteratorEntries)(
          getRecordEntries(val),
          config3,
          indentation,
          depth,
          refs,
          printer
        ) + "}";
      };
      var printImmutableSeq = (val, config3, indentation, depth, refs, printer) => {
        const name = getImmutableName("Seq");
        if (++depth > config3.maxDepth) {
          return printAsLeaf(name);
        }
        if (val[IS_KEYED_SENTINEL]) {
          return name + SPACE + "{" + // from Immutable collection of entries or from ECMAScript object
          (val._iter || val._object ? (0, _collections.printIteratorEntries)(
            val.entries(),
            config3,
            indentation,
            depth,
            refs,
            printer
          ) : LAZY) + "}";
        }
        return name + SPACE + "[" + (val._iter || // from Immutable collection of values
        val._array || // from ECMAScript array
        val._collection || // from ECMAScript collection in immutable v4
        val._iterable ? (0, _collections.printIteratorValues)(
          val.values(),
          config3,
          indentation,
          depth,
          refs,
          printer
        ) : LAZY) + "]";
      };
      var printImmutableValues = (val, config3, indentation, depth, refs, printer, type3) => ++depth > config3.maxDepth ? printAsLeaf(getImmutableName(type3)) : getImmutableName(type3) + SPACE + "[" + (0, _collections.printIteratorValues)(
        val.values(),
        config3,
        indentation,
        depth,
        refs,
        printer
      ) + "]";
      var serialize = (val, config3, indentation, depth, refs, printer) => {
        if (val[IS_MAP_SENTINEL]) {
          return printImmutableEntries(
            val,
            config3,
            indentation,
            depth,
            refs,
            printer,
            val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map"
          );
        }
        if (val[IS_LIST_SENTINEL]) {
          return printImmutableValues(
            val,
            config3,
            indentation,
            depth,
            refs,
            printer,
            "List"
          );
        }
        if (val[IS_SET_SENTINEL]) {
          return printImmutableValues(
            val,
            config3,
            indentation,
            depth,
            refs,
            printer,
            val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set"
          );
        }
        if (val[IS_STACK_SENTINEL]) {
          return printImmutableValues(
            val,
            config3,
            indentation,
            depth,
            refs,
            printer,
            "Stack"
          );
        }
        if (val[IS_SEQ_SENTINEL]) {
          return printImmutableSeq(val, config3, indentation, depth, refs, printer);
        }
        return printImmutableRecord(val, config3, indentation, depth, refs, printer);
      };
      exports.serialize = serialize;
      var test2 = (val) => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
      exports.test = test2;
      var plugin = {
        serialize,
        test: test2
      };
      var _default = plugin;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/react-is@17.0.2/node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "node_modules/.pnpm/react-is@17.0.2/node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var REACT_ELEMENT_TYPE = 60103;
          var REACT_PORTAL_TYPE = 60106;
          var REACT_FRAGMENT_TYPE = 60107;
          var REACT_STRICT_MODE_TYPE = 60108;
          var REACT_PROFILER_TYPE = 60114;
          var REACT_PROVIDER_TYPE = 60109;
          var REACT_CONTEXT_TYPE = 60110;
          var REACT_FORWARD_REF_TYPE = 60112;
          var REACT_SUSPENSE_TYPE = 60113;
          var REACT_SUSPENSE_LIST_TYPE = 60120;
          var REACT_MEMO_TYPE = 60115;
          var REACT_LAZY_TYPE = 60116;
          var REACT_BLOCK_TYPE = 60121;
          var REACT_SERVER_BLOCK_TYPE = 60122;
          var REACT_FUNDAMENTAL_TYPE = 60117;
          var REACT_SCOPE_TYPE = 60119;
          var REACT_OPAQUE_ID_TYPE = 60128;
          var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
          var REACT_OFFSCREEN_TYPE = 60130;
          var REACT_LEGACY_HIDDEN_TYPE = 60131;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            REACT_ELEMENT_TYPE = symbolFor("react.element");
            REACT_PORTAL_TYPE = symbolFor("react.portal");
            REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
            REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
            REACT_PROFILER_TYPE = symbolFor("react.profiler");
            REACT_PROVIDER_TYPE = symbolFor("react.provider");
            REACT_CONTEXT_TYPE = symbolFor("react.context");
            REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
            REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
            REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
            REACT_MEMO_TYPE = symbolFor("react.memo");
            REACT_LAZY_TYPE = symbolFor("react.lazy");
            REACT_BLOCK_TYPE = symbolFor("react.block");
            REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
            REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
            REACT_SCOPE_TYPE = symbolFor("react.scope");
            REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
            REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
            REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
            REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
          }
          var enableScopeAPI = false;
          function isValidElementType(type3) {
            if (typeof type3 === "string" || typeof type3 === "function") {
              return true;
            }
            if (type3 === REACT_FRAGMENT_TYPE || type3 === REACT_PROFILER_TYPE || type3 === REACT_DEBUG_TRACING_MODE_TYPE || type3 === REACT_STRICT_MODE_TYPE || type3 === REACT_SUSPENSE_TYPE || type3 === REACT_SUSPENSE_LIST_TYPE || type3 === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
              return true;
            }
            if (typeof type3 === "object" && type3 !== null) {
              if (type3.$$typeof === REACT_LAZY_TYPE || type3.$$typeof === REACT_MEMO_TYPE || type3.$$typeof === REACT_PROVIDER_TYPE || type3.$$typeof === REACT_CONTEXT_TYPE || type3.$$typeof === REACT_FORWARD_REF_TYPE || type3.$$typeof === REACT_FUNDAMENTAL_TYPE || type3.$$typeof === REACT_BLOCK_TYPE || type3[0] === REACT_SERVER_BLOCK_TYPE) {
                return true;
              }
            }
            return false;
          }
          function typeOf(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type3 = object.type;
                  switch (type3) {
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                    case REACT_SUSPENSE_LIST_TYPE:
                      return type3;
                    default:
                      var $$typeofType = type3 && type3.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          var hasWarnedAboutDeprecatedIsConcurrentMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
              }
            }
            return false;
          }
          function isConcurrentMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
                hasWarnedAboutDeprecatedIsConcurrentMode = true;
                console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
              }
            }
            return false;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement2(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement2;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // node_modules/.pnpm/react-is@17.0.2/node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/.pnpm/react-is@17.0.2/node_modules/react-is/index.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_is_development();
      }
    }
  });

  // node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/ReactElement.js
  var require_ReactElement = __commonJS({
    "node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/ReactElement.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.test = exports.serialize = exports.default = void 0;
      var ReactIs = _interopRequireWildcard(require_react_is());
      var _markup = require_markup();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { default: obj };
        }
        var cache = _getRequireWildcardCache(nodeInterop);
        if (cache && cache.has(obj)) {
          return cache.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        if (cache) {
          cache.set(obj, newObj);
        }
        return newObj;
      }
      var getChildren = (arg, children = []) => {
        if (Array.isArray(arg)) {
          arg.forEach((item) => {
            getChildren(item, children);
          });
        } else if (arg != null && arg !== false) {
          children.push(arg);
        }
        return children;
      };
      var getType = (element) => {
        const type3 = element.type;
        if (typeof type3 === "string") {
          return type3;
        }
        if (typeof type3 === "function") {
          return type3.displayName || type3.name || "Unknown";
        }
        if (ReactIs.isFragment(element)) {
          return "React.Fragment";
        }
        if (ReactIs.isSuspense(element)) {
          return "React.Suspense";
        }
        if (typeof type3 === "object" && type3 !== null) {
          if (ReactIs.isContextProvider(element)) {
            return "Context.Provider";
          }
          if (ReactIs.isContextConsumer(element)) {
            return "Context.Consumer";
          }
          if (ReactIs.isForwardRef(element)) {
            if (type3.displayName) {
              return type3.displayName;
            }
            const functionName = type3.render.displayName || type3.render.name || "";
            return functionName !== "" ? "ForwardRef(" + functionName + ")" : "ForwardRef";
          }
          if (ReactIs.isMemo(element)) {
            const functionName = type3.displayName || type3.type.displayName || type3.type.name || "";
            return functionName !== "" ? "Memo(" + functionName + ")" : "Memo";
          }
        }
        return "UNDEFINED";
      };
      var getPropKeys = (element) => {
        const { props } = element;
        return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
      };
      var serialize = (element, config3, indentation, depth, refs, printer) => ++depth > config3.maxDepth ? (0, _markup.printElementAsLeaf)(getType(element), config3) : (0, _markup.printElement)(
        getType(element),
        (0, _markup.printProps)(
          getPropKeys(element),
          element.props,
          config3,
          indentation + config3.indent,
          depth,
          refs,
          printer
        ),
        (0, _markup.printChildren)(
          getChildren(element.props.children),
          config3,
          indentation + config3.indent,
          depth,
          refs,
          printer
        ),
        config3,
        indentation
      );
      exports.serialize = serialize;
      var test2 = (val) => val != null && ReactIs.isElement(val);
      exports.test = test2;
      var plugin = {
        serialize,
        test: test2
      };
      var _default = plugin;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/ReactTestComponent.js
  var require_ReactTestComponent = __commonJS({
    "node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/plugins/ReactTestComponent.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.test = exports.serialize = exports.default = void 0;
      var _markup = require_markup();
      var global2 = (function() {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        } else if (typeof global2 !== "undefined") {
          return global2;
        } else if (typeof self !== "undefined") {
          return self;
        } else if (typeof window !== "undefined") {
          return window;
        } else {
          return Function("return this")();
        }
      })();
      var Symbol2 = global2["jest-symbol-do-not-touch"] || global2.Symbol;
      var testSymbol = typeof Symbol2 === "function" && Symbol2.for ? Symbol2.for("react.test.json") : 245830487;
      var getPropKeys = (object) => {
        const { props } = object;
        return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
      };
      var serialize = (object, config3, indentation, depth, refs, printer) => ++depth > config3.maxDepth ? (0, _markup.printElementAsLeaf)(object.type, config3) : (0, _markup.printElement)(
        object.type,
        object.props ? (0, _markup.printProps)(
          getPropKeys(object),
          object.props,
          config3,
          indentation + config3.indent,
          depth,
          refs,
          printer
        ) : "",
        object.children ? (0, _markup.printChildren)(
          object.children,
          config3,
          indentation + config3.indent,
          depth,
          refs,
          printer
        ) : "",
        config3,
        indentation
      );
      exports.serialize = serialize;
      var test2 = (val) => val && val.$$typeof === testSymbol;
      exports.test = test2;
      var plugin = {
        serialize,
        test: test2
      };
      var _default = plugin;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/index.js
  var require_build = __commonJS({
    "node_modules/.pnpm/pretty-format@27.5.1/node_modules/pretty-format/build/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = exports.DEFAULT_OPTIONS = void 0;
      exports.format = format2;
      exports.plugins = void 0;
      var _ansiStyles = _interopRequireDefault(require_ansi_styles());
      var _collections = require_collections();
      var _AsymmetricMatcher = _interopRequireDefault(
        require_AsymmetricMatcher()
      );
      var _ConvertAnsi = _interopRequireDefault(require_ConvertAnsi());
      var _DOMCollection = _interopRequireDefault(require_DOMCollection());
      var _DOMElement = _interopRequireDefault(require_DOMElement());
      var _Immutable = _interopRequireDefault(require_Immutable());
      var _ReactElement = _interopRequireDefault(require_ReactElement());
      var _ReactTestComponent = _interopRequireDefault(
        require_ReactTestComponent()
      );
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var toString2 = Object.prototype.toString;
      var toISOString = Date.prototype.toISOString;
      var errorToString = Error.prototype.toString;
      var regExpToString = RegExp.prototype.toString;
      var getConstructorName2 = (val) => typeof val.constructor === "function" && val.constructor.name || "Object";
      var isWindow = (val) => typeof window !== "undefined" && val === window;
      var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
      var NEWLINE_REGEXP = /\n/gi;
      var PrettyFormatPluginError = class extends Error {
        constructor(message, stack) {
          super(message);
          this.stack = stack;
          this.name = this.constructor.name;
        }
      };
      function isToStringedArrayType(toStringed) {
        return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
      }
      function printNumber(val) {
        return Object.is(val, -0) ? "-0" : String(val);
      }
      function printBigInt(val) {
        return String(`${val}n`);
      }
      function printFunction(val, printFunctionName) {
        if (!printFunctionName) {
          return "[Function]";
        }
        return "[Function " + (val.name || "anonymous") + "]";
      }
      function printSymbol(val) {
        return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
      }
      function printError(val) {
        return "[" + errorToString.call(val) + "]";
      }
      function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
        if (val === true || val === false) {
          return "" + val;
        }
        if (val === void 0) {
          return "undefined";
        }
        if (val === null) {
          return "null";
        }
        const typeOf = typeof val;
        if (typeOf === "number") {
          return printNumber(val);
        }
        if (typeOf === "bigint") {
          return printBigInt(val);
        }
        if (typeOf === "string") {
          if (escapeString) {
            return '"' + val.replace(/"|\\/g, "\\$&") + '"';
          }
          return '"' + val + '"';
        }
        if (typeOf === "function") {
          return printFunction(val, printFunctionName);
        }
        if (typeOf === "symbol") {
          return printSymbol(val);
        }
        const toStringed = toString2.call(val);
        if (toStringed === "[object WeakMap]") {
          return "WeakMap {}";
        }
        if (toStringed === "[object WeakSet]") {
          return "WeakSet {}";
        }
        if (toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]") {
          return printFunction(val, printFunctionName);
        }
        if (toStringed === "[object Symbol]") {
          return printSymbol(val);
        }
        if (toStringed === "[object Date]") {
          return isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
        }
        if (toStringed === "[object Error]") {
          return printError(val);
        }
        if (toStringed === "[object RegExp]") {
          if (escapeRegex) {
            return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
          }
          return regExpToString.call(val);
        }
        if (val instanceof Error) {
          return printError(val);
        }
        return null;
      }
      function printComplexValue(val, config3, indentation, depth, refs, hasCalledToJSON) {
        if (refs.indexOf(val) !== -1) {
          return "[Circular]";
        }
        refs = refs.slice();
        refs.push(val);
        const hitMaxDepth = ++depth > config3.maxDepth;
        const min = config3.min;
        if (config3.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === "function" && !hasCalledToJSON) {
          return printer(val.toJSON(), config3, indentation, depth, refs, true);
        }
        const toStringed = toString2.call(val);
        if (toStringed === "[object Arguments]") {
          return hitMaxDepth ? "[Arguments]" : (min ? "" : "Arguments ") + "[" + (0, _collections.printListItems)(
            val,
            config3,
            indentation,
            depth,
            refs,
            printer
          ) + "]";
        }
        if (isToStringedArrayType(toStringed)) {
          return hitMaxDepth ? "[" + val.constructor.name + "]" : (min ? "" : !config3.printBasicPrototype && val.constructor.name === "Array" ? "" : val.constructor.name + " ") + "[" + (0, _collections.printListItems)(
            val,
            config3,
            indentation,
            depth,
            refs,
            printer
          ) + "]";
        }
        if (toStringed === "[object Map]") {
          return hitMaxDepth ? "[Map]" : "Map {" + (0, _collections.printIteratorEntries)(
            val.entries(),
            config3,
            indentation,
            depth,
            refs,
            printer,
            " => "
          ) + "}";
        }
        if (toStringed === "[object Set]") {
          return hitMaxDepth ? "[Set]" : "Set {" + (0, _collections.printIteratorValues)(
            val.values(),
            config3,
            indentation,
            depth,
            refs,
            printer
          ) + "}";
        }
        return hitMaxDepth || isWindow(val) ? "[" + getConstructorName2(val) + "]" : (min ? "" : !config3.printBasicPrototype && getConstructorName2(val) === "Object" ? "" : getConstructorName2(val) + " ") + "{" + (0, _collections.printObjectProperties)(
          val,
          config3,
          indentation,
          depth,
          refs,
          printer
        ) + "}";
      }
      function isNewPlugin(plugin) {
        return plugin.serialize != null;
      }
      function printPlugin(plugin, val, config3, indentation, depth, refs) {
        let printed;
        try {
          printed = isNewPlugin(plugin) ? plugin.serialize(val, config3, indentation, depth, refs, printer) : plugin.print(
            val,
            (valChild) => printer(valChild, config3, indentation, depth, refs),
            (str) => {
              const indentationNext = indentation + config3.indent;
              return indentationNext + str.replace(NEWLINE_REGEXP, "\n" + indentationNext);
            },
            {
              edgeSpacing: config3.spacingOuter,
              min: config3.min,
              spacing: config3.spacingInner
            },
            config3.colors
          );
        } catch (error) {
          throw new PrettyFormatPluginError(error.message, error.stack);
        }
        if (typeof printed !== "string") {
          throw new Error(
            `pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`
          );
        }
        return printed;
      }
      function findPlugin(plugins3, val) {
        for (let p = 0; p < plugins3.length; p++) {
          try {
            if (plugins3[p].test(val)) {
              return plugins3[p];
            }
          } catch (error) {
            throw new PrettyFormatPluginError(error.message, error.stack);
          }
        }
        return null;
      }
      function printer(val, config3, indentation, depth, refs, hasCalledToJSON) {
        const plugin = findPlugin(config3.plugins, val);
        if (plugin !== null) {
          return printPlugin(plugin, val, config3, indentation, depth, refs);
        }
        const basicResult = printBasicValue(
          val,
          config3.printFunctionName,
          config3.escapeRegex,
          config3.escapeString
        );
        if (basicResult !== null) {
          return basicResult;
        }
        return printComplexValue(
          val,
          config3,
          indentation,
          depth,
          refs,
          hasCalledToJSON
        );
      }
      var DEFAULT_THEME = {
        comment: "gray",
        content: "reset",
        prop: "yellow",
        tag: "cyan",
        value: "green"
      };
      var DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
      var DEFAULT_OPTIONS = {
        callToJSON: true,
        compareKeys: void 0,
        escapeRegex: false,
        escapeString: true,
        highlight: false,
        indent: 2,
        maxDepth: Infinity,
        min: false,
        plugins: [],
        printBasicPrototype: true,
        printFunctionName: true,
        theme: DEFAULT_THEME
      };
      exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;
      function validateOptions(options) {
        Object.keys(options).forEach((key) => {
          if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
            throw new Error(`pretty-format: Unknown option "${key}".`);
          }
        });
        if (options.min && options.indent !== void 0 && options.indent !== 0) {
          throw new Error(
            'pretty-format: Options "min" and "indent" cannot be used together.'
          );
        }
        if (options.theme !== void 0) {
          if (options.theme === null) {
            throw new Error('pretty-format: Option "theme" must not be null.');
          }
          if (typeof options.theme !== "object") {
            throw new Error(
              `pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`
            );
          }
        }
      }
      var getColorsHighlight = (options) => DEFAULT_THEME_KEYS.reduce((colors, key) => {
        const value = options.theme && options.theme[key] !== void 0 ? options.theme[key] : DEFAULT_THEME[key];
        const color = value && _ansiStyles.default[value];
        if (color && typeof color.close === "string" && typeof color.open === "string") {
          colors[key] = color;
        } else {
          throw new Error(
            `pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`
          );
        }
        return colors;
      }, /* @__PURE__ */ Object.create(null));
      var getColorsEmpty = () => DEFAULT_THEME_KEYS.reduce((colors, key) => {
        colors[key] = {
          close: "",
          open: ""
        };
        return colors;
      }, /* @__PURE__ */ Object.create(null));
      var getPrintFunctionName = (options) => options && options.printFunctionName !== void 0 ? options.printFunctionName : DEFAULT_OPTIONS.printFunctionName;
      var getEscapeRegex = (options) => options && options.escapeRegex !== void 0 ? options.escapeRegex : DEFAULT_OPTIONS.escapeRegex;
      var getEscapeString = (options) => options && options.escapeString !== void 0 ? options.escapeString : DEFAULT_OPTIONS.escapeString;
      var getConfig2 = (options) => {
        var _options$printBasicPr;
        return {
          callToJSON: options && options.callToJSON !== void 0 ? options.callToJSON : DEFAULT_OPTIONS.callToJSON,
          colors: options && options.highlight ? getColorsHighlight(options) : getColorsEmpty(),
          compareKeys: options && typeof options.compareKeys === "function" ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
          escapeRegex: getEscapeRegex(options),
          escapeString: getEscapeString(options),
          indent: options && options.min ? "" : createIndent(
            options && options.indent !== void 0 ? options.indent : DEFAULT_OPTIONS.indent
          ),
          maxDepth: options && options.maxDepth !== void 0 ? options.maxDepth : DEFAULT_OPTIONS.maxDepth,
          min: options && options.min !== void 0 ? options.min : DEFAULT_OPTIONS.min,
          plugins: options && options.plugins !== void 0 ? options.plugins : DEFAULT_OPTIONS.plugins,
          printBasicPrototype: (_options$printBasicPr = options === null || options === void 0 ? void 0 : options.printBasicPrototype) !== null && _options$printBasicPr !== void 0 ? _options$printBasicPr : true,
          printFunctionName: getPrintFunctionName(options),
          spacingInner: options && options.min ? " " : "\n",
          spacingOuter: options && options.min ? "" : "\n"
        };
      };
      function createIndent(indent) {
        return new Array(indent + 1).join(" ");
      }
      function format2(val, options) {
        if (options) {
          validateOptions(options);
          if (options.plugins) {
            const plugin = findPlugin(options.plugins, val);
            if (plugin !== null) {
              return printPlugin(plugin, val, getConfig2(options), "", 0, []);
            }
          }
        }
        const basicResult = printBasicValue(
          val,
          getPrintFunctionName(options),
          getEscapeRegex(options),
          getEscapeString(options)
        );
        if (basicResult !== null) {
          return basicResult;
        }
        return printComplexValue(val, getConfig2(options), "", 0, []);
      }
      var plugins2 = {
        AsymmetricMatcher: _AsymmetricMatcher.default,
        ConvertAnsi: _ConvertAnsi.default,
        DOMCollection: _DOMCollection.default,
        DOMElement: _DOMElement.default,
        Immutable: _Immutable.default,
        ReactElement: _ReactElement.default,
        ReactTestComponent: _ReactTestComponent.default
      };
      exports.plugins = plugins2;
      var _default = format2;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/util/iteratorProxy.js
  var require_iteratorProxy = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/util/iteratorProxy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      function iteratorProxy() {
        var values = this;
        var index = 0;
        var iter = {
          "@@iterator": function iterator() {
            return iter;
          },
          next: function next() {
            if (index < values.length) {
              var value = values[index];
              index = index + 1;
              return {
                done: false,
                value
              };
            } else {
              return {
                done: true
              };
            }
          }
        };
        return iter;
      }
      var _default = iteratorProxy;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/util/iterationDecorator.js
  var require_iterationDecorator = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/util/iterationDecorator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = iterationDecorator;
      var _iteratorProxy = _interopRequireDefault(require_iteratorProxy());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _typeof3(obj) {
        "@babel/helpers - typeof";
        return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof3(obj);
      }
      function iterationDecorator(collection, entries) {
        if (typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol") {
          Object.defineProperty(collection, Symbol.iterator, {
            value: _iteratorProxy.default.bind(entries)
          });
        }
        return collection;
      }
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/ariaPropsMap.js
  var require_ariaPropsMap = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/ariaPropsMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _iterableToArrayLimit(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it2) {
          if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it2) o = it2;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e2) {
              throw _e2;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it2 = it2.call(o);
        }, n: function n() {
          var step = it2.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e3) {
          didErr = true;
          err = _e3;
        }, f: function f() {
          try {
            if (!normalCompletion && it2.return != null) it2.return();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      var properties = [["aria-activedescendant", {
        "type": "id"
      }], ["aria-atomic", {
        "type": "boolean"
      }], ["aria-autocomplete", {
        "type": "token",
        "values": ["inline", "list", "both", "none"]
      }], ["aria-braillelabel", {
        "type": "string"
      }], ["aria-brailleroledescription", {
        "type": "string"
      }], ["aria-busy", {
        "type": "boolean"
      }], ["aria-checked", {
        "type": "tristate"
      }], ["aria-colcount", {
        type: "integer"
      }], ["aria-colindex", {
        type: "integer"
      }], ["aria-colspan", {
        type: "integer"
      }], ["aria-controls", {
        "type": "idlist"
      }], ["aria-current", {
        type: "token",
        values: ["page", "step", "location", "date", "time", true, false]
      }], ["aria-describedby", {
        "type": "idlist"
      }], ["aria-description", {
        "type": "string"
      }], ["aria-details", {
        "type": "id"
      }], ["aria-disabled", {
        "type": "boolean"
      }], ["aria-dropeffect", {
        "type": "tokenlist",
        "values": ["copy", "execute", "link", "move", "none", "popup"]
      }], ["aria-errormessage", {
        "type": "id"
      }], ["aria-expanded", {
        "type": "boolean",
        "allowundefined": true
      }], ["aria-flowto", {
        "type": "idlist"
      }], ["aria-grabbed", {
        "type": "boolean",
        "allowundefined": true
      }], ["aria-haspopup", {
        "type": "token",
        "values": [false, true, "menu", "listbox", "tree", "grid", "dialog"]
      }], ["aria-hidden", {
        "type": "boolean",
        "allowundefined": true
      }], ["aria-invalid", {
        "type": "token",
        "values": ["grammar", false, "spelling", true]
      }], ["aria-keyshortcuts", {
        type: "string"
      }], ["aria-label", {
        "type": "string"
      }], ["aria-labelledby", {
        "type": "idlist"
      }], ["aria-level", {
        "type": "integer"
      }], ["aria-live", {
        "type": "token",
        "values": ["assertive", "off", "polite"]
      }], ["aria-modal", {
        type: "boolean"
      }], ["aria-multiline", {
        "type": "boolean"
      }], ["aria-multiselectable", {
        "type": "boolean"
      }], ["aria-orientation", {
        "type": "token",
        "values": ["vertical", "undefined", "horizontal"]
      }], ["aria-owns", {
        "type": "idlist"
      }], ["aria-placeholder", {
        type: "string"
      }], ["aria-posinset", {
        "type": "integer"
      }], ["aria-pressed", {
        "type": "tristate"
      }], ["aria-readonly", {
        "type": "boolean"
      }], ["aria-relevant", {
        "type": "tokenlist",
        "values": ["additions", "all", "removals", "text"]
      }], ["aria-required", {
        "type": "boolean"
      }], ["aria-roledescription", {
        type: "string"
      }], ["aria-rowcount", {
        type: "integer"
      }], ["aria-rowindex", {
        type: "integer"
      }], ["aria-rowspan", {
        type: "integer"
      }], ["aria-selected", {
        "type": "boolean",
        "allowundefined": true
      }], ["aria-setsize", {
        "type": "integer"
      }], ["aria-sort", {
        "type": "token",
        "values": ["ascending", "descending", "none", "other"]
      }], ["aria-valuemax", {
        "type": "number"
      }], ["aria-valuemin", {
        "type": "number"
      }], ["aria-valuenow", {
        "type": "number"
      }], ["aria-valuetext", {
        "type": "string"
      }]];
      var ariaPropsMap = {
        entries: function entries() {
          return properties;
        },
        forEach: function forEach(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var _iterator = _createForOfIteratorHelper(properties), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values = _step$value[1];
              fn.call(thisArg, values, key, properties);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        },
        get: function get2(key) {
          var item = properties.find(function(tuple) {
            return tuple[0] === key ? true : false;
          });
          return item && item[1];
        },
        has: function has(key) {
          return !!ariaPropsMap.get(key);
        },
        keys: function keys() {
          return properties.map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
            return key;
          });
        },
        values: function values() {
          return properties.map(function(_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
            return values2;
          });
        }
      };
      var _default = (0, _iterationDecorator.default)(ariaPropsMap, ariaPropsMap.entries());
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/domMap.js
  var require_domMap = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/domMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _iterableToArrayLimit(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it2) {
          if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it2) o = it2;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e2) {
              throw _e2;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it2 = it2.call(o);
        }, n: function n() {
          var step = it2.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e3) {
          didErr = true;
          err = _e3;
        }, f: function f() {
          try {
            if (!normalCompletion && it2.return != null) it2.return();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      var dom = [["a", {
        reserved: false
      }], ["abbr", {
        reserved: false
      }], ["acronym", {
        reserved: false
      }], ["address", {
        reserved: false
      }], ["applet", {
        reserved: false
      }], ["area", {
        reserved: false
      }], ["article", {
        reserved: false
      }], ["aside", {
        reserved: false
      }], ["audio", {
        reserved: false
      }], ["b", {
        reserved: false
      }], ["base", {
        reserved: true
      }], ["bdi", {
        reserved: false
      }], ["bdo", {
        reserved: false
      }], ["big", {
        reserved: false
      }], ["blink", {
        reserved: false
      }], ["blockquote", {
        reserved: false
      }], ["body", {
        reserved: false
      }], ["br", {
        reserved: false
      }], ["button", {
        reserved: false
      }], ["canvas", {
        reserved: false
      }], ["caption", {
        reserved: false
      }], ["center", {
        reserved: false
      }], ["cite", {
        reserved: false
      }], ["code", {
        reserved: false
      }], ["col", {
        reserved: true
      }], ["colgroup", {
        reserved: true
      }], ["content", {
        reserved: false
      }], ["data", {
        reserved: false
      }], ["datalist", {
        reserved: false
      }], ["dd", {
        reserved: false
      }], ["del", {
        reserved: false
      }], ["details", {
        reserved: false
      }], ["dfn", {
        reserved: false
      }], ["dialog", {
        reserved: false
      }], ["dir", {
        reserved: false
      }], ["div", {
        reserved: false
      }], ["dl", {
        reserved: false
      }], ["dt", {
        reserved: false
      }], ["em", {
        reserved: false
      }], ["embed", {
        reserved: false
      }], ["fieldset", {
        reserved: false
      }], ["figcaption", {
        reserved: false
      }], ["figure", {
        reserved: false
      }], ["font", {
        reserved: false
      }], ["footer", {
        reserved: false
      }], ["form", {
        reserved: false
      }], ["frame", {
        reserved: false
      }], ["frameset", {
        reserved: false
      }], ["h1", {
        reserved: false
      }], ["h2", {
        reserved: false
      }], ["h3", {
        reserved: false
      }], ["h4", {
        reserved: false
      }], ["h5", {
        reserved: false
      }], ["h6", {
        reserved: false
      }], ["head", {
        reserved: true
      }], ["header", {
        reserved: false
      }], ["hgroup", {
        reserved: false
      }], ["hr", {
        reserved: false
      }], ["html", {
        reserved: true
      }], ["i", {
        reserved: false
      }], ["iframe", {
        reserved: false
      }], ["img", {
        reserved: false
      }], ["input", {
        reserved: false
      }], ["ins", {
        reserved: false
      }], ["kbd", {
        reserved: false
      }], ["keygen", {
        reserved: false
      }], ["label", {
        reserved: false
      }], ["legend", {
        reserved: false
      }], ["li", {
        reserved: false
      }], ["link", {
        reserved: true
      }], ["main", {
        reserved: false
      }], ["map", {
        reserved: false
      }], ["mark", {
        reserved: false
      }], ["marquee", {
        reserved: false
      }], ["menu", {
        reserved: false
      }], ["menuitem", {
        reserved: false
      }], ["meta", {
        reserved: true
      }], ["meter", {
        reserved: false
      }], ["nav", {
        reserved: false
      }], ["noembed", {
        reserved: true
      }], ["noscript", {
        reserved: true
      }], ["object", {
        reserved: false
      }], ["ol", {
        reserved: false
      }], ["optgroup", {
        reserved: false
      }], ["option", {
        reserved: false
      }], ["output", {
        reserved: false
      }], ["p", {
        reserved: false
      }], ["param", {
        reserved: true
      }], ["picture", {
        reserved: true
      }], ["pre", {
        reserved: false
      }], ["progress", {
        reserved: false
      }], ["q", {
        reserved: false
      }], ["rp", {
        reserved: false
      }], ["rt", {
        reserved: false
      }], ["rtc", {
        reserved: false
      }], ["ruby", {
        reserved: false
      }], ["s", {
        reserved: false
      }], ["samp", {
        reserved: false
      }], ["script", {
        reserved: true
      }], ["section", {
        reserved: false
      }], ["select", {
        reserved: false
      }], ["small", {
        reserved: false
      }], ["source", {
        reserved: true
      }], ["spacer", {
        reserved: false
      }], ["span", {
        reserved: false
      }], ["strike", {
        reserved: false
      }], ["strong", {
        reserved: false
      }], ["style", {
        reserved: true
      }], ["sub", {
        reserved: false
      }], ["summary", {
        reserved: false
      }], ["sup", {
        reserved: false
      }], ["table", {
        reserved: false
      }], ["tbody", {
        reserved: false
      }], ["td", {
        reserved: false
      }], ["textarea", {
        reserved: false
      }], ["tfoot", {
        reserved: false
      }], ["th", {
        reserved: false
      }], ["thead", {
        reserved: false
      }], ["time", {
        reserved: false
      }], ["title", {
        reserved: true
      }], ["tr", {
        reserved: false
      }], ["track", {
        reserved: true
      }], ["tt", {
        reserved: false
      }], ["u", {
        reserved: false
      }], ["ul", {
        reserved: false
      }], ["var", {
        reserved: false
      }], ["video", {
        reserved: false
      }], ["wbr", {
        reserved: false
      }], ["xmp", {
        reserved: false
      }]];
      var domMap = {
        entries: function entries() {
          return dom;
        },
        forEach: function forEach(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var _iterator = _createForOfIteratorHelper(dom), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values = _step$value[1];
              fn.call(thisArg, values, key, dom);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        },
        get: function get2(key) {
          var item = dom.find(function(tuple) {
            return tuple[0] === key ? true : false;
          });
          return item && item[1];
        },
        has: function has(key) {
          return !!domMap.get(key);
        },
        keys: function keys() {
          return dom.map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
            return key;
          });
        },
        values: function values() {
          return dom.map(function(_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
            return values2;
          });
        }
      };
      var _default = (0, _iterationDecorator.default)(domMap, domMap.entries());
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/commandRole.js
  var require_commandRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/commandRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var commandRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget"]]
      };
      var _default = commandRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js
  var require_compositeRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var compositeRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-activedescendant": null,
          "aria-disabled": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget"]]
      };
      var _default = compositeRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/inputRole.js
  var require_inputRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/inputRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var inputRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null
        },
        relatedConcepts: [{
          concept: {
            name: "input"
          },
          module: "XForms"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget"]]
      };
      var _default = inputRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js
  var require_landmarkRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var landmarkRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = landmarkRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js
  var require_rangeRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var rangeRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-valuemax": null,
          "aria-valuemin": null,
          "aria-valuenow": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default = rangeRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js
  var require_roletypeRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var roletypeRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {
          "aria-atomic": null,
          "aria-busy": null,
          "aria-controls": null,
          "aria-current": null,
          "aria-describedby": null,
          "aria-details": null,
          "aria-dropeffect": null,
          "aria-flowto": null,
          "aria-grabbed": null,
          "aria-hidden": null,
          "aria-keyshortcuts": null,
          "aria-label": null,
          "aria-labelledby": null,
          "aria-live": null,
          "aria-owns": null,
          "aria-relevant": null,
          "aria-roledescription": null
        },
        relatedConcepts: [{
          concept: {
            name: "role"
          },
          module: "XHTML"
        }, {
          concept: {
            name: "type"
          },
          module: "Dublin Core"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: []
      };
      var _default = roletypeRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js
  var require_sectionRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var sectionRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "frontmatter"
          },
          module: "DTB"
        }, {
          concept: {
            name: "level"
          },
          module: "DTB"
        }, {
          concept: {
            name: "level"
          },
          module: "SMIL"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default = sectionRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js
  var require_sectionheadRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var sectionheadRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default = sectionheadRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/selectRole.js
  var require_selectRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/selectRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var selectRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-orientation": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
      };
      var _default = selectRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/structureRole.js
  var require_structureRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/structureRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var structureRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype"]]
      };
      var _default = structureRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js
  var require_widgetRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var widgetRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype"]]
      };
      var _default = widgetRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/windowRole.js
  var require_windowRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/windowRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var windowRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-modal": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype"]]
      };
      var _default = windowRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js
  var require_ariaAbstractRoles = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _commandRole = _interopRequireDefault(require_commandRole());
      var _compositeRole = _interopRequireDefault(require_compositeRole());
      var _inputRole = _interopRequireDefault(require_inputRole());
      var _landmarkRole = _interopRequireDefault(require_landmarkRole());
      var _rangeRole = _interopRequireDefault(require_rangeRole());
      var _roletypeRole = _interopRequireDefault(require_roletypeRole());
      var _sectionRole = _interopRequireDefault(require_sectionRole());
      var _sectionheadRole = _interopRequireDefault(require_sectionheadRole());
      var _selectRole = _interopRequireDefault(require_selectRole());
      var _structureRole = _interopRequireDefault(require_structureRole());
      var _widgetRole = _interopRequireDefault(require_widgetRole());
      var _windowRole = _interopRequireDefault(require_windowRole());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ariaAbstractRoles = [["command", _commandRole.default], ["composite", _compositeRole.default], ["input", _inputRole.default], ["landmark", _landmarkRole.default], ["range", _rangeRole.default], ["roletype", _roletypeRole.default], ["section", _sectionRole.default], ["sectionhead", _sectionheadRole.default], ["select", _selectRole.default], ["structure", _structureRole.default], ["widget", _widgetRole.default], ["window", _windowRole.default]];
      var _default = ariaAbstractRoles;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/alertRole.js
  var require_alertRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/alertRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var alertRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-atomic": "true",
          "aria-live": "assertive"
        },
        relatedConcepts: [{
          concept: {
            name: "alert"
          },
          module: "XForms"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = alertRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js
  var require_alertdialogRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var alertdialogRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "alert"
          },
          module: "XForms"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
      };
      var _default = alertdialogRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/applicationRole.js
  var require_applicationRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/applicationRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var applicationRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-activedescendant": null,
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "Device Independence Delivery Unit"
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default = applicationRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/articleRole.js
  var require_articleRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/articleRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var articleRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-posinset": null,
          "aria-setsize": null
        },
        relatedConcepts: [{
          concept: {
            name: "article"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "document"]]
      };
      var _default = articleRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/bannerRole.js
  var require_bannerRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/bannerRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var bannerRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            constraints: ["scoped to the body element"],
            name: "header"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = bannerRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js
  var require_blockquoteRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var blockquoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "blockquote"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = blockquoteRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/buttonRole.js
  var require_buttonRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/buttonRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var buttonRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-pressed": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "type",
              value: "button"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "type",
              value: "image"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "type",
              value: "reset"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "type",
              value: "submit"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            name: "button"
          },
          module: "HTML"
        }, {
          concept: {
            name: "trigger"
          },
          module: "XForms"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command"]]
      };
      var _default = buttonRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/captionRole.js
  var require_captionRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/captionRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var captionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "caption"
          },
          module: "HTML"
        }],
        requireContextRole: ["figure", "grid", "table"],
        requiredContextRole: ["figure", "grid", "table"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = captionRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/cellRole.js
  var require_cellRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/cellRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var cellRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-colindex": null,
          "aria-colspan": null,
          "aria-rowindex": null,
          "aria-rowspan": null
        },
        relatedConcepts: [{
          concept: {
            constraints: ["ancestor table element has table role"],
            name: "td"
          },
          module: "HTML"
        }],
        requireContextRole: ["row"],
        requiredContextRole: ["row"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = cellRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js
  var require_checkboxRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var checkboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-checked": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-invalid": null,
          "aria-readonly": null,
          "aria-required": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "type",
              value: "checkbox"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            name: "option"
          },
          module: "ARIA"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-checked": null
        },
        superClass: [["roletype", "widget", "input"]]
      };
      var _default = checkboxRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/codeRole.js
  var require_codeRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/codeRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var codeRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "code"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = codeRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js
  var require_columnheaderRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var columnheaderRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-sort": null
        },
        relatedConcepts: [{
          concept: {
            name: "th"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "scope",
              value: "col"
            }],
            name: "th"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "scope",
              value: "colgroup"
            }],
            name: "th"
          },
          module: "HTML"
        }],
        requireContextRole: ["row"],
        requiredContextRole: ["row"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
      };
      var _default = columnheaderRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js
  var require_comboboxRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var comboboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-activedescendant": null,
          "aria-autocomplete": null,
          "aria-errormessage": null,
          "aria-invalid": null,
          "aria-readonly": null,
          "aria-required": null,
          "aria-expanded": "false",
          "aria-haspopup": "listbox"
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "list"
            }, {
              name: "type",
              value: "email"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "list"
            }, {
              name: "type",
              value: "search"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "list"
            }, {
              name: "type",
              value: "tel"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "list"
            }, {
              name: "type",
              value: "text"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "list"
            }, {
              name: "type",
              value: "url"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "list"
            }, {
              name: "type",
              value: "url"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "multiple"
            }, {
              constraints: ["undefined"],
              name: "size"
            }],
            constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
            name: "select"
          },
          module: "HTML"
        }, {
          concept: {
            name: "select"
          },
          module: "XForms"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-controls": null,
          "aria-expanded": "false"
        },
        superClass: [["roletype", "widget", "input"]]
      };
      var _default = comboboxRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js
  var require_complementaryRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var complementaryRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "aside"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "aria-label"
            }],
            constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
            name: "aside"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "aria-labelledby"
            }],
            constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
            name: "aside"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = complementaryRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js
  var require_contentinfoRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var contentinfoRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            constraints: ["scoped to the body element"],
            name: "footer"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = contentinfoRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/definitionRole.js
  var require_definitionRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/definitionRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var definitionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "dd"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = definitionRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/deletionRole.js
  var require_deletionRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/deletionRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var deletionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "del"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = deletionRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/dialogRole.js
  var require_dialogRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/dialogRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var dialogRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "dialog"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "window"]]
      };
      var _default = dialogRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/directoryRole.js
  var require_directoryRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/directoryRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var directoryRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          module: "DAISY Guide"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "list"]]
      };
      var _default = directoryRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/documentRole.js
  var require_documentRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/documentRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var documentRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "Device Independence Delivery Unit"
          }
        }, {
          concept: {
            name: "html"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default = documentRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js
  var require_emphasisRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var emphasisRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "em"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = emphasisRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/feedRole.js
  var require_feedRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/feedRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var feedRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["article"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "list"]]
      };
      var _default = feedRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/figureRole.js
  var require_figureRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/figureRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var figureRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "figure"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = figureRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/formRole.js
  var require_formRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/formRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var formRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "aria-label"
            }],
            name: "form"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "aria-labelledby"
            }],
            name: "form"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "name"
            }],
            name: "form"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = formRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/genericRole.js
  var require_genericRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/genericRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var genericRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "a"
          },
          module: "HTML"
        }, {
          concept: {
            name: "area"
          },
          module: "HTML"
        }, {
          concept: {
            name: "aside"
          },
          module: "HTML"
        }, {
          concept: {
            name: "b"
          },
          module: "HTML"
        }, {
          concept: {
            name: "bdo"
          },
          module: "HTML"
        }, {
          concept: {
            name: "body"
          },
          module: "HTML"
        }, {
          concept: {
            name: "data"
          },
          module: "HTML"
        }, {
          concept: {
            name: "div"
          },
          module: "HTML"
        }, {
          concept: {
            constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
            name: "footer"
          },
          module: "HTML"
        }, {
          concept: {
            constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
            name: "header"
          },
          module: "HTML"
        }, {
          concept: {
            name: "hgroup"
          },
          module: "HTML"
        }, {
          concept: {
            name: "i"
          },
          module: "HTML"
        }, {
          concept: {
            name: "pre"
          },
          module: "HTML"
        }, {
          concept: {
            name: "q"
          },
          module: "HTML"
        }, {
          concept: {
            name: "samp"
          },
          module: "HTML"
        }, {
          concept: {
            name: "section"
          },
          module: "HTML"
        }, {
          concept: {
            name: "small"
          },
          module: "HTML"
        }, {
          concept: {
            name: "span"
          },
          module: "HTML"
        }, {
          concept: {
            name: "u"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default = genericRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/gridRole.js
  var require_gridRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/gridRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var gridRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-multiselectable": null,
          "aria-readonly": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["row"], ["row", "rowgroup"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
      };
      var _default = gridRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js
  var require_gridcellRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var gridcellRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null,
          "aria-readonly": null,
          "aria-required": null,
          "aria-selected": null
        },
        relatedConcepts: [{
          concept: {
            constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
            name: "td"
          },
          module: "HTML"
        }],
        requireContextRole: ["row"],
        requiredContextRole: ["row"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
      };
      var _default = gridcellRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/groupRole.js
  var require_groupRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/groupRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var groupRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-activedescendant": null,
          "aria-disabled": null
        },
        relatedConcepts: [{
          concept: {
            name: "details"
          },
          module: "HTML"
        }, {
          concept: {
            name: "fieldset"
          },
          module: "HTML"
        }, {
          concept: {
            name: "optgroup"
          },
          module: "HTML"
        }, {
          concept: {
            name: "address"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = groupRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/headingRole.js
  var require_headingRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/headingRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var headingRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-level": "2"
        },
        relatedConcepts: [{
          concept: {
            name: "h1"
          },
          module: "HTML"
        }, {
          concept: {
            name: "h2"
          },
          module: "HTML"
        }, {
          concept: {
            name: "h3"
          },
          module: "HTML"
        }, {
          concept: {
            name: "h4"
          },
          module: "HTML"
        }, {
          concept: {
            name: "h5"
          },
          module: "HTML"
        }, {
          concept: {
            name: "h6"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-level": "2"
        },
        superClass: [["roletype", "structure", "sectionhead"]]
      };
      var _default = headingRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/imgRole.js
  var require_imgRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/imgRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var imgRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "alt"
            }],
            name: "img"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "alt"
            }],
            name: "img"
          },
          module: "HTML"
        }, {
          concept: {
            name: "imggroup"
          },
          module: "DTB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = imgRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/insertionRole.js
  var require_insertionRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/insertionRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var insertionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "ins"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = insertionRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/linkRole.js
  var require_linkRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/linkRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var linkRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-expanded": null,
          "aria-haspopup": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "href"
            }],
            name: "a"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "href"
            }],
            name: "area"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command"]]
      };
      var _default = linkRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/listRole.js
  var require_listRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/listRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var listRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "menu"
          },
          module: "HTML"
        }, {
          concept: {
            name: "ol"
          },
          module: "HTML"
        }, {
          concept: {
            name: "ul"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["listitem"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = listRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/listboxRole.js
  var require_listboxRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/listboxRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var listboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-invalid": null,
          "aria-multiselectable": null,
          "aria-readonly": null,
          "aria-required": null,
          "aria-orientation": "vertical"
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: [">1"],
              name: "size"
            }],
            constraints: ["the size attribute value is greater than 1"],
            name: "select"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "multiple"
            }],
            name: "select"
          },
          module: "HTML"
        }, {
          concept: {
            name: "datalist"
          },
          module: "HTML"
        }, {
          concept: {
            name: "list"
          },
          module: "ARIA"
        }, {
          concept: {
            name: "select"
          },
          module: "XForms"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["option", "group"], ["option"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
      };
      var _default = listboxRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/listitemRole.js
  var require_listitemRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/listitemRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var listitemRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-level": null,
          "aria-posinset": null,
          "aria-setsize": null
        },
        relatedConcepts: [{
          concept: {
            constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
            name: "li"
          },
          module: "HTML"
        }, {
          concept: {
            name: "item"
          },
          module: "XForms"
        }],
        requireContextRole: ["directory", "list"],
        requiredContextRole: ["directory", "list"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = listitemRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/logRole.js
  var require_logRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/logRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var logRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-live": "polite"
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = logRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/mainRole.js
  var require_mainRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/mainRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var mainRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "main"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = mainRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/markRole.js
  var require_markRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/markRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var markRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: [],
        props: {
          "aria-braillelabel": null,
          "aria-brailleroledescription": null,
          "aria-description": null
        },
        relatedConcepts: [{
          concept: {
            name: "mark"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = markRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js
  var require_marqueeRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var marqueeRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = marqueeRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/mathRole.js
  var require_mathRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/mathRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var mathRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "math"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = mathRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuRole.js
  var require_menuRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var menuRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-orientation": "vertical"
        },
        relatedConcepts: [{
          concept: {
            name: "MENU"
          },
          module: "JAPI"
        }, {
          concept: {
            name: "list"
          },
          module: "ARIA"
        }, {
          concept: {
            name: "select"
          },
          module: "XForms"
        }, {
          concept: {
            name: "sidebar"
          },
          module: "DTB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
      };
      var _default = menuRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menubarRole.js
  var require_menubarRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menubarRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var menubarRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-orientation": "horizontal"
        },
        relatedConcepts: [{
          concept: {
            name: "toolbar"
          },
          module: "ARIA"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
      };
      var _default = menubarRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js
  var require_menuitemRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var menuitemRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-posinset": null,
          "aria-setsize": null
        },
        relatedConcepts: [{
          concept: {
            name: "MENU_ITEM"
          },
          module: "JAPI"
        }, {
          concept: {
            name: "listitem"
          },
          module: "ARIA"
        }, {
          concept: {
            name: "option"
          },
          module: "ARIA"
        }],
        requireContextRole: ["group", "menu", "menubar"],
        requiredContextRole: ["group", "menu", "menubar"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command"]]
      };
      var _default = menuitemRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js
  var require_menuitemcheckboxRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var menuitemcheckboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "menuitem"
          },
          module: "ARIA"
        }],
        requireContextRole: ["group", "menu", "menubar"],
        requiredContextRole: ["group", "menu", "menubar"],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-checked": null
        },
        superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
      };
      var _default = menuitemcheckboxRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js
  var require_menuitemradioRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var menuitemradioRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "menuitem"
          },
          module: "ARIA"
        }],
        requireContextRole: ["group", "menu", "menubar"],
        requiredContextRole: ["group", "menu", "menubar"],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-checked": null
        },
        superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
      };
      var _default = menuitemradioRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/meterRole.js
  var require_meterRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/meterRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var meterRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-valuetext": null,
          "aria-valuemax": "100",
          "aria-valuemin": "0"
        },
        relatedConcepts: [{
          concept: {
            name: "meter"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-valuenow": null
        },
        superClass: [["roletype", "structure", "range"]]
      };
      var _default = meterRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/navigationRole.js
  var require_navigationRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/navigationRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var navigationRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "nav"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = navigationRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/noneRole.js
  var require_noneRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/noneRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var noneRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: []
      };
      var _default = noneRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/noteRole.js
  var require_noteRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/noteRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var noteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = noteRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/optionRole.js
  var require_optionRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/optionRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var optionRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-checked": null,
          "aria-posinset": null,
          "aria-setsize": null,
          "aria-selected": "false"
        },
        relatedConcepts: [{
          concept: {
            name: "item"
          },
          module: "XForms"
        }, {
          concept: {
            name: "listitem"
          },
          module: "ARIA"
        }, {
          concept: {
            name: "option"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-selected": "false"
        },
        superClass: [["roletype", "widget", "input"]]
      };
      var _default = optionRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js
  var require_paragraphRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var paragraphRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "p"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = paragraphRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/presentationRole.js
  var require_presentationRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/presentationRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var presentationRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "alt",
              value: ""
            }],
            name: "img"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default = presentationRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js
  var require_progressbarRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var progressbarRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-valuetext": null
        },
        relatedConcepts: [{
          concept: {
            name: "progress"
          },
          module: "HTML"
        }, {
          concept: {
            name: "status"
          },
          module: "ARIA"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
      };
      var _default = progressbarRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/radioRole.js
  var require_radioRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/radioRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var radioRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-checked": null,
          "aria-posinset": null,
          "aria-setsize": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "type",
              value: "radio"
            }],
            name: "input"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-checked": null
        },
        superClass: [["roletype", "widget", "input"]]
      };
      var _default = radioRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js
  var require_radiogroupRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var radiogroupRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null,
          "aria-readonly": null,
          "aria-required": null
        },
        relatedConcepts: [{
          concept: {
            name: "list"
          },
          module: "ARIA"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["radio"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
      };
      var _default = radiogroupRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/regionRole.js
  var require_regionRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/regionRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var regionRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "aria-label"
            }],
            name: "section"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "aria-labelledby"
            }],
            name: "section"
          },
          module: "HTML"
        }, {
          concept: {
            name: "Device Independence Glossart perceivable unit"
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = regionRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/rowRole.js
  var require_rowRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/rowRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var rowRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-colindex": null,
          "aria-expanded": null,
          "aria-level": null,
          "aria-posinset": null,
          "aria-rowindex": null,
          "aria-selected": null,
          "aria-setsize": null
        },
        relatedConcepts: [{
          concept: {
            name: "tr"
          },
          module: "HTML"
        }],
        requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
        requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
        requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
      };
      var _default = rowRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js
  var require_rowgroupRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var rowgroupRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "tbody"
          },
          module: "HTML"
        }, {
          concept: {
            name: "tfoot"
          },
          module: "HTML"
        }, {
          concept: {
            name: "thead"
          },
          module: "HTML"
        }],
        requireContextRole: ["grid", "table", "treegrid"],
        requiredContextRole: ["grid", "table", "treegrid"],
        requiredOwnedElements: [["row"]],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default = rowgroupRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js
  var require_rowheaderRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var rowheaderRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-sort": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "scope",
              value: "row"
            }],
            name: "th"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "scope",
              value: "rowgroup"
            }],
            name: "th"
          },
          module: "HTML"
        }],
        requireContextRole: ["row", "rowgroup"],
        requiredContextRole: ["row", "rowgroup"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
      };
      var _default = rowheaderRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js
  var require_scrollbarRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var scrollbarRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-valuetext": null,
          "aria-orientation": "vertical",
          "aria-valuemax": "100",
          "aria-valuemin": "0"
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-controls": null,
          "aria-valuenow": null
        },
        superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
      };
      var _default = scrollbarRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/searchRole.js
  var require_searchRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/searchRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var searchRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = searchRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js
  var require_searchboxRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var searchboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "list"
            }, {
              name: "type",
              value: "search"
            }],
            constraints: ["the list attribute is not set"],
            name: "input"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "input", "textbox"]]
      };
      var _default = searchboxRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/separatorRole.js
  var require_separatorRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/separatorRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var separatorRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-orientation": "horizontal",
          "aria-valuemax": "100",
          "aria-valuemin": "0",
          "aria-valuenow": null,
          "aria-valuetext": null
        },
        relatedConcepts: [{
          concept: {
            name: "hr"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default = separatorRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/sliderRole.js
  var require_sliderRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/sliderRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var sliderRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-haspopup": null,
          "aria-invalid": null,
          "aria-readonly": null,
          "aria-valuetext": null,
          "aria-orientation": "horizontal",
          "aria-valuemax": "100",
          "aria-valuemin": "0"
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "type",
              value: "range"
            }],
            name: "input"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-valuenow": null
        },
        superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
      };
      var _default = sliderRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js
  var require_spinbuttonRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var spinbuttonRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null,
          "aria-readonly": null,
          "aria-required": null,
          "aria-valuetext": null,
          "aria-valuenow": "0"
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "type",
              value: "number"
            }],
            name: "input"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
      };
      var _default = spinbuttonRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/statusRole.js
  var require_statusRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/statusRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var statusRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-atomic": "true",
          "aria-live": "polite"
        },
        relatedConcepts: [{
          concept: {
            name: "output"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = statusRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/strongRole.js
  var require_strongRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/strongRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var strongRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "strong"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = strongRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js
  var require_subscriptRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var subscriptRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "sub"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = subscriptRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js
  var require_superscriptRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var superscriptRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "sup"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = superscriptRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/switchRole.js
  var require_switchRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/switchRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var switchRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "button"
          },
          module: "ARIA"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-checked": null
        },
        superClass: [["roletype", "widget", "input", "checkbox"]]
      };
      var _default = switchRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tabRole.js
  var require_tabRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tabRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var tabRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-posinset": null,
          "aria-setsize": null,
          "aria-selected": "false"
        },
        relatedConcepts: [],
        requireContextRole: ["tablist"],
        requiredContextRole: ["tablist"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
      };
      var _default = tabRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tableRole.js
  var require_tableRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tableRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var tableRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-colcount": null,
          "aria-rowcount": null
        },
        relatedConcepts: [{
          concept: {
            name: "table"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["row"], ["row", "rowgroup"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = tableRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tablistRole.js
  var require_tablistRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tablistRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var tablistRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-level": null,
          "aria-multiselectable": null,
          "aria-orientation": "horizontal"
        },
        relatedConcepts: [{
          module: "DAISY",
          concept: {
            name: "guide"
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["tab"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite"]]
      };
      var _default = tablistRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js
  var require_tabpanelRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var tabpanelRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = tabpanelRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/termRole.js
  var require_termRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/termRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var termRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "dfn"
          },
          module: "HTML"
        }, {
          concept: {
            name: "dt"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = termRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/textboxRole.js
  var require_textboxRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/textboxRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var textboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-activedescendant": null,
          "aria-autocomplete": null,
          "aria-errormessage": null,
          "aria-haspopup": null,
          "aria-invalid": null,
          "aria-multiline": null,
          "aria-placeholder": null,
          "aria-readonly": null,
          "aria-required": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "type"
            }, {
              constraints: ["undefined"],
              name: "list"
            }],
            constraints: ["the list attribute is not set"],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "list"
            }, {
              name: "type",
              value: "email"
            }],
            constraints: ["the list attribute is not set"],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "list"
            }, {
              name: "type",
              value: "tel"
            }],
            constraints: ["the list attribute is not set"],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "list"
            }, {
              name: "type",
              value: "text"
            }],
            constraints: ["the list attribute is not set"],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "list"
            }, {
              name: "type",
              value: "url"
            }],
            constraints: ["the list attribute is not set"],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            name: "input"
          },
          module: "XForms"
        }, {
          concept: {
            name: "textarea"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "input"]]
      };
      var _default = textboxRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/timeRole.js
  var require_timeRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/timeRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var timeRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "time"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = timeRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/timerRole.js
  var require_timerRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/timerRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var timerRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "status"]]
      };
      var _default = timerRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js
  var require_toolbarRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var toolbarRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-orientation": "horizontal"
        },
        relatedConcepts: [{
          concept: {
            name: "menubar"
          },
          module: "ARIA"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "group"]]
      };
      var _default = toolbarRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js
  var require_tooltipRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var tooltipRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = tooltipRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/treeRole.js
  var require_treeRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/treeRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var treeRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null,
          "aria-multiselectable": null,
          "aria-required": null,
          "aria-orientation": "vertical"
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
      };
      var _default = treeRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/treegridRole.js
  var require_treegridRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/treegridRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var treegridRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["row"], ["row", "rowgroup"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
      };
      var _default = treegridRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js
  var require_treeitemRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var treeitemRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-expanded": null,
          "aria-haspopup": null
        },
        relatedConcepts: [],
        requireContextRole: ["group", "tree"],
        requiredContextRole: ["group", "tree"],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-selected": null
        },
        superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
      };
      var _default = treeitemRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js
  var require_ariaLiteralRoles = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _alertRole = _interopRequireDefault(require_alertRole());
      var _alertdialogRole = _interopRequireDefault(require_alertdialogRole());
      var _applicationRole = _interopRequireDefault(require_applicationRole());
      var _articleRole = _interopRequireDefault(require_articleRole());
      var _bannerRole = _interopRequireDefault(require_bannerRole());
      var _blockquoteRole = _interopRequireDefault(require_blockquoteRole());
      var _buttonRole = _interopRequireDefault(require_buttonRole());
      var _captionRole = _interopRequireDefault(require_captionRole());
      var _cellRole = _interopRequireDefault(require_cellRole());
      var _checkboxRole = _interopRequireDefault(require_checkboxRole());
      var _codeRole = _interopRequireDefault(require_codeRole());
      var _columnheaderRole = _interopRequireDefault(require_columnheaderRole());
      var _comboboxRole = _interopRequireDefault(require_comboboxRole());
      var _complementaryRole = _interopRequireDefault(require_complementaryRole());
      var _contentinfoRole = _interopRequireDefault(require_contentinfoRole());
      var _definitionRole = _interopRequireDefault(require_definitionRole());
      var _deletionRole = _interopRequireDefault(require_deletionRole());
      var _dialogRole = _interopRequireDefault(require_dialogRole());
      var _directoryRole = _interopRequireDefault(require_directoryRole());
      var _documentRole = _interopRequireDefault(require_documentRole());
      var _emphasisRole = _interopRequireDefault(require_emphasisRole());
      var _feedRole = _interopRequireDefault(require_feedRole());
      var _figureRole = _interopRequireDefault(require_figureRole());
      var _formRole = _interopRequireDefault(require_formRole());
      var _genericRole = _interopRequireDefault(require_genericRole());
      var _gridRole = _interopRequireDefault(require_gridRole());
      var _gridcellRole = _interopRequireDefault(require_gridcellRole());
      var _groupRole = _interopRequireDefault(require_groupRole());
      var _headingRole = _interopRequireDefault(require_headingRole());
      var _imgRole = _interopRequireDefault(require_imgRole());
      var _insertionRole = _interopRequireDefault(require_insertionRole());
      var _linkRole = _interopRequireDefault(require_linkRole());
      var _listRole = _interopRequireDefault(require_listRole());
      var _listboxRole = _interopRequireDefault(require_listboxRole());
      var _listitemRole = _interopRequireDefault(require_listitemRole());
      var _logRole = _interopRequireDefault(require_logRole());
      var _mainRole = _interopRequireDefault(require_mainRole());
      var _markRole = _interopRequireDefault(require_markRole());
      var _marqueeRole = _interopRequireDefault(require_marqueeRole());
      var _mathRole = _interopRequireDefault(require_mathRole());
      var _menuRole = _interopRequireDefault(require_menuRole());
      var _menubarRole = _interopRequireDefault(require_menubarRole());
      var _menuitemRole = _interopRequireDefault(require_menuitemRole());
      var _menuitemcheckboxRole = _interopRequireDefault(require_menuitemcheckboxRole());
      var _menuitemradioRole = _interopRequireDefault(require_menuitemradioRole());
      var _meterRole = _interopRequireDefault(require_meterRole());
      var _navigationRole = _interopRequireDefault(require_navigationRole());
      var _noneRole = _interopRequireDefault(require_noneRole());
      var _noteRole = _interopRequireDefault(require_noteRole());
      var _optionRole = _interopRequireDefault(require_optionRole());
      var _paragraphRole = _interopRequireDefault(require_paragraphRole());
      var _presentationRole = _interopRequireDefault(require_presentationRole());
      var _progressbarRole = _interopRequireDefault(require_progressbarRole());
      var _radioRole = _interopRequireDefault(require_radioRole());
      var _radiogroupRole = _interopRequireDefault(require_radiogroupRole());
      var _regionRole = _interopRequireDefault(require_regionRole());
      var _rowRole = _interopRequireDefault(require_rowRole());
      var _rowgroupRole = _interopRequireDefault(require_rowgroupRole());
      var _rowheaderRole = _interopRequireDefault(require_rowheaderRole());
      var _scrollbarRole = _interopRequireDefault(require_scrollbarRole());
      var _searchRole = _interopRequireDefault(require_searchRole());
      var _searchboxRole = _interopRequireDefault(require_searchboxRole());
      var _separatorRole = _interopRequireDefault(require_separatorRole());
      var _sliderRole = _interopRequireDefault(require_sliderRole());
      var _spinbuttonRole = _interopRequireDefault(require_spinbuttonRole());
      var _statusRole = _interopRequireDefault(require_statusRole());
      var _strongRole = _interopRequireDefault(require_strongRole());
      var _subscriptRole = _interopRequireDefault(require_subscriptRole());
      var _superscriptRole = _interopRequireDefault(require_superscriptRole());
      var _switchRole = _interopRequireDefault(require_switchRole());
      var _tabRole = _interopRequireDefault(require_tabRole());
      var _tableRole = _interopRequireDefault(require_tableRole());
      var _tablistRole = _interopRequireDefault(require_tablistRole());
      var _tabpanelRole = _interopRequireDefault(require_tabpanelRole());
      var _termRole = _interopRequireDefault(require_termRole());
      var _textboxRole = _interopRequireDefault(require_textboxRole());
      var _timeRole = _interopRequireDefault(require_timeRole());
      var _timerRole = _interopRequireDefault(require_timerRole());
      var _toolbarRole = _interopRequireDefault(require_toolbarRole());
      var _tooltipRole = _interopRequireDefault(require_tooltipRole());
      var _treeRole = _interopRequireDefault(require_treeRole());
      var _treegridRole = _interopRequireDefault(require_treegridRole());
      var _treeitemRole = _interopRequireDefault(require_treeitemRole());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ariaLiteralRoles = [["alert", _alertRole.default], ["alertdialog", _alertdialogRole.default], ["application", _applicationRole.default], ["article", _articleRole.default], ["banner", _bannerRole.default], ["blockquote", _blockquoteRole.default], ["button", _buttonRole.default], ["caption", _captionRole.default], ["cell", _cellRole.default], ["checkbox", _checkboxRole.default], ["code", _codeRole.default], ["columnheader", _columnheaderRole.default], ["combobox", _comboboxRole.default], ["complementary", _complementaryRole.default], ["contentinfo", _contentinfoRole.default], ["definition", _definitionRole.default], ["deletion", _deletionRole.default], ["dialog", _dialogRole.default], ["directory", _directoryRole.default], ["document", _documentRole.default], ["emphasis", _emphasisRole.default], ["feed", _feedRole.default], ["figure", _figureRole.default], ["form", _formRole.default], ["generic", _genericRole.default], ["grid", _gridRole.default], ["gridcell", _gridcellRole.default], ["group", _groupRole.default], ["heading", _headingRole.default], ["img", _imgRole.default], ["insertion", _insertionRole.default], ["link", _linkRole.default], ["list", _listRole.default], ["listbox", _listboxRole.default], ["listitem", _listitemRole.default], ["log", _logRole.default], ["main", _mainRole.default], ["mark", _markRole.default], ["marquee", _marqueeRole.default], ["math", _mathRole.default], ["menu", _menuRole.default], ["menubar", _menubarRole.default], ["menuitem", _menuitemRole.default], ["menuitemcheckbox", _menuitemcheckboxRole.default], ["menuitemradio", _menuitemradioRole.default], ["meter", _meterRole.default], ["navigation", _navigationRole.default], ["none", _noneRole.default], ["note", _noteRole.default], ["option", _optionRole.default], ["paragraph", _paragraphRole.default], ["presentation", _presentationRole.default], ["progressbar", _progressbarRole.default], ["radio", _radioRole.default], ["radiogroup", _radiogroupRole.default], ["region", _regionRole.default], ["row", _rowRole.default], ["rowgroup", _rowgroupRole.default], ["rowheader", _rowheaderRole.default], ["scrollbar", _scrollbarRole.default], ["search", _searchRole.default], ["searchbox", _searchboxRole.default], ["separator", _separatorRole.default], ["slider", _sliderRole.default], ["spinbutton", _spinbuttonRole.default], ["status", _statusRole.default], ["strong", _strongRole.default], ["subscript", _subscriptRole.default], ["superscript", _superscriptRole.default], ["switch", _switchRole.default], ["tab", _tabRole.default], ["table", _tableRole.default], ["tablist", _tablistRole.default], ["tabpanel", _tabpanelRole.default], ["term", _termRole.default], ["textbox", _textboxRole.default], ["time", _timeRole.default], ["timer", _timerRole.default], ["toolbar", _toolbarRole.default], ["tooltip", _tooltipRole.default], ["tree", _treeRole.default], ["treegrid", _treegridRole.default], ["treeitem", _treeitemRole.default]];
      var _default = ariaLiteralRoles;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js
  var require_docAbstractRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docAbstractRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "abstract [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = docAbstractRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js
  var require_docAcknowledgmentsRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docAcknowledgmentsRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "acknowledgments [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docAcknowledgmentsRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js
  var require_docAfterwordRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docAfterwordRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "afterword [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docAfterwordRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js
  var require_docAppendixRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docAppendixRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "appendix [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docAppendixRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js
  var require_docBacklinkRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docBacklinkRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "referrer [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command", "link"]]
      };
      var _default = docBacklinkRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js
  var require_docBiblioentryRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docBiblioentryRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "EPUB biblioentry [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: ["doc-bibliography"],
        requiredContextRole: ["doc-bibliography"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "listitem"]]
      };
      var _default = docBiblioentryRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js
  var require_docBibliographyRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docBibliographyRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "bibliography [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["doc-biblioentry"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docBibliographyRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js
  var require_docBibliorefRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docBibliorefRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "biblioref [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command", "link"]]
      };
      var _default = docBibliorefRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js
  var require_docChapterRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docChapterRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "chapter [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docChapterRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js
  var require_docColophonRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docColophonRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "colophon [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = docColophonRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js
  var require_docConclusionRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docConclusionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "conclusion [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docConclusionRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js
  var require_docCoverRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docCoverRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "cover [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "img"]]
      };
      var _default = docCoverRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js
  var require_docCreditRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docCreditRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "credit [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = docCreditRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js
  var require_docCreditsRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docCreditsRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "credits [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docCreditsRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js
  var require_docDedicationRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docDedicationRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "dedication [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = docDedicationRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js
  var require_docEndnoteRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docEndnoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "rearnote [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: ["doc-endnotes"],
        requiredContextRole: ["doc-endnotes"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "listitem"]]
      };
      var _default = docEndnoteRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js
  var require_docEndnotesRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docEndnotesRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "rearnotes [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["doc-endnote"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docEndnotesRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js
  var require_docEpigraphRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docEpigraphRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "epigraph [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = docEpigraphRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js
  var require_docEpilogueRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docEpilogueRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "epilogue [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docEpilogueRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js
  var require_docErrataRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docErrataRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "errata [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docErrataRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js
  var require_docExampleRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docExampleRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = docExampleRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js
  var require_docFootnoteRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docFootnoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "footnote [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = docFootnoteRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js
  var require_docForewordRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docForewordRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "foreword [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docForewordRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js
  var require_docGlossaryRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docGlossaryRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "glossary [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["definition"], ["term"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docGlossaryRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js
  var require_docGlossrefRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docGlossrefRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "glossref [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command", "link"]]
      };
      var _default = docGlossrefRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js
  var require_docIndexRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docIndexRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "index [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
      };
      var _default = docIndexRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js
  var require_docIntroductionRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docIntroductionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "introduction [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docIntroductionRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js
  var require_docNoterefRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docNoterefRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "noteref [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command", "link"]]
      };
      var _default = docNoterefRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js
  var require_docNoticeRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docNoticeRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "notice [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "note"]]
      };
      var _default = docNoticeRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js
  var require_docPagebreakRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docPagebreakRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "pagebreak [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "separator"]]
      };
      var _default = docPagebreakRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js
  var require_docPagelistRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docPagelistRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "page-list [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
      };
      var _default = docPagelistRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js
  var require_docPartRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docPartRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "part [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docPartRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js
  var require_docPrefaceRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docPrefaceRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "preface [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docPrefaceRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js
  var require_docPrologueRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docPrologueRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "prologue [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default = docPrologueRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js
  var require_docPullquoteRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docPullquoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "pullquote [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["none"]]
      };
      var _default = docPullquoteRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js
  var require_docQnaRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docQnaRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "qna [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default = docQnaRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js
  var require_docSubtitleRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docSubtitleRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "subtitle [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "sectionhead"]]
      };
      var _default = docSubtitleRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js
  var require_docTipRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docTipRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "help [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "note"]]
      };
      var _default = docTipRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js
  var require_docTocRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var docTocRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "toc [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
      };
      var _default = docTocRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js
  var require_ariaDpubRoles = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _docAbstractRole = _interopRequireDefault(require_docAbstractRole());
      var _docAcknowledgmentsRole = _interopRequireDefault(require_docAcknowledgmentsRole());
      var _docAfterwordRole = _interopRequireDefault(require_docAfterwordRole());
      var _docAppendixRole = _interopRequireDefault(require_docAppendixRole());
      var _docBacklinkRole = _interopRequireDefault(require_docBacklinkRole());
      var _docBiblioentryRole = _interopRequireDefault(require_docBiblioentryRole());
      var _docBibliographyRole = _interopRequireDefault(require_docBibliographyRole());
      var _docBibliorefRole = _interopRequireDefault(require_docBibliorefRole());
      var _docChapterRole = _interopRequireDefault(require_docChapterRole());
      var _docColophonRole = _interopRequireDefault(require_docColophonRole());
      var _docConclusionRole = _interopRequireDefault(require_docConclusionRole());
      var _docCoverRole = _interopRequireDefault(require_docCoverRole());
      var _docCreditRole = _interopRequireDefault(require_docCreditRole());
      var _docCreditsRole = _interopRequireDefault(require_docCreditsRole());
      var _docDedicationRole = _interopRequireDefault(require_docDedicationRole());
      var _docEndnoteRole = _interopRequireDefault(require_docEndnoteRole());
      var _docEndnotesRole = _interopRequireDefault(require_docEndnotesRole());
      var _docEpigraphRole = _interopRequireDefault(require_docEpigraphRole());
      var _docEpilogueRole = _interopRequireDefault(require_docEpilogueRole());
      var _docErrataRole = _interopRequireDefault(require_docErrataRole());
      var _docExampleRole = _interopRequireDefault(require_docExampleRole());
      var _docFootnoteRole = _interopRequireDefault(require_docFootnoteRole());
      var _docForewordRole = _interopRequireDefault(require_docForewordRole());
      var _docGlossaryRole = _interopRequireDefault(require_docGlossaryRole());
      var _docGlossrefRole = _interopRequireDefault(require_docGlossrefRole());
      var _docIndexRole = _interopRequireDefault(require_docIndexRole());
      var _docIntroductionRole = _interopRequireDefault(require_docIntroductionRole());
      var _docNoterefRole = _interopRequireDefault(require_docNoterefRole());
      var _docNoticeRole = _interopRequireDefault(require_docNoticeRole());
      var _docPagebreakRole = _interopRequireDefault(require_docPagebreakRole());
      var _docPagelistRole = _interopRequireDefault(require_docPagelistRole());
      var _docPartRole = _interopRequireDefault(require_docPartRole());
      var _docPrefaceRole = _interopRequireDefault(require_docPrefaceRole());
      var _docPrologueRole = _interopRequireDefault(require_docPrologueRole());
      var _docPullquoteRole = _interopRequireDefault(require_docPullquoteRole());
      var _docQnaRole = _interopRequireDefault(require_docQnaRole());
      var _docSubtitleRole = _interopRequireDefault(require_docSubtitleRole());
      var _docTipRole = _interopRequireDefault(require_docTipRole());
      var _docTocRole = _interopRequireDefault(require_docTocRole());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ariaDpubRoles = [["doc-abstract", _docAbstractRole.default], ["doc-acknowledgments", _docAcknowledgmentsRole.default], ["doc-afterword", _docAfterwordRole.default], ["doc-appendix", _docAppendixRole.default], ["doc-backlink", _docBacklinkRole.default], ["doc-biblioentry", _docBiblioentryRole.default], ["doc-bibliography", _docBibliographyRole.default], ["doc-biblioref", _docBibliorefRole.default], ["doc-chapter", _docChapterRole.default], ["doc-colophon", _docColophonRole.default], ["doc-conclusion", _docConclusionRole.default], ["doc-cover", _docCoverRole.default], ["doc-credit", _docCreditRole.default], ["doc-credits", _docCreditsRole.default], ["doc-dedication", _docDedicationRole.default], ["doc-endnote", _docEndnoteRole.default], ["doc-endnotes", _docEndnotesRole.default], ["doc-epigraph", _docEpigraphRole.default], ["doc-epilogue", _docEpilogueRole.default], ["doc-errata", _docErrataRole.default], ["doc-example", _docExampleRole.default], ["doc-footnote", _docFootnoteRole.default], ["doc-foreword", _docForewordRole.default], ["doc-glossary", _docGlossaryRole.default], ["doc-glossref", _docGlossrefRole.default], ["doc-index", _docIndexRole.default], ["doc-introduction", _docIntroductionRole.default], ["doc-noteref", _docNoterefRole.default], ["doc-notice", _docNoticeRole.default], ["doc-pagebreak", _docPagebreakRole.default], ["doc-pagelist", _docPagelistRole.default], ["doc-part", _docPartRole.default], ["doc-preface", _docPrefaceRole.default], ["doc-prologue", _docPrologueRole.default], ["doc-pullquote", _docPullquoteRole.default], ["doc-qna", _docQnaRole.default], ["doc-subtitle", _docSubtitleRole.default], ["doc-tip", _docTipRole.default], ["doc-toc", _docTocRole.default]];
      var _default = ariaDpubRoles;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js
  var require_graphicsDocumentRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var graphicsDocumentRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          module: "GRAPHICS",
          concept: {
            name: "graphics-object"
          }
        }, {
          module: "ARIA",
          concept: {
            name: "img"
          }
        }, {
          module: "ARIA",
          concept: {
            name: "article"
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "document"]]
      };
      var _default = graphicsDocumentRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js
  var require_graphicsObjectRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var graphicsObjectRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          module: "GRAPHICS",
          concept: {
            name: "graphics-document"
          }
        }, {
          module: "ARIA",
          concept: {
            name: "group"
          }
        }, {
          module: "ARIA",
          concept: {
            name: "img"
          }
        }, {
          module: "GRAPHICS",
          concept: {
            name: "graphics-symbol"
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "group"]]
      };
      var _default = graphicsObjectRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js
  var require_graphicsSymbolRole = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var graphicsSymbolRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "img"]]
      };
      var _default = graphicsSymbolRole;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js
  var require_ariaGraphicsRoles = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _graphicsDocumentRole = _interopRequireDefault(require_graphicsDocumentRole());
      var _graphicsObjectRole = _interopRequireDefault(require_graphicsObjectRole());
      var _graphicsSymbolRole = _interopRequireDefault(require_graphicsSymbolRole());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ariaGraphicsRoles = [["graphics-document", _graphicsDocumentRole.default], ["graphics-object", _graphicsObjectRole.default], ["graphics-symbol", _graphicsSymbolRole.default]];
      var _default = ariaGraphicsRoles;
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/rolesMap.js
  var require_rolesMap = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/rolesMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _ariaAbstractRoles = _interopRequireDefault(require_ariaAbstractRoles());
      var _ariaLiteralRoles = _interopRequireDefault(require_ariaLiteralRoles());
      var _ariaDpubRoles = _interopRequireDefault(require_ariaDpubRoles());
      var _ariaGraphicsRoles = _interopRequireDefault(require_ariaGraphicsRoles());
      var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _defineProperty3(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it2) {
          if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it2) o = it2;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e2) {
              throw _e2;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it2 = it2.call(o);
        }, n: function n() {
          var step = it2.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e3) {
          didErr = true;
          err = _e3;
        }, f: function f() {
          try {
            if (!normalCompletion && it2.return != null) it2.return();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _iterableToArrayLimit(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }
      var roles2 = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
      roles2.forEach(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1];
        var _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var superClassIter = _step.value;
            var _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
            try {
              var _loop = function _loop2() {
                var superClassName = _step2.value;
                var superClassRoleTuple = roles2.find(function(_ref3) {
                  var _ref4 = _slicedToArray(_ref3, 1), name = _ref4[0];
                  return name === superClassName;
                });
                if (superClassRoleTuple) {
                  var superClassDefinition = superClassRoleTuple[1];
                  for (var _i2 = 0, _Object$keys = Object.keys(superClassDefinition.props); _i2 < _Object$keys.length; _i2++) {
                    var prop = _Object$keys[_i2];
                    if (
                      // $FlowIssue Accessing the hasOwnProperty on the Object prototype is fine.
                      !Object.prototype.hasOwnProperty.call(roleDefinition.props, prop)
                    ) {
                      Object.assign(roleDefinition.props, _defineProperty3({}, prop, superClassDefinition.props[prop]));
                    }
                  }
                }
              };
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                _loop();
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
      var rolesMap = {
        entries: function entries() {
          return roles2;
        },
        forEach: function forEach(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var _iterator3 = _createForOfIteratorHelper(roles2), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var _step3$value = _slicedToArray(_step3.value, 2), key = _step3$value[0], values = _step3$value[1];
              fn.call(thisArg, values, key, roles2);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        },
        get: function get2(key) {
          var item = roles2.find(function(tuple) {
            return tuple[0] === key ? true : false;
          });
          return item && item[1];
        },
        has: function has(key) {
          return !!rolesMap.get(key);
        },
        keys: function keys() {
          return roles2.map(function(_ref5) {
            var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
            return key;
          });
        },
        values: function values() {
          return roles2.map(function(_ref7) {
            var _ref8 = _slicedToArray(_ref7, 2), values2 = _ref8[1];
            return values2;
          });
        }
      };
      var _default = (0, _iterationDecorator.default)(rolesMap, rolesMap.entries());
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/lite/index.js
  var require_lite = __commonJS({
    "node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/lite/index.js"(exports) {
      var has = Object.prototype.hasOwnProperty;
      function dequal(foo, bar) {
        var ctor, len;
        if (foo === bar) return true;
        if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
          if (ctor === Date) return foo.getTime() === bar.getTime();
          if (ctor === RegExp) return foo.toString() === bar.toString();
          if (ctor === Array) {
            if ((len = foo.length) === bar.length) {
              while (len-- && dequal(foo[len], bar[len])) ;
            }
            return len === -1;
          }
          if (!ctor || typeof foo === "object") {
            len = 0;
            for (ctor in foo) {
              if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
              if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
            }
            return Object.keys(bar).length === len;
          }
        }
        return foo !== foo && bar !== bar;
      }
      exports.dequal = dequal;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/elementRoleMap.js
  var require_elementRoleMap = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/elementRoleMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _lite = require_lite();
      var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
      var _rolesMap = _interopRequireDefault(require_rolesMap());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _slicedToArray(arr, i2) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _iterableToArrayLimit(arr, i2) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it2) {
          if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it2) o = it2;
            var i2 = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i2 >= o.length) return { done: true };
              return { done: false, value: o[i2++] };
            }, e: function e(_e2) {
              throw _e2;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it2 = it2.call(o);
        }, n: function n() {
          var step = it2.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e3) {
          didErr = true;
          err = _e3;
        }, f: function f() {
          try {
            if (!normalCompletion && it2.return != null) it2.return();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
      var elementRoles2 = [];
      var keys = _rolesMap.default.keys();
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        role = _rolesMap.default.get(key);
        if (role) {
          concepts = [].concat(role.baseConcepts, role.relatedConcepts);
          for (k = 0; k < concepts.length; k++) {
            relation = concepts[k];
            if (relation.module === "HTML") {
              (function() {
                var concept = relation.concept;
                if (concept) {
                  var elementRoleRelation = elementRoles2.find(function(relation2) {
                    return (0, _lite.dequal)(relation2, concept);
                  });
                  var roles2;
                  if (elementRoleRelation) {
                    roles2 = elementRoleRelation[1];
                  } else {
                    roles2 = [];
                  }
                  var isUnique = true;
                  for (var _i = 0; _i < roles2.length; _i++) {
                    if (roles2[_i] === key) {
                      isUnique = false;
                      break;
                    }
                  }
                  if (isUnique) {
                    roles2.push(key);
                  }
                  elementRoles2.push([concept, roles2]);
                }
              })();
            }
          }
        }
      }
      var key;
      var role;
      var concepts;
      var relation;
      var k;
      var i;
      var elementRoleMap = {
        entries: function entries() {
          return elementRoles2;
        },
        forEach: function forEach(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var _iterator = _createForOfIteratorHelper(elementRoles2), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _step$value = _slicedToArray(_step.value, 2), _key = _step$value[0], values = _step$value[1];
              fn.call(thisArg, values, _key, elementRoles2);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        },
        get: function get2(key2) {
          var item = elementRoles2.find(function(tuple) {
            return key2.name === tuple[0].name && (0, _lite.dequal)(key2.attributes, tuple[0].attributes);
          });
          return item && item[1];
        },
        has: function has(key2) {
          return !!elementRoleMap.get(key2);
        },
        keys: function keys2() {
          return elementRoles2.map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
            return key2;
          });
        },
        values: function values() {
          return elementRoles2.map(function(_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
            return values2;
          });
        }
      };
      var _default = (0, _iterationDecorator.default)(elementRoleMap, elementRoleMap.entries());
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/roleElementMap.js
  var require_roleElementMap = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/roleElementMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
      var _rolesMap = _interopRequireDefault(require_rolesMap());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _slicedToArray(arr, i2) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _iterableToArrayLimit(arr, i2) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it2) {
          if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it2) o = it2;
            var i2 = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i2 >= o.length) return { done: true };
              return { done: false, value: o[i2++] };
            }, e: function e(_e2) {
              throw _e2;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it2 = it2.call(o);
        }, n: function n() {
          var step = it2.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e3) {
          didErr = true;
          err = _e3;
        }, f: function f() {
          try {
            if (!normalCompletion && it2.return != null) it2.return();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
      var roleElement = [];
      var keys = _rolesMap.default.keys();
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        role = _rolesMap.default.get(key);
        relationConcepts = [];
        if (role) {
          concepts = [].concat(role.baseConcepts, role.relatedConcepts);
          for (k = 0; k < concepts.length; k++) {
            relation = concepts[k];
            if (relation.module === "HTML") {
              concept = relation.concept;
              if (concept != null) {
                relationConcepts.push(concept);
              }
            }
          }
          if (relationConcepts.length > 0) {
            roleElement.push([key, relationConcepts]);
          }
        }
      }
      var key;
      var role;
      var relationConcepts;
      var concepts;
      var relation;
      var concept;
      var k;
      var i;
      var roleElementMap = {
        entries: function entries() {
          return roleElement;
        },
        forEach: function forEach(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var _iterator = _createForOfIteratorHelper(roleElement), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _step$value = _slicedToArray(_step.value, 2), _key = _step$value[0], values = _step$value[1];
              fn.call(thisArg, values, _key, roleElement);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        },
        get: function get2(key2) {
          var item = roleElement.find(function(tuple) {
            return tuple[0] === key2 ? true : false;
          });
          return item && item[1];
        },
        has: function has(key2) {
          return !!roleElementMap.get(key2);
        },
        keys: function keys2() {
          return roleElement.map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
            return key2;
          });
        },
        values: function values() {
          return roleElement.map(function(_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
            return values2;
          });
        }
      };
      var _default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
      exports.default = _default;
    }
  });

  // node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/index.js
  var require_lib = __commonJS({
    "node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.roles = exports.roleElements = exports.elementRoles = exports.dom = exports.aria = void 0;
      var _ariaPropsMap = _interopRequireDefault(require_ariaPropsMap());
      var _domMap = _interopRequireDefault(require_domMap());
      var _rolesMap = _interopRequireDefault(require_rolesMap());
      var _elementRoleMap = _interopRequireDefault(require_elementRoleMap());
      var _roleElementMap = _interopRequireDefault(require_roleElementMap());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var aria = _ariaPropsMap.default;
      exports.aria = aria;
      var dom = _domMap.default;
      exports.dom = dom;
      var roles2 = _rolesMap.default;
      exports.roles = roles2;
      var elementRoles2 = _elementRoleMap.default;
      exports.elementRoles = elementRoles2;
      var roleElements2 = _roleElementMap.default;
      exports.roleElements = roleElements2;
    }
  });

  // node_modules/.pnpm/lz-string@1.5.0/node_modules/lz-string/libs/lz-string.js
  var require_lz_string = __commonJS({
    "node_modules/.pnpm/lz-string@1.5.0/node_modules/lz-string/libs/lz-string.js"(exports, module2) {
      var LZString = (function() {
        var f = String.fromCharCode;
        var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
        var baseReverseDic = {};
        function getBaseValue(alphabet, character) {
          if (!baseReverseDic[alphabet]) {
            baseReverseDic[alphabet] = {};
            for (var i = 0; i < alphabet.length; i++) {
              baseReverseDic[alphabet][alphabet.charAt(i)] = i;
            }
          }
          return baseReverseDic[alphabet][character];
        }
        var LZString2 = {
          compressToBase64: function(input) {
            if (input == null) return "";
            var res = LZString2._compress(input, 6, function(a) {
              return keyStrBase64.charAt(a);
            });
            switch (res.length % 4) {
              // To produce valid Base64
              default:
              // When could this happen ?
              case 0:
                return res;
              case 1:
                return res + "===";
              case 2:
                return res + "==";
              case 3:
                return res + "=";
            }
          },
          decompressFromBase64: function(input) {
            if (input == null) return "";
            if (input == "") return null;
            return LZString2._decompress(input.length, 32, function(index) {
              return getBaseValue(keyStrBase64, input.charAt(index));
            });
          },
          compressToUTF16: function(input) {
            if (input == null) return "";
            return LZString2._compress(input, 15, function(a) {
              return f(a + 32);
            }) + " ";
          },
          decompressFromUTF16: function(compressed) {
            if (compressed == null) return "";
            if (compressed == "") return null;
            return LZString2._decompress(compressed.length, 16384, function(index) {
              return compressed.charCodeAt(index) - 32;
            });
          },
          //compress into uint8array (UCS-2 big endian format)
          compressToUint8Array: function(uncompressed) {
            var compressed = LZString2.compress(uncompressed);
            var buf = new Uint8Array(compressed.length * 2);
            for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
              var current_value = compressed.charCodeAt(i);
              buf[i * 2] = current_value >>> 8;
              buf[i * 2 + 1] = current_value % 256;
            }
            return buf;
          },
          //decompress from uint8array (UCS-2 big endian format)
          decompressFromUint8Array: function(compressed) {
            if (compressed === null || compressed === void 0) {
              return LZString2.decompress(compressed);
            } else {
              var buf = new Array(compressed.length / 2);
              for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
                buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
              }
              var result = [];
              buf.forEach(function(c) {
                result.push(f(c));
              });
              return LZString2.decompress(result.join(""));
            }
          },
          //compress into a string that is already URI encoded
          compressToEncodedURIComponent: function(input) {
            if (input == null) return "";
            return LZString2._compress(input, 6, function(a) {
              return keyStrUriSafe.charAt(a);
            });
          },
          //decompress from an output of compressToEncodedURIComponent
          decompressFromEncodedURIComponent: function(input) {
            if (input == null) return "";
            if (input == "") return null;
            input = input.replace(/ /g, "+");
            return LZString2._decompress(input.length, 32, function(index) {
              return getBaseValue(keyStrUriSafe, input.charAt(index));
            });
          },
          compress: function(uncompressed) {
            return LZString2._compress(uncompressed, 16, function(a) {
              return f(a);
            });
          },
          _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
            if (uncompressed == null) return "";
            var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
            for (ii = 0; ii < uncompressed.length; ii += 1) {
              context_c = uncompressed.charAt(ii);
              if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
                context_dictionary[context_c] = context_dictSize++;
                context_dictionaryToCreate[context_c] = true;
              }
              context_wc = context_w + context_c;
              if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
                context_w = context_wc;
              } else {
                if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                  if (context_w.charCodeAt(0) < 256) {
                    for (i = 0; i < context_numBits; i++) {
                      context_data_val = context_data_val << 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                    }
                    value = context_w.charCodeAt(0);
                    for (i = 0; i < 8; i++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  } else {
                    value = 1;
                    for (i = 0; i < context_numBits; i++) {
                      context_data_val = context_data_val << 1 | value;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = 0;
                    }
                    value = context_w.charCodeAt(0);
                    for (i = 0; i < 16; i++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  }
                  context_enlargeIn--;
                  if (context_enlargeIn == 0) {
                    context_enlargeIn = Math.pow(2, context_numBits);
                    context_numBits++;
                  }
                  delete context_dictionaryToCreate[context_w];
                } else {
                  value = context_dictionary[context_w];
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                context_dictionary[context_wc] = context_dictSize++;
                context_w = String(context_c);
              }
            }
            if (context_w !== "") {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 8; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                } else {
                  value = 1;
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = 0;
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 16; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value = context_dictionary[context_w];
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
            }
            value = 2;
            for (i = 0; i < context_numBits; i++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
            while (true) {
              context_data_val = context_data_val << 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data.push(getCharFromInt(context_data_val));
                break;
              } else context_data_position++;
            }
            return context_data.join("");
          },
          decompress: function(compressed) {
            if (compressed == null) return "";
            if (compressed == "") return null;
            return LZString2._decompress(compressed.length, 32768, function(index) {
              return compressed.charCodeAt(index);
            });
          },
          _decompress: function(length, resetValue, getNextValue) {
            var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i, w, bits, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };
            for (i = 0; i < 3; i += 1) {
              dictionary[i] = i;
            }
            bits = 0;
            maxpower = Math.pow(2, 2);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (next = bits) {
              case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                c = f(bits);
                break;
              case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                c = f(bits);
                break;
              case 2:
                return "";
            }
            dictionary[3] = c;
            w = c;
            result.push(c);
            while (true) {
              if (data.index > length) {
                return "";
              }
              bits = 0;
              maxpower = Math.pow(2, numBits);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              switch (c = bits) {
                case 0:
                  bits = 0;
                  maxpower = Math.pow(2, 8);
                  power = 1;
                  while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                      data.position = resetValue;
                      data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  dictionary[dictSize++] = f(bits);
                  c = dictSize - 1;
                  enlargeIn--;
                  break;
                case 1:
                  bits = 0;
                  maxpower = Math.pow(2, 16);
                  power = 1;
                  while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                      data.position = resetValue;
                      data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  dictionary[dictSize++] = f(bits);
                  c = dictSize - 1;
                  enlargeIn--;
                  break;
                case 2:
                  return result.join("");
              }
              if (enlargeIn == 0) {
                enlargeIn = Math.pow(2, numBits);
                numBits++;
              }
              if (dictionary[c]) {
                entry = dictionary[c];
              } else {
                if (c === dictSize) {
                  entry = w + w.charAt(0);
                } else {
                  return null;
                }
              }
              result.push(entry);
              dictionary[dictSize++] = w + entry.charAt(0);
              enlargeIn--;
              w = entry;
              if (enlargeIn == 0) {
                enlargeIn = Math.pow(2, numBits);
                numBits++;
              }
            }
          }
        };
        return LZString2;
      })();
      if (typeof define === "function" && define.amd) {
        define(function() {
          return LZString;
        });
      } else if (typeof module2 !== "undefined" && module2 != null) {
        module2.exports = LZString;
      } else if (typeof angular !== "undefined" && angular != null) {
        angular.module("LZString", []).factory("LZString", function() {
          return LZString;
        });
      }
    }
  });

  // src/utils/flatten.ts
  function flatten(obj, ignore = []) {
    const stack = [{
      path: [],
      obj
    }];
    const result = [];
    const visited = /* @__PURE__ */ new WeakSet();
    while (stack.length > 0) {
      const { path, obj: obj2 } = stack.pop();
      if (visited.has(obj2)) continue;
      visited.add(obj2);
      for (const key in obj2) {
        if (ignore.includes(key)) continue;
        const value = obj2[key];
        const newPath = path.concat(key);
        if (typeof value === "object" && value !== null && !visited.has(value)) {
          stack.push({
            path: newPath,
            obj: value
          });
        }
        result.push({ path: newPath, value });
      }
    }
    return result;
  }
  var init_flatten = __esm({
    "src/utils/flatten.ts"() {
      "use strict";
    }
  });

  // src/vision.ts
  function isVisible(element) {
    if (element.hasAttribute("hidden")) return false;
    if (element.style.display === "none") return false;
    if (element.style.visibility === "hidden") return false;
    if (element.getAttribute("aria-hidden") === "true") return false;
    return true;
  }
  function getSemanticDOM(element) {
    if (!(element instanceof HTMLElement)) return null;
    const tagName = element.tagName.toLowerCase();
    if (IGNORED_TAGS.has(tagName)) return null;
    if (!isVisible(element)) return null;
    const node = { tagName };
    const attributes = {};
    let hasAttrs = false;
    for (const attr of Array.from(element.attributes)) {
      const name = attr.name;
      if (IMPORTANT_ATTRS.has(name) || name.startsWith("aria-") || name.startsWith("data-")) {
        if (name === "checked" || name === "disabled") {
          attributes[name] = element[name];
        } else if (name === "value" && (tagName === "input" || tagName === "textarea" || tagName === "select")) {
          attributes[name] = element.value;
        } else {
          attributes[name] = attr.value;
        }
        hasAttrs = true;
      }
    }
    if (hasAttrs) node.attributes = attributes;
    let text = "";
    for (const child of Array.from(element.childNodes)) {
      if (child.nodeType === Node.TEXT_NODE) {
        const val = child.nodeValue?.trim();
        if (val) text += val + " ";
      }
    }
    text = text.trim();
    if (text) node.text = text;
    const children = [];
    for (const child of Array.from(element.children)) {
      const semanticChild = getSemanticDOM(child);
      if (semanticChild) {
        children.push(semanticChild);
      }
    }
    if (children.length > 0) node.children = children;
    if (tagName === "div" && !hasAttrs && !text && children.length === 0) return null;
    return node;
  }
  var IGNORED_TAGS, IMPORTANT_ATTRS;
  var init_vision = __esm({
    "src/vision.ts"() {
      "use strict";
      IGNORED_TAGS = /* @__PURE__ */ new Set([
        "script",
        "style",
        "noscript",
        "template",
        "link",
        "meta",
        "head",
        "title"
      ]);
      IMPORTANT_ATTRS = /* @__PURE__ */ new Set([
        "id",
        "class",
        "type",
        "value",
        "checked",
        "disabled",
        "placeholder",
        "href",
        "src",
        "alt",
        "title",
        "role"
      ]);
    }
  });

  // src/patch.ts
  function applyPatch(state, patch) {
    const undoStack = [];
    try {
      for (const op of patch) {
        const inverse = applyOp(state, op);
        if (inverse) undoStack.push(inverse);
      }
      return { success: true };
    } catch (e) {
      for (let i = undoStack.length - 1; i >= 0; i--) {
        try {
          applyOp(state, undoStack[i]);
        } catch (rollbackError) {
          console.error("Critical: Rollback failed", rollbackError);
        }
      }
      return { success: false, error: e.message || String(e) };
    }
  }
  function deepEqual2(a, b) {
    if (a === b) return true;
    if (typeof a !== "object" || a === null || typeof b !== "object" || b === null) return false;
    if (Array.isArray(a) !== Array.isArray(b)) return false;
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length) return false;
    for (const key of keysA) {
      if (!keysB.includes(key) || !deepEqual2(a[key], b[key])) return false;
    }
    return true;
  }
  function parsePath2(path) {
    if (path === "") return [];
    if (path === "/") return [""];
    return path.split("/").slice(1).map(
      (segment) => segment.replace(/~1/g, "/").replace(/~0/g, "~")
    );
  }
  function applyOp(root, op) {
    const parts = parsePath2(op.path);
    if (parts.length === 0) {
      throw new Error("Cannot operate on root state directly");
    }
    const key = parts.pop();
    let target = root;
    for (const segment of parts) {
      if (target === void 0 || target === null) {
        throw new Error(`Path not found: ${op.path}`);
      }
      if (Array.isArray(target)) {
        const index = parseInt(segment, 10);
        if (isNaN(index)) throw new Error(`Invalid array index: ${segment}`);
        target = target[index];
      } else {
        target = target[segment];
      }
    }
    if (target === void 0 || target === null) {
      throw new Error(`Path not found: ${op.path}`);
    }
    if (op.op === "test") {
      let valueToCheck;
      if (Array.isArray(target)) {
        if (key === "-") {
          valueToCheck = void 0;
        } else {
          const index = parseInt(key, 10);
          if (isNaN(index) || index < 0 || index >= target.length) {
            valueToCheck = void 0;
          } else {
            valueToCheck = target[index];
          }
        }
      } else {
        valueToCheck = target[key];
      }
      if (!deepEqual2(valueToCheck, op.value)) {
        throw new Error(`Test failed at ${op.path}: expected ${JSON.stringify(op.value)}, got ${JSON.stringify(valueToCheck)}`);
      }
      return null;
    }
    if (Array.isArray(target)) {
      if (key === "-") {
        if (op.op === "add") {
          target.push(op.value);
          return { op: "remove", path: op.path.replace(/-$/, (target.length - 1).toString()) };
        } else {
          throw new Error("Can only add to '-' index");
        }
      }
      const index = parseInt(key, 10);
      if (isNaN(index) || index < 0) {
        throw new Error(`Invalid array index: ${key}`);
      }
      if (op.op === "add") {
        if (index > target.length) throw new Error("Index out of bounds");
        target.splice(index, 0, op.value);
        return { op: "remove", path: op.path };
      } else if (op.op === "remove") {
        if (index >= target.length) throw new Error("Index out of bounds");
        const oldValue = target[index];
        target.splice(index, 1);
        return { op: "add", path: op.path, value: oldValue };
      } else if (op.op === "replace") {
        if (index >= target.length) throw new Error("Index out of bounds");
        const oldValue = target[index];
        target[index] = op.value;
        return { op: "replace", path: op.path, value: oldValue };
      }
    } else {
      if (op.op === "add") {
        const oldValue = target[key];
        const existed = Object.prototype.hasOwnProperty.call(target, key);
        target[key] = op.value;
        return existed ? { op: "replace", path: op.path, value: oldValue } : { op: "remove", path: op.path };
      } else if (op.op === "replace") {
        if (!Object.prototype.hasOwnProperty.call(target, key)) {
          throw new Error(`Path not found: ${op.path}`);
        }
        const oldValue = target[key];
        target[key] = op.value;
        return { op: "replace", path: op.path, value: oldValue };
      } else if (op.op === "remove") {
        if (!Object.prototype.hasOwnProperty.call(target, key)) {
          throw new Error(`Path not found: ${op.path}`);
        }
        const oldValue = target[key];
        delete target[key];
        return { op: "add", path: op.path, value: oldValue };
      }
    }
    return null;
  }
  var init_patch = __esm({
    "src/patch.ts"() {
      "use strict";
    }
  });

  // src/console-api.ts
  function setCurrentAppState(state, webComponentFn, registerComponentFn) {
    currentAppState = state;
    if (webComponentFn) storedWebComponent = webComponentFn;
    if (registerComponentFn) storedRegisterComponent = registerComponentFn;
  }
  function getCurrentAppState() {
    return currentAppState;
  }
  function storeComponentContext(element, context) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) return;
    if (!isDebugEnabled("api")) return;
    componentContexts.set(element, context);
  }
  function isWebComponentResult(fn) {
    return typeof fn === "function" && fn[WEB_COMPONENT_MARKER] === true;
  }
  function define2(tagName, template, logic) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) {
      console.warn("[boreDOM] define() is not available in production build");
      return false;
    }
    if (!isDebugEnabled("api")) {
      console.warn("[boreDOM] define() is disabled (debug.api is false)");
      return false;
    }
    if (!currentAppState) {
      throw new Error("[boreDOM] Cannot define component before inflictBoreDOM()");
    }
    if (!tagName.includes("-")) {
      throw new Error(`[boreDOM] Invalid tag name "${tagName}": must contain a hyphen`);
    }
    if (customElements.get(tagName)) {
      throw new Error(`[boreDOM] Component "${tagName}" is already defined`);
    }
    if (!storedWebComponent || !storedRegisterComponent) {
      throw new Error("[boreDOM] Console API not initialized. Call inflictBoreDOM() first.");
    }
    const appState = currentAppState;
    const webComponentFn = storedWebComponent;
    const registerComponentFn = storedRegisterComponent;
    const templateEl = document.createElement("template");
    templateEl.innerHTML = template;
    templateEl.setAttribute("data-component", tagName);
    document.body.appendChild(templateEl);
    const componentLogic = isWebComponentResult(logic) ? logic : webComponentFn(logic);
    appState.internal.components.set(tagName, componentLogic);
    appState.internal.customTags.push(tagName);
    registerComponentFn(tagName);
    initializeExistingElements(tagName, componentLogic);
    if (isDebugEnabled("console")) {
      console.log(
        "%c\u2705 boreDOM: Defined %c<%s>",
        "color: #27ae60; font-weight: bold",
        "color: #4ecdc4; font-weight: bold",
        tagName
      );
    }
    return true;
  }
  function initializeExistingElements(tagName, logic) {
    if (!currentAppState) return;
    const elements = Array.from(document.querySelectorAll(tagName));
    const failedCount = { count: 0 };
    elements.forEach((elem, index) => {
      if (elem instanceof HTMLElement && "renderCallback" in elem) {
        try {
          const detail = { index, name: tagName, data: void 0 };
          const renderCallback = logic(currentAppState, detail);
          elem.renderCallback = renderCallback;
          renderCallback(elem);
        } catch (error) {
          failedCount.count++;
          if (isDebugEnabled("console")) {
            console.error(
              `[boreDOM] Failed to initialize <${tagName}> instance ${index}:`,
              error
            );
          }
        }
      }
    });
    if (failedCount.count > 0 && isDebugEnabled("console")) {
      console.warn(
        `[boreDOM] ${failedCount.count} of ${elements.length} <${tagName}> instances failed to initialize`
      );
    }
  }
  function operate(selectorOrElement, index = 0) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) {
      console.warn("[boreDOM] operate() is not available in production build");
      return void 0;
    }
    if (!isDebugEnabled("api")) {
      console.warn("[boreDOM] operate() is disabled (debug.api is false)");
      return void 0;
    }
    let element = null;
    if (typeof selectorOrElement === "string") {
      const elements = Array.from(document.querySelectorAll(selectorOrElement)).filter((el) => el instanceof HTMLElement);
      element = elements[index] ?? null;
    } else {
      element = selectorOrElement;
    }
    if (!element) {
      if (isDebugEnabled("console")) {
        console.warn(`[boreDOM] operate(): No element found for "${selectorOrElement}"`);
      }
      return void 0;
    }
    const context = componentContexts.get(element);
    if (!context) {
      if (isDebugEnabled("console")) {
        console.warn(`[boreDOM] operate(): Element is not a boreDOM component or not initialized`);
      }
      return void 0;
    }
    return context;
  }
  function exportComponent(selector) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) {
      console.warn("[boreDOM] exportComponent() is not available in production build");
      return null;
    }
    if (!isDebugEnabled("api")) {
      console.warn("[boreDOM] exportComponent() is disabled (debug.api is false)");
      return null;
    }
    const ctx = operate(selector);
    if (!ctx) return null;
    const templateEl = document.querySelector(`template[data-component="${ctx.detail.name}"]`);
    const templateHtml = templateEl?.innerHTML ?? void 0;
    try {
      return {
        component: ctx.detail.name,
        state: JSON.parse(JSON.stringify(ctx.state)),
        template: templateHtml,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (e) {
      if (isDebugEnabled("console")) {
        console.warn(
          `[boreDOM] exportComponent: Unable to serialize state for <${ctx.detail.name}>:`,
          e instanceof Error ? e.message : e
        );
      }
      return {
        component: ctx.detail.name,
        state: "[Unable to serialize - contains circular references or functions]",
        template: templateHtml,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
  }
  var WEB_COMPONENT_MARKER, currentAppState, storedWebComponent, storedRegisterComponent, componentContexts, consoleAPI;
  var init_console_api = __esm({
    "src/console-api.ts"() {
      "use strict";
      init_debug();
      WEB_COMPONENT_MARKER = Symbol("boreDOM.webComponent");
      currentAppState = null;
      storedWebComponent = null;
      storedRegisterComponent = null;
      componentContexts = /* @__PURE__ */ new WeakMap();
      consoleAPI = {
        define: define2,
        operate,
        exportComponent
      };
    }
  });

  // src/version.ts
  var VERSION;
  var init_version = __esm({
    "src/version.ts"() {
      "use strict";
      VERSION = "0.25.25";
    }
  });

  // src/llm.ts
  var llm_exports = {};
  __export(llm_exports, {
    llmAPI: () => llmAPI
  });
  var isLLMEnabled, _vision, _transact, llmAPI;
  var init_llm = __esm({
    "src/llm.ts"() {
      "use strict";
      init_vision();
      init_patch();
      init_console_api();
      init_flatten();
      init_version();
      isLLMEnabled = typeof __LLM__ !== "undefined" ? __LLM__ : typeof __DEBUG__ === "undefined" || __DEBUG__;
      _vision = (root) => {
        return getSemanticDOM(root || document.body);
      };
      _transact = (patch) => {
        const appState = getCurrentAppState();
        if (!appState || !appState.app) {
          return { success: false, error: "No app state found" };
        }
        return applyPatch(appState.app, patch);
      };
      llmAPI = {
        /**
         * Returns a lightweight, semantic JSON tree of the DOM.
         * Use this to "see" the UI structure, attributes, and text without
         * the noise of full DOM nodes. Hidden elements and scripts are ignored.
         * 
         * @returns {SemanticNode | null} The root node of the semantic tree.
         */
        vision: isLLMEnabled ? _vision : () => null,
        /**
         * Safely modifies the app state using a JSON Patch transaction.
         * Supports operations: "add", "remove", "replace", "test".
         * 
         * ATOMICITY: If any operation fails (including a "test"), the entire
         * transaction is rolled back, and the state remains unchanged.
         * 
         * REACTIVITY: Successful patches automatically trigger DOM updates.
         * 
         * @param {JSONPatchOp[]} patch - Array of patch operations.
         * @returns {TransactionResult} { success: true } or { success: false, error: string }
         */
        transact: isLLMEnabled ? _transact : () => ({ success: false, error: "Production mode" }),
        /**
         * Returns a compact, LLM-friendly summary of the app.
         * Includes framework/version, component list, and state paths.
         */
        compact: isLLMEnabled ? () => {
          const appState = getCurrentAppState();
          if (!appState || !appState.app) return null;
          const state = appState.app;
          const paths = flatten(state).map((entry) => entry.path.join("."));
          const sample = {};
          Object.entries(state).forEach(([key, value]) => {
            if (Array.isArray(value)) {
              sample[key] = `[${value.length}]`;
            } else if (value && typeof value === "object") {
              sample[key] = "{...}";
            } else {
              sample[key] = value;
            }
          });
          const components = Array.from(appState.internal.components.entries()).map(([tag, logic]) => ({ tag, hasLogic: Boolean(logic) }));
          return {
            framework: { name: "boreDOM", version: VERSION },
            state: { paths, sample },
            components
          };
        } : () => null
      };
    }
  });

  // src/debug.ts
  function isDebugEnabled(feature) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) {
      if (feature === "errorBoundary") {
        return debugConfig.errorBoundary ?? true;
      }
      return false;
    }
    const value = debugConfig[feature];
    if (feature === "strict") {
      return value ?? false;
    }
    return value ?? true;
  }
  function setDebugConfig(config3) {
    if (typeof config3 === "boolean") {
      const enabled = config3;
      debugConfig = {
        console: enabled,
        globals: enabled,
        errorBoundary: true,
        // Always keep error boundary for safety
        visualIndicators: enabled,
        errorHistory: enabled,
        versionLog: enabled,
        api: enabled,
        methodMissing: enabled,
        templateInference: enabled,
        strict: false,
        // Strict mode only enabled explicitly
        outputFormat: "human",
        // Always human format by default
        llm: enabled
        // LLM API follows debug mode
      };
    } else {
      debugConfig = { ...debugConfig, ...config3 };
    }
  }
  function getDebugConfig() {
    return { ...debugConfig };
  }
  function exposeGlobals(ctx) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) return;
    if (!isDebugEnabled("globals")) return;
    if (typeof window === "undefined") return;
    const w = window;
    w.$state = ctx.state;
    w.$refs = ctx.refs;
    w.$slots = ctx.slots;
    w.$self = ctx.element;
    w.$error = ctx.error;
    w.$component = ctx.component;
    w.$rerender = ctx.rerender;
  }
  function clearGlobals() {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) return;
    if (!isDebugEnabled("globals")) return;
    if (typeof window === "undefined") return;
    const w = window;
    delete w.$state;
    delete w.$refs;
    delete w.$slots;
    delete w.$self;
    delete w.$error;
    delete w.$component;
    delete w.$rerender;
  }
  function logError(ctx) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) return;
    if (!isDebugEnabled("console")) return;
    if (debugConfig.outputFormat === "llm") {
      Promise.resolve().then(() => (init_llm(), llm_exports)).then(({ formatErrorForLLM }) => {
        console.log(formatErrorForLLM(ctx));
      });
      return;
    }
    console.log(
      "%c\u{1F534} boreDOM: Error in %c<%s>%c render",
      "color: #ff6b6b; font-weight: bold",
      "color: #4ecdc4; font-weight: bold",
      ctx.component,
      "color: #ff6b6b"
    );
    console.error(ctx.error);
    if (isDebugEnabled("globals")) {
      console.log("%c\u{1F4CB} Debug context loaded:", "color: #95a5a6; font-weight: bold");
      console.log("   $state     \u2192", ctx.state);
      console.log("   $refs      \u2192", ctx.refs);
      console.log("   $slots     \u2192", ctx.slots);
      console.log("   $self      \u2192", ctx.element);
      console.log("%c\u{1F4A1} Quick fixes:", "color: #f39c12; font-weight: bold");
      console.log("   $state.propertyName = value");
      console.log("   $rerender()");
      console.log("%c\u{1F4E4} When fixed:", "color: #27ae60; font-weight: bold");
      console.log(`   boreDOM.export('${ctx.component}')`);
    }
  }
  function logErrorMinimal(component3, error) {
    console.error(`[boreDOM] Render error in <${component3}>: ${error.message}`);
  }
  function logInitError(component3, error) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) return;
    if (!isDebugEnabled("console")) return;
    console.log(
      "%c\u{1F534} boreDOM: Error in %c<%s>%c init",
      "color: #ff6b6b; font-weight: bold",
      "color: #4ecdc4; font-weight: bold",
      component3,
      "color: #ff6b6b"
    );
    console.error(error);
  }
  function storeError(ctx) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) return;
    if (!isDebugEnabled("errorHistory")) return;
    errors.set(ctx.component, ctx);
    lastError = ctx;
  }
  function clearError(component3) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) return;
    if (!isDebugEnabled("errorHistory")) return;
    if (component3) {
      errors.delete(component3);
      if (lastError?.component === component3) {
        lastError = null;
      }
    } else if (lastError) {
      errors.delete(lastError.component);
      lastError = null;
    }
  }
  function markComponentError(element) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) return;
    if (!isDebugEnabled("visualIndicators")) return;
    element.setAttribute("data-boredom-error", "true");
  }
  function clearComponentErrorMark(element) {
    element.removeAttribute("data-boredom-error");
  }
  function exportState(tagName) {
    const ctx = tagName ? errors.get(tagName) : lastError;
    if (!ctx) return null;
    try {
      return {
        component: ctx.component,
        state: JSON.parse(JSON.stringify(ctx.state)),
        timestamp: new Date(ctx.timestamp).toISOString(),
        error: ctx.error.message
      };
    } catch (e) {
      if (isDebugEnabled("console")) {
        console.warn(
          `[boreDOM] exportState: Unable to serialize state for <${ctx.component}>:`,
          e instanceof Error ? e.message : e
        );
      }
      return {
        component: ctx.component,
        state: "[Unable to serialize - contains circular references or functions]",
        timestamp: new Date(ctx.timestamp).toISOString(),
        error: ctx.error.message
      };
    }
  }
  var debugConfig, errors, lastError, debugAPI;
  var init_debug = __esm({
    "src/debug.ts"() {
      "use strict";
      debugConfig = {
        console: true,
        globals: true,
        errorBoundary: true,
        visualIndicators: true,
        errorHistory: true,
        versionLog: true,
        api: true,
        methodMissing: true,
        templateInference: true,
        strict: false,
        outputFormat: "human",
        llm: true
      };
      errors = /* @__PURE__ */ new Map();
      lastError = null;
      debugAPI = {
        /** Map of all current errors by component name */
        get errors() {
          return errors;
        },
        /** Most recent error context */
        get lastError() {
          return lastError;
        },
        /** Re-render a specific component or the last errored one */
        rerender(tagName) {
          const ctx = tagName ? errors.get(tagName) : lastError;
          if (ctx) {
            ctx.rerender();
          } else {
            console.warn("[boreDOM] No error context found to rerender");
          }
        },
        /** Clear error state for a component */
        clearError(tagName) {
          const ctx = tagName ? errors.get(tagName) : lastError;
          if (ctx) {
            clearComponentErrorMark(ctx.element);
            clearError(tagName);
            clearGlobals();
          } else if (isDebugEnabled("console")) {
            console.warn(
              tagName ? `[boreDOM] clearError: No error found for <${tagName}>` : "[boreDOM] clearError: No error to clear"
            );
          }
        },
        /** Export state snapshot */
        export: exportState,
        /** Current debug configuration (read-only) */
        get config() {
          return getDebugConfig();
        }
      };
    }
  });

  // node_modules/.pnpm/chai@5.3.3/node_modules/chai/index.js
  var __defProp2 = Object.defineProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var utils_exports = {};
  __export2(utils_exports, {
    addChainableMethod: () => addChainableMethod,
    addLengthGuard: () => addLengthGuard,
    addMethod: () => addMethod,
    addProperty: () => addProperty,
    checkError: () => check_error_exports,
    compareByInspect: () => compareByInspect,
    eql: () => deep_eql_default,
    expectTypes: () => expectTypes,
    flag: () => flag,
    getActual: () => getActual,
    getMessage: () => getMessage2,
    getName: () => getName,
    getOperator: () => getOperator,
    getOwnEnumerableProperties: () => getOwnEnumerableProperties,
    getOwnEnumerablePropertySymbols: () => getOwnEnumerablePropertySymbols,
    getPathInfo: () => getPathInfo,
    hasProperty: () => hasProperty,
    inspect: () => inspect2,
    isNaN: () => isNaN22,
    isNumeric: () => isNumeric,
    isProxyEnabled: () => isProxyEnabled,
    isRegExp: () => isRegExp2,
    objDisplay: () => objDisplay,
    overwriteChainableMethod: () => overwriteChainableMethod,
    overwriteMethod: () => overwriteMethod,
    overwriteProperty: () => overwriteProperty,
    proxify: () => proxify,
    test: () => test,
    transferFlags: () => transferFlags,
    type: () => type
  });
  var check_error_exports = {};
  __export2(check_error_exports, {
    compatibleConstructor: () => compatibleConstructor,
    compatibleInstance: () => compatibleInstance,
    compatibleMessage: () => compatibleMessage,
    getConstructorName: () => getConstructorName,
    getMessage: () => getMessage
  });
  function isErrorInstance(obj) {
    return obj instanceof Error || Object.prototype.toString.call(obj) === "[object Error]";
  }
  __name(isErrorInstance, "isErrorInstance");
  function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  }
  __name(isRegExp, "isRegExp");
  function compatibleInstance(thrown, errorLike) {
    return isErrorInstance(errorLike) && thrown === errorLike;
  }
  __name(compatibleInstance, "compatibleInstance");
  function compatibleConstructor(thrown, errorLike) {
    if (isErrorInstance(errorLike)) {
      return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
    } else if ((typeof errorLike === "object" || typeof errorLike === "function") && errorLike.prototype) {
      return thrown.constructor === errorLike || thrown instanceof errorLike;
    }
    return false;
  }
  __name(compatibleConstructor, "compatibleConstructor");
  function compatibleMessage(thrown, errMatcher) {
    const comparisonString = typeof thrown === "string" ? thrown : thrown.message;
    if (isRegExp(errMatcher)) {
      return errMatcher.test(comparisonString);
    } else if (typeof errMatcher === "string") {
      return comparisonString.indexOf(errMatcher) !== -1;
    }
    return false;
  }
  __name(compatibleMessage, "compatibleMessage");
  function getConstructorName(errorLike) {
    let constructorName = errorLike;
    if (isErrorInstance(errorLike)) {
      constructorName = errorLike.constructor.name;
    } else if (typeof errorLike === "function") {
      constructorName = errorLike.name;
      if (constructorName === "") {
        const newConstructorName = new errorLike().name;
        constructorName = newConstructorName || constructorName;
      }
    }
    return constructorName;
  }
  __name(getConstructorName, "getConstructorName");
  function getMessage(errorLike) {
    let msg = "";
    if (errorLike && errorLike.message) {
      msg = errorLike.message;
    } else if (typeof errorLike === "string") {
      msg = errorLike;
    }
    return msg;
  }
  __name(getMessage, "getMessage");
  function flag(obj, key, value) {
    let flags = obj.__flags || (obj.__flags = /* @__PURE__ */ Object.create(null));
    if (arguments.length === 3) {
      flags[key] = value;
    } else {
      return flags[key];
    }
  }
  __name(flag, "flag");
  function test(obj, args) {
    let negate = flag(obj, "negate"), expr = args[0];
    return negate ? !expr : expr;
  }
  __name(test, "test");
  function type(obj) {
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    const stringTag = obj[Symbol.toStringTag];
    if (typeof stringTag === "string") {
      return stringTag;
    }
    const type3 = Object.prototype.toString.call(obj).slice(8, -1);
    return type3;
  }
  __name(type, "type");
  var canElideFrames = "captureStackTrace" in Error;
  var AssertionError = class _AssertionError extends Error {
    static {
      __name(this, "AssertionError");
    }
    message;
    get name() {
      return "AssertionError";
    }
    get ok() {
      return false;
    }
    constructor(message = "Unspecified AssertionError", props, ssf) {
      super(message);
      this.message = message;
      if (canElideFrames) {
        Error.captureStackTrace(this, ssf || _AssertionError);
      }
      for (const key in props) {
        if (!(key in this)) {
          this[key] = props[key];
        }
      }
    }
    toJSON(stack) {
      return {
        ...this,
        name: this.name,
        message: this.message,
        ok: false,
        stack: stack !== false ? this.stack : void 0
      };
    }
  };
  function expectTypes(obj, types) {
    let flagMsg = flag(obj, "message");
    let ssfi = flag(obj, "ssfi");
    flagMsg = flagMsg ? flagMsg + ": " : "";
    obj = flag(obj, "object");
    types = types.map(function(t) {
      return t.toLowerCase();
    });
    types.sort();
    let str = types.map(function(t, index) {
      let art = ~["a", "e", "i", "o", "u"].indexOf(t.charAt(0)) ? "an" : "a";
      let or = types.length > 1 && index === types.length - 1 ? "or " : "";
      return or + art + " " + t;
    }).join(", ");
    let objType = type(obj).toLowerCase();
    if (!types.some(function(expected) {
      return objType === expected;
    })) {
      throw new AssertionError(
        flagMsg + "object tested must be " + str + ", but " + objType + " given",
        void 0,
        ssfi
      );
    }
  }
  __name(expectTypes, "expectTypes");
  function getActual(obj, args) {
    return args.length > 4 ? args[4] : obj._obj;
  }
  __name(getActual, "getActual");
  var ansiColors = {
    bold: ["1", "22"],
    dim: ["2", "22"],
    italic: ["3", "23"],
    underline: ["4", "24"],
    // 5 & 6 are blinking
    inverse: ["7", "27"],
    hidden: ["8", "28"],
    strike: ["9", "29"],
    // 10-20 are fonts
    // 21-29 are resets for 1-9
    black: ["30", "39"],
    red: ["31", "39"],
    green: ["32", "39"],
    yellow: ["33", "39"],
    blue: ["34", "39"],
    magenta: ["35", "39"],
    cyan: ["36", "39"],
    white: ["37", "39"],
    brightblack: ["30;1", "39"],
    brightred: ["31;1", "39"],
    brightgreen: ["32;1", "39"],
    brightyellow: ["33;1", "39"],
    brightblue: ["34;1", "39"],
    brightmagenta: ["35;1", "39"],
    brightcyan: ["36;1", "39"],
    brightwhite: ["37;1", "39"],
    grey: ["90", "39"]
  };
  var styles = {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red"
  };
  var truncator = "\u2026";
  function colorise(value, styleType) {
    const color = ansiColors[styles[styleType]] || ansiColors[styleType] || "";
    if (!color) {
      return String(value);
    }
    return `\x1B[${color[0]}m${String(value)}\x1B[${color[1]}m`;
  }
  __name(colorise, "colorise");
  function normaliseOptions({
    showHidden = false,
    depth = 2,
    colors = false,
    customInspect = true,
    showProxy = false,
    maxArrayLength = Infinity,
    breakLength = Infinity,
    seen = [],
    // eslint-disable-next-line no-shadow
    truncate: truncate2 = Infinity,
    stylize = String
  } = {}, inspect3) {
    const options = {
      showHidden: Boolean(showHidden),
      depth: Number(depth),
      colors: Boolean(colors),
      customInspect: Boolean(customInspect),
      showProxy: Boolean(showProxy),
      maxArrayLength: Number(maxArrayLength),
      breakLength: Number(breakLength),
      truncate: Number(truncate2),
      seen,
      inspect: inspect3,
      stylize
    };
    if (options.colors) {
      options.stylize = colorise;
    }
    return options;
  }
  __name(normaliseOptions, "normaliseOptions");
  function isHighSurrogate(char) {
    return char >= "\uD800" && char <= "\uDBFF";
  }
  __name(isHighSurrogate, "isHighSurrogate");
  function truncate(string, length, tail = truncator) {
    string = String(string);
    const tailLength = tail.length;
    const stringLength = string.length;
    if (tailLength > length && stringLength > tailLength) {
      return tail;
    }
    if (stringLength > length && stringLength > tailLength) {
      let end = length - tailLength;
      if (end > 0 && isHighSurrogate(string[end - 1])) {
        end = end - 1;
      }
      return `${string.slice(0, end)}${tail}`;
    }
    return string;
  }
  __name(truncate, "truncate");
  function inspectList(list, options, inspectItem, separator = ", ") {
    inspectItem = inspectItem || options.inspect;
    const size = list.length;
    if (size === 0)
      return "";
    const originalLength = options.truncate;
    let output = "";
    let peek = "";
    let truncated = "";
    for (let i = 0; i < size; i += 1) {
      const last = i + 1 === list.length;
      const secondToLast = i + 2 === list.length;
      truncated = `${truncator}(${list.length - i})`;
      const value = list[i];
      options.truncate = originalLength - output.length - (last ? 0 : separator.length);
      const string = peek || inspectItem(value, options) + (last ? "" : separator);
      const nextLength = output.length + string.length;
      const truncatedLength = nextLength + truncated.length;
      if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
        break;
      }
      if (!last && !secondToLast && truncatedLength > originalLength) {
        break;
      }
      peek = last ? "" : inspectItem(list[i + 1], options) + (secondToLast ? "" : separator);
      if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
        break;
      }
      output += string;
      if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
        truncated = `${truncator}(${list.length - i - 1})`;
        break;
      }
      truncated = "";
    }
    return `${output}${truncated}`;
  }
  __name(inspectList, "inspectList");
  function quoteComplexKey(key) {
    if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
      return key;
    }
    return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
  }
  __name(quoteComplexKey, "quoteComplexKey");
  function inspectProperty([key, value], options) {
    options.truncate -= 2;
    if (typeof key === "string") {
      key = quoteComplexKey(key);
    } else if (typeof key !== "number") {
      key = `[${options.inspect(key, options)}]`;
    }
    options.truncate -= key.length;
    value = options.inspect(value, options);
    return `${key}: ${value}`;
  }
  __name(inspectProperty, "inspectProperty");
  function inspectArray(array, options) {
    const nonIndexProperties = Object.keys(array).slice(array.length);
    if (!array.length && !nonIndexProperties.length)
      return "[]";
    options.truncate -= 4;
    const listContents = inspectList(array, options);
    options.truncate -= listContents.length;
    let propertyContents = "";
    if (nonIndexProperties.length) {
      propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty);
    }
    return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
  }
  __name(inspectArray, "inspectArray");
  var getArrayName = /* @__PURE__ */ __name((array) => {
    if (typeof Buffer === "function" && array instanceof Buffer) {
      return "Buffer";
    }
    if (array[Symbol.toStringTag]) {
      return array[Symbol.toStringTag];
    }
    return array.constructor.name;
  }, "getArrayName");
  function inspectTypedArray(array, options) {
    const name = getArrayName(array);
    options.truncate -= name.length + 4;
    const nonIndexProperties = Object.keys(array).slice(array.length);
    if (!array.length && !nonIndexProperties.length)
      return `${name}[]`;
    let output = "";
    for (let i = 0; i < array.length; i++) {
      const string = `${options.stylize(truncate(array[i], options.truncate), "number")}${i === array.length - 1 ? "" : ", "}`;
      options.truncate -= string.length;
      if (array[i] !== array.length && options.truncate <= 3) {
        output += `${truncator}(${array.length - array[i] + 1})`;
        break;
      }
      output += string;
    }
    let propertyContents = "";
    if (nonIndexProperties.length) {
      propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty);
    }
    return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
  }
  __name(inspectTypedArray, "inspectTypedArray");
  function inspectDate(dateObject, options) {
    const stringRepresentation = dateObject.toJSON();
    if (stringRepresentation === null) {
      return "Invalid Date";
    }
    const split = stringRepresentation.split("T");
    const date = split[0];
    return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, "date");
  }
  __name(inspectDate, "inspectDate");
  function inspectFunction(func, options) {
    const functionType = func[Symbol.toStringTag] || "Function";
    const name = func.name;
    if (!name) {
      return options.stylize(`[${functionType}]`, "special");
    }
    return options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, "special");
  }
  __name(inspectFunction, "inspectFunction");
  function inspectMapEntry([key, value], options) {
    options.truncate -= 4;
    key = options.inspect(key, options);
    options.truncate -= key.length;
    value = options.inspect(value, options);
    return `${key} => ${value}`;
  }
  __name(inspectMapEntry, "inspectMapEntry");
  function mapToEntries(map) {
    const entries = [];
    map.forEach((value, key) => {
      entries.push([key, value]);
    });
    return entries;
  }
  __name(mapToEntries, "mapToEntries");
  function inspectMap(map, options) {
    if (map.size === 0)
      return "Map{}";
    options.truncate -= 7;
    return `Map{ ${inspectList(mapToEntries(map), options, inspectMapEntry)} }`;
  }
  __name(inspectMap, "inspectMap");
  var isNaN2 = Number.isNaN || ((i) => i !== i);
  function inspectNumber(number, options) {
    if (isNaN2(number)) {
      return options.stylize("NaN", "number");
    }
    if (number === Infinity) {
      return options.stylize("Infinity", "number");
    }
    if (number === -Infinity) {
      return options.stylize("-Infinity", "number");
    }
    if (number === 0) {
      return options.stylize(1 / number === Infinity ? "+0" : "-0", "number");
    }
    return options.stylize(truncate(String(number), options.truncate), "number");
  }
  __name(inspectNumber, "inspectNumber");
  function inspectBigInt(number, options) {
    let nums = truncate(number.toString(), options.truncate - 1);
    if (nums !== truncator)
      nums += "n";
    return options.stylize(nums, "bigint");
  }
  __name(inspectBigInt, "inspectBigInt");
  function inspectRegExp(value, options) {
    const flags = value.toString().split("/")[2];
    const sourceLength = options.truncate - (2 + flags.length);
    const source = value.source;
    return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, "regexp");
  }
  __name(inspectRegExp, "inspectRegExp");
  function arrayFromSet(set2) {
    const values = [];
    set2.forEach((value) => {
      values.push(value);
    });
    return values;
  }
  __name(arrayFromSet, "arrayFromSet");
  function inspectSet(set2, options) {
    if (set2.size === 0)
      return "Set{}";
    options.truncate -= 7;
    return `Set{ ${inspectList(arrayFromSet(set2), options)} }`;
  }
  __name(inspectSet, "inspectSet");
  var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
  var escapeCharacters = {
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    "'": "\\'",
    "\\": "\\\\"
  };
  var hex = 16;
  var unicodeLength = 4;
  function escape(char) {
    return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;
  }
  __name(escape, "escape");
  function inspectString(string, options) {
    if (stringEscapeChars.test(string)) {
      string = string.replace(stringEscapeChars, escape);
    }
    return options.stylize(`'${truncate(string, options.truncate - 2)}'`, "string");
  }
  __name(inspectString, "inspectString");
  function inspectSymbol(value) {
    if ("description" in Symbol.prototype) {
      return value.description ? `Symbol(${value.description})` : "Symbol()";
    }
    return value.toString();
  }
  __name(inspectSymbol, "inspectSymbol");
  var getPromiseValue = /* @__PURE__ */ __name(() => "Promise{\u2026}", "getPromiseValue");
  var promise_default = getPromiseValue;
  function inspectObject(object, options) {
    const properties = Object.getOwnPropertyNames(object);
    const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
    if (properties.length === 0 && symbols.length === 0) {
      return "{}";
    }
    options.truncate -= 4;
    options.seen = options.seen || [];
    if (options.seen.includes(object)) {
      return "[Circular]";
    }
    options.seen.push(object);
    const propertyContents = inspectList(properties.map((key) => [key, object[key]]), options, inspectProperty);
    const symbolContents = inspectList(symbols.map((key) => [key, object[key]]), options, inspectProperty);
    options.seen.pop();
    let sep = "";
    if (propertyContents && symbolContents) {
      sep = ", ";
    }
    return `{ ${propertyContents}${sep}${symbolContents} }`;
  }
  __name(inspectObject, "inspectObject");
  var toStringTag = typeof Symbol !== "undefined" && Symbol.toStringTag ? Symbol.toStringTag : false;
  function inspectClass(value, options) {
    let name = "";
    if (toStringTag && toStringTag in value) {
      name = value[toStringTag];
    }
    name = name || value.constructor.name;
    if (!name || name === "_class") {
      name = "<Anonymous Class>";
    }
    options.truncate -= name.length;
    return `${name}${inspectObject(value, options)}`;
  }
  __name(inspectClass, "inspectClass");
  function inspectArguments(args, options) {
    if (args.length === 0)
      return "Arguments[]";
    options.truncate -= 13;
    return `Arguments[ ${inspectList(args, options)} ]`;
  }
  __name(inspectArguments, "inspectArguments");
  var errorKeys = [
    "stack",
    "line",
    "column",
    "name",
    "message",
    "fileName",
    "lineNumber",
    "columnNumber",
    "number",
    "description",
    "cause"
  ];
  function inspectObject2(error, options) {
    const properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1);
    const name = error.name;
    options.truncate -= name.length;
    let message = "";
    if (typeof error.message === "string") {
      message = truncate(error.message, options.truncate);
    } else {
      properties.unshift("message");
    }
    message = message ? `: ${message}` : "";
    options.truncate -= message.length + 5;
    options.seen = options.seen || [];
    if (options.seen.includes(error)) {
      return "[Circular]";
    }
    options.seen.push(error);
    const propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);
    return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
  }
  __name(inspectObject2, "inspectObject");
  function inspectAttribute([key, value], options) {
    options.truncate -= 3;
    if (!value) {
      return `${options.stylize(String(key), "yellow")}`;
    }
    return `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}`;
  }
  __name(inspectAttribute, "inspectAttribute");
  function inspectNodeCollection(collection, options) {
    return inspectList(collection, options, inspectNode, "\n");
  }
  __name(inspectNodeCollection, "inspectNodeCollection");
  function inspectNode(node, options) {
    switch (node.nodeType) {
      case 1:
        return inspectHTML(node, options);
      case 3:
        return options.inspect(node.data, options);
      default:
        return options.inspect(node, options);
    }
  }
  __name(inspectNode, "inspectNode");
  function inspectHTML(element, options) {
    const properties = element.getAttributeNames();
    const name = element.tagName.toLowerCase();
    const head = options.stylize(`<${name}`, "special");
    const headClose = options.stylize(`>`, "special");
    const tail = options.stylize(`</${name}>`, "special");
    options.truncate -= name.length * 2 + 5;
    let propertyContents = "";
    if (properties.length > 0) {
      propertyContents += " ";
      propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, " ");
    }
    options.truncate -= propertyContents.length;
    const truncate2 = options.truncate;
    let children = inspectNodeCollection(element.children, options);
    if (children && children.length > truncate2) {
      children = `${truncator}(${element.children.length})`;
    }
    return `${head}${propertyContents}${headClose}${children}${tail}`;
  }
  __name(inspectHTML, "inspectHTML");
  var symbolsSupported = typeof Symbol === "function" && typeof Symbol.for === "function";
  var chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect";
  var nodeInspect = Symbol.for("nodejs.util.inspect.custom");
  var constructorMap = /* @__PURE__ */ new WeakMap();
  var stringTagMap = {};
  var baseTypesMap = {
    undefined: /* @__PURE__ */ __name((value, options) => options.stylize("undefined", "undefined"), "undefined"),
    null: /* @__PURE__ */ __name((value, options) => options.stylize("null", "null"), "null"),
    boolean: /* @__PURE__ */ __name((value, options) => options.stylize(String(value), "boolean"), "boolean"),
    Boolean: /* @__PURE__ */ __name((value, options) => options.stylize(String(value), "boolean"), "Boolean"),
    number: inspectNumber,
    Number: inspectNumber,
    bigint: inspectBigInt,
    BigInt: inspectBigInt,
    string: inspectString,
    String: inspectString,
    function: inspectFunction,
    Function: inspectFunction,
    symbol: inspectSymbol,
    // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
    Symbol: inspectSymbol,
    Array: inspectArray,
    Date: inspectDate,
    Map: inspectMap,
    Set: inspectSet,
    RegExp: inspectRegExp,
    Promise: promise_default,
    // WeakSet, WeakMap are totally opaque to us
    WeakSet: /* @__PURE__ */ __name((value, options) => options.stylize("WeakSet{\u2026}", "special"), "WeakSet"),
    WeakMap: /* @__PURE__ */ __name((value, options) => options.stylize("WeakMap{\u2026}", "special"), "WeakMap"),
    Arguments: inspectArguments,
    Int8Array: inspectTypedArray,
    Uint8Array: inspectTypedArray,
    Uint8ClampedArray: inspectTypedArray,
    Int16Array: inspectTypedArray,
    Uint16Array: inspectTypedArray,
    Int32Array: inspectTypedArray,
    Uint32Array: inspectTypedArray,
    Float32Array: inspectTypedArray,
    Float64Array: inspectTypedArray,
    Generator: /* @__PURE__ */ __name(() => "", "Generator"),
    DataView: /* @__PURE__ */ __name(() => "", "DataView"),
    ArrayBuffer: /* @__PURE__ */ __name(() => "", "ArrayBuffer"),
    Error: inspectObject2,
    HTMLCollection: inspectNodeCollection,
    NodeList: inspectNodeCollection
  };
  var inspectCustom = /* @__PURE__ */ __name((value, options, type3) => {
    if (chaiInspect in value && typeof value[chaiInspect] === "function") {
      return value[chaiInspect](options);
    }
    if (nodeInspect in value && typeof value[nodeInspect] === "function") {
      return value[nodeInspect](options.depth, options);
    }
    if ("inspect" in value && typeof value.inspect === "function") {
      return value.inspect(options.depth, options);
    }
    if ("constructor" in value && constructorMap.has(value.constructor)) {
      return constructorMap.get(value.constructor)(value, options);
    }
    if (stringTagMap[type3]) {
      return stringTagMap[type3](value, options);
    }
    return "";
  }, "inspectCustom");
  var toString = Object.prototype.toString;
  function inspect(value, opts = {}) {
    const options = normaliseOptions(opts, inspect);
    const { customInspect } = options;
    let type3 = value === null ? "null" : typeof value;
    if (type3 === "object") {
      type3 = toString.call(value).slice(8, -1);
    }
    if (type3 in baseTypesMap) {
      return baseTypesMap[type3](value, options);
    }
    if (customInspect && value) {
      const output = inspectCustom(value, options, type3);
      if (output) {
        if (typeof output === "string")
          return output;
        return inspect(output, options);
      }
    }
    const proto = value ? Object.getPrototypeOf(value) : false;
    if (proto === Object.prototype || proto === null) {
      return inspectObject(value, options);
    }
    if (value && typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return inspectHTML(value, options);
    }
    if ("constructor" in value) {
      if (value.constructor !== Object) {
        return inspectClass(value, options);
      }
      return inspectObject(value, options);
    }
    if (value === Object(value)) {
      return inspectObject(value, options);
    }
    return options.stylize(String(value), type3);
  }
  __name(inspect, "inspect");
  var config = {
    /**
     * ### config.includeStack
     *
     * User configurable property, influences whether stack trace
     * is included in Assertion error message. Default of false
     * suppresses stack trace in the error message.
     *
     *     chai.config.includeStack = true;  // enable stack on error
     *
     * @param {boolean}
     * @public
     */
    includeStack: false,
    /**
     * ### config.showDiff
     *
     * User configurable property, influences whether or not
     * the `showDiff` flag should be included in the thrown
     * AssertionErrors. `false` will always be `false`; `true`
     * will be true when the assertion has requested a diff
     * be shown.
     *
     * @param {boolean}
     * @public
     */
    showDiff: true,
    /**
     * ### config.truncateThreshold
     *
     * User configurable property, sets length threshold for actual and
     * expected values in assertion errors. If this threshold is exceeded, for
     * example for large data structures, the value is replaced with something
     * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
     *
     * Set it to zero if you want to disable truncating altogether.
     *
     * This is especially userful when doing assertions on arrays: having this
     * set to a reasonable large value makes the failure messages readily
     * inspectable.
     *
     *     chai.config.truncateThreshold = 0;  // disable truncating
     *
     * @param {number}
     * @public
     */
    truncateThreshold: 40,
    /**
     * ### config.useProxy
     *
     * User configurable property, defines if chai will use a Proxy to throw
     * an error when a non-existent property is read, which protects users
     * from typos when using property-based assertions.
     *
     * Set it to false if you want to disable this feature.
     *
     *     chai.config.useProxy = false;  // disable use of Proxy
     *
     * This feature is automatically disabled regardless of this config value
     * in environments that don't support proxies.
     *
     * @param {boolean}
     * @public
     */
    useProxy: true,
    /**
     * ### config.proxyExcludedKeys
     *
     * User configurable property, defines which properties should be ignored
     * instead of throwing an error if they do not exist on the assertion.
     * This is only applied if the environment Chai is running in supports proxies and
     * if the `useProxy` configuration setting is enabled.
     * By default, `then` and `inspect` will not throw an error if they do not exist on the
     * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
     * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
     *
     *     // By default these keys will not throw an error if they do not exist on the assertion object
     *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
     *
     * @param {Array}
     * @public
     */
    proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
    /**
     * ### config.deepEqual
     *
     * User configurable property, defines which a custom function to use for deepEqual
     * comparisons.
     * By default, the function used is the one from the `deep-eql` package without custom comparator.
     *
     *     // use a custom comparator
     *     chai.config.deepEqual = (expected, actual) => {
     *         return chai.util.eql(expected, actual, {
     *             comparator: (expected, actual) => {
     *                 // for non number comparison, use the default behavior
     *                 if(typeof expected !== 'number') return null;
     *                 // allow a difference of 10 between compared numbers
     *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
     *             }
     *         })
     *     };
     *
     * @param {Function}
     * @public
     */
    deepEqual: null
  };
  function inspect2(obj, showHidden, depth, colors) {
    let options = {
      colors,
      depth: typeof depth === "undefined" ? 2 : depth,
      showHidden,
      truncate: config.truncateThreshold ? config.truncateThreshold : Infinity
    };
    return inspect(obj, options);
  }
  __name(inspect2, "inspect");
  function objDisplay(obj) {
    let str = inspect2(obj), type3 = Object.prototype.toString.call(obj);
    if (config.truncateThreshold && str.length >= config.truncateThreshold) {
      if (type3 === "[object Function]") {
        return !obj.name || obj.name === "" ? "[Function]" : "[Function: " + obj.name + "]";
      } else if (type3 === "[object Array]") {
        return "[ Array(" + obj.length + ") ]";
      } else if (type3 === "[object Object]") {
        let keys = Object.keys(obj), kstr = keys.length > 2 ? keys.splice(0, 2).join(", ") + ", ..." : keys.join(", ");
        return "{ Object (" + kstr + ") }";
      } else {
        return str;
      }
    } else {
      return str;
    }
  }
  __name(objDisplay, "objDisplay");
  function getMessage2(obj, args) {
    let negate = flag(obj, "negate");
    let val = flag(obj, "object");
    let expected = args[3];
    let actual = getActual(obj, args);
    let msg = negate ? args[2] : args[1];
    let flagMsg = flag(obj, "message");
    if (typeof msg === "function") msg = msg();
    msg = msg || "";
    msg = msg.replace(/#\{this\}/g, function() {
      return objDisplay(val);
    }).replace(/#\{act\}/g, function() {
      return objDisplay(actual);
    }).replace(/#\{exp\}/g, function() {
      return objDisplay(expected);
    });
    return flagMsg ? flagMsg + ": " + msg : msg;
  }
  __name(getMessage2, "getMessage");
  function transferFlags(assertion, object, includeAll) {
    let flags = assertion.__flags || (assertion.__flags = /* @__PURE__ */ Object.create(null));
    if (!object.__flags) {
      object.__flags = /* @__PURE__ */ Object.create(null);
    }
    includeAll = arguments.length === 3 ? includeAll : true;
    for (let flag3 in flags) {
      if (includeAll || flag3 !== "object" && flag3 !== "ssfi" && flag3 !== "lockSsfi" && flag3 != "message") {
        object.__flags[flag3] = flags[flag3];
      }
    }
  }
  __name(transferFlags, "transferFlags");
  function type2(obj) {
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    const stringTag = obj[Symbol.toStringTag];
    if (typeof stringTag === "string") {
      return stringTag;
    }
    const sliceStart = 8;
    const sliceEnd = -1;
    return Object.prototype.toString.call(obj).slice(sliceStart, sliceEnd);
  }
  __name(type2, "type");
  function FakeMap() {
    this._key = "chai/deep-eql__" + Math.random() + Date.now();
  }
  __name(FakeMap, "FakeMap");
  FakeMap.prototype = {
    get: /* @__PURE__ */ __name(function get(key) {
      return key[this._key];
    }, "get"),
    set: /* @__PURE__ */ __name(function set(key, value) {
      if (Object.isExtensible(key)) {
        Object.defineProperty(key, this._key, {
          value,
          configurable: true
        });
      }
    }, "set")
  };
  var MemoizeMap = typeof WeakMap === "function" ? WeakMap : FakeMap;
  function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
    if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
      return null;
    }
    var leftHandMap = memoizeMap.get(leftHandOperand);
    if (leftHandMap) {
      var result = leftHandMap.get(rightHandOperand);
      if (typeof result === "boolean") {
        return result;
      }
    }
    return null;
  }
  __name(memoizeCompare, "memoizeCompare");
  function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
    if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
      return;
    }
    var leftHandMap = memoizeMap.get(leftHandOperand);
    if (leftHandMap) {
      leftHandMap.set(rightHandOperand, result);
    } else {
      leftHandMap = new MemoizeMap();
      leftHandMap.set(rightHandOperand, result);
      memoizeMap.set(leftHandOperand, leftHandMap);
    }
  }
  __name(memoizeSet, "memoizeSet");
  var deep_eql_default = deepEqual;
  function deepEqual(leftHandOperand, rightHandOperand, options) {
    if (options && options.comparator) {
      return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
    }
    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
    if (simpleResult !== null) {
      return simpleResult;
    }
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  }
  __name(deepEqual, "deepEqual");
  function simpleEqual(leftHandOperand, rightHandOperand) {
    if (leftHandOperand === rightHandOperand) {
      return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
    }
    if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
    rightHandOperand !== rightHandOperand) {
      return true;
    }
    if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
      return false;
    }
    return null;
  }
  __name(simpleEqual, "simpleEqual");
  function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
    options = options || {};
    options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
    var comparator = options && options.comparator;
    var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
    if (memoizeResultLeft !== null) {
      return memoizeResultLeft;
    }
    var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
    if (memoizeResultRight !== null) {
      return memoizeResultRight;
    }
    if (comparator) {
      var comparatorResult = comparator(leftHandOperand, rightHandOperand);
      if (comparatorResult === false || comparatorResult === true) {
        memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
        return comparatorResult;
      }
      var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
      if (simpleResult !== null) {
        return simpleResult;
      }
    }
    var leftHandType = type2(leftHandOperand);
    if (leftHandType !== type2(rightHandOperand)) {
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
      return false;
    }
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
    var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
    return result;
  }
  __name(extensiveDeepEqual, "extensiveDeepEqual");
  function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
    switch (leftHandType) {
      case "String":
      case "Number":
      case "Boolean":
      case "Date":
        return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
      case "Promise":
      case "Symbol":
      case "function":
      case "WeakMap":
      case "WeakSet":
        return leftHandOperand === rightHandOperand;
      case "Error":
        return keysEqual(leftHandOperand, rightHandOperand, ["name", "message", "code"], options);
      case "Arguments":
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "Array":
        return iterableEqual(leftHandOperand, rightHandOperand, options);
      case "RegExp":
        return regexpEqual(leftHandOperand, rightHandOperand);
      case "Generator":
        return generatorEqual(leftHandOperand, rightHandOperand, options);
      case "DataView":
        return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
      case "ArrayBuffer":
        return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
      case "Set":
        return entriesEqual(leftHandOperand, rightHandOperand, options);
      case "Map":
        return entriesEqual(leftHandOperand, rightHandOperand, options);
      case "Temporal.PlainDate":
      case "Temporal.PlainTime":
      case "Temporal.PlainDateTime":
      case "Temporal.Instant":
      case "Temporal.ZonedDateTime":
      case "Temporal.PlainYearMonth":
      case "Temporal.PlainMonthDay":
        return leftHandOperand.equals(rightHandOperand);
      case "Temporal.Duration":
        return leftHandOperand.total("nanoseconds") === rightHandOperand.total("nanoseconds");
      case "Temporal.TimeZone":
      case "Temporal.Calendar":
        return leftHandOperand.toString() === rightHandOperand.toString();
      default:
        return objectEqual(leftHandOperand, rightHandOperand, options);
    }
  }
  __name(extensiveDeepEqualByType, "extensiveDeepEqualByType");
  function regexpEqual(leftHandOperand, rightHandOperand) {
    return leftHandOperand.toString() === rightHandOperand.toString();
  }
  __name(regexpEqual, "regexpEqual");
  function entriesEqual(leftHandOperand, rightHandOperand, options) {
    try {
      if (leftHandOperand.size !== rightHandOperand.size) {
        return false;
      }
      if (leftHandOperand.size === 0) {
        return true;
      }
    } catch (sizeError) {
      return false;
    }
    var leftHandItems = [];
    var rightHandItems = [];
    leftHandOperand.forEach(/* @__PURE__ */ __name(function gatherEntries(key, value) {
      leftHandItems.push([key, value]);
    }, "gatherEntries"));
    rightHandOperand.forEach(/* @__PURE__ */ __name(function gatherEntries(key, value) {
      rightHandItems.push([key, value]);
    }, "gatherEntries"));
    return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
  }
  __name(entriesEqual, "entriesEqual");
  function iterableEqual(leftHandOperand, rightHandOperand, options) {
    var length = leftHandOperand.length;
    if (length !== rightHandOperand.length) {
      return false;
    }
    if (length === 0) {
      return true;
    }
    var index = -1;
    while (++index < length) {
      if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
        return false;
      }
    }
    return true;
  }
  __name(iterableEqual, "iterableEqual");
  function generatorEqual(leftHandOperand, rightHandOperand, options) {
    return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
  }
  __name(generatorEqual, "generatorEqual");
  function hasIteratorFunction(target) {
    return typeof Symbol !== "undefined" && typeof target === "object" && typeof Symbol.iterator !== "undefined" && typeof target[Symbol.iterator] === "function";
  }
  __name(hasIteratorFunction, "hasIteratorFunction");
  function getIteratorEntries(target) {
    if (hasIteratorFunction(target)) {
      try {
        return getGeneratorEntries(target[Symbol.iterator]());
      } catch (iteratorError) {
        return [];
      }
    }
    return [];
  }
  __name(getIteratorEntries, "getIteratorEntries");
  function getGeneratorEntries(generator) {
    var generatorResult = generator.next();
    var accumulator = [generatorResult.value];
    while (generatorResult.done === false) {
      generatorResult = generator.next();
      accumulator.push(generatorResult.value);
    }
    return accumulator;
  }
  __name(getGeneratorEntries, "getGeneratorEntries");
  function getEnumerableKeys(target) {
    var keys = [];
    for (var key in target) {
      keys.push(key);
    }
    return keys;
  }
  __name(getEnumerableKeys, "getEnumerableKeys");
  function getEnumerableSymbols(target) {
    var keys = [];
    var allKeys = Object.getOwnPropertySymbols(target);
    for (var i = 0; i < allKeys.length; i += 1) {
      var key = allKeys[i];
      if (Object.getOwnPropertyDescriptor(target, key).enumerable) {
        keys.push(key);
      }
    }
    return keys;
  }
  __name(getEnumerableSymbols, "getEnumerableSymbols");
  function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
    var length = keys.length;
    if (length === 0) {
      return true;
    }
    for (var i = 0; i < length; i += 1) {
      if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
        return false;
      }
    }
    return true;
  }
  __name(keysEqual, "keysEqual");
  function objectEqual(leftHandOperand, rightHandOperand, options) {
    var leftHandKeys = getEnumerableKeys(leftHandOperand);
    var rightHandKeys = getEnumerableKeys(rightHandOperand);
    var leftHandSymbols = getEnumerableSymbols(leftHandOperand);
    var rightHandSymbols = getEnumerableSymbols(rightHandOperand);
    leftHandKeys = leftHandKeys.concat(leftHandSymbols);
    rightHandKeys = rightHandKeys.concat(rightHandSymbols);
    if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
      if (iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort()) === false) {
        return false;
      }
      return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
    }
    var leftHandEntries = getIteratorEntries(leftHandOperand);
    var rightHandEntries = getIteratorEntries(rightHandOperand);
    if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
      leftHandEntries.sort();
      rightHandEntries.sort();
      return iterableEqual(leftHandEntries, rightHandEntries, options);
    }
    if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
      return true;
    }
    return false;
  }
  __name(objectEqual, "objectEqual");
  function isPrimitive(value) {
    return value === null || typeof value !== "object";
  }
  __name(isPrimitive, "isPrimitive");
  function mapSymbols(arr) {
    return arr.map(/* @__PURE__ */ __name(function mapSymbol(entry) {
      if (typeof entry === "symbol") {
        return entry.toString();
      }
      return entry;
    }, "mapSymbol"));
  }
  __name(mapSymbols, "mapSymbols");
  function hasProperty(obj, name) {
    if (typeof obj === "undefined" || obj === null) {
      return false;
    }
    return name in Object(obj);
  }
  __name(hasProperty, "hasProperty");
  function parsePath(path) {
    const str = path.replace(/([^\\])\[/g, "$1.[");
    const parts = str.match(/(\\\.|[^.]+?)+/g);
    return parts.map((value) => {
      if (value === "constructor" || value === "__proto__" || value === "prototype") {
        return {};
      }
      const regexp = /^\[(\d+)\]$/;
      const mArr = regexp.exec(value);
      let parsed = null;
      if (mArr) {
        parsed = { i: parseFloat(mArr[1]) };
      } else {
        parsed = { p: value.replace(/\\([.[\]])/g, "$1") };
      }
      return parsed;
    });
  }
  __name(parsePath, "parsePath");
  function internalGetPathValue(obj, parsed, pathDepth) {
    let temporaryValue = obj;
    let res = null;
    pathDepth = typeof pathDepth === "undefined" ? parsed.length : pathDepth;
    for (let i = 0; i < pathDepth; i++) {
      const part = parsed[i];
      if (temporaryValue) {
        if (typeof part.p === "undefined") {
          temporaryValue = temporaryValue[part.i];
        } else {
          temporaryValue = temporaryValue[part.p];
        }
        if (i === pathDepth - 1) {
          res = temporaryValue;
        }
      }
    }
    return res;
  }
  __name(internalGetPathValue, "internalGetPathValue");
  function getPathInfo(obj, path) {
    const parsed = parsePath(path);
    const last = parsed[parsed.length - 1];
    const info = {
      parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
      name: last.p || last.i,
      value: internalGetPathValue(obj, parsed)
    };
    info.exists = hasProperty(info.parent, info.name);
    return info;
  }
  __name(getPathInfo, "getPathInfo");
  var Assertion = class _Assertion {
    static {
      __name(this, "Assertion");
    }
    /** @type {{}} */
    __flags = {};
    /**
     * Creates object for chaining.
     * `Assertion` objects contain metadata in the form of flags. Three flags can
     * be assigned during instantiation by passing arguments to this constructor:
     *
     * - `object`: This flag contains the target of the assertion. For example, in
     * the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
     * contain `numKittens` so that the `equal` assertion can reference it when
     * needed.
     *
     * - `message`: This flag contains an optional custom error message to be
     * prepended to the error message that's generated by the assertion when it
     * fails.
     *
     * - `ssfi`: This flag stands for "start stack function indicator". It
     * contains a function reference that serves as the starting point for
     * removing frames from the stack trace of the error that's created by the
     * assertion when it fails. The goal is to provide a cleaner stack trace to
     * end users by removing Chai's internal functions. Note that it only works
     * in environments that support `Error.captureStackTrace`, and only when
     * `Chai.config.includeStack` hasn't been set to `false`.
     *
     * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
     * should retain its current value, even as assertions are chained off of
     * this object. This is usually set to `true` when creating a new assertion
     * from within another assertion. It's also temporarily set to `true` before
     * an overwritten assertion gets called by the overwriting assertion.
     *
     * - `eql`: This flag contains the deepEqual function to be used by the assertion.
     *
     * @param {unknown} obj target of the assertion
     * @param {string} [msg] (optional) custom error message
     * @param {Function} [ssfi] (optional) starting point for removing stack frames
     * @param {boolean} [lockSsfi] (optional) whether or not the ssfi flag is locked
     */
    constructor(obj, msg, ssfi, lockSsfi) {
      flag(this, "ssfi", ssfi || _Assertion);
      flag(this, "lockSsfi", lockSsfi);
      flag(this, "object", obj);
      flag(this, "message", msg);
      flag(this, "eql", config.deepEqual || deep_eql_default);
      return proxify(this);
    }
    /** @returns {boolean} */
    static get includeStack() {
      console.warn(
        "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
      );
      return config.includeStack;
    }
    /** @param {boolean} value */
    static set includeStack(value) {
      console.warn(
        "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
      );
      config.includeStack = value;
    }
    /** @returns {boolean} */
    static get showDiff() {
      console.warn(
        "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
      );
      return config.showDiff;
    }
    /** @param {boolean} value */
    static set showDiff(value) {
      console.warn(
        "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
      );
      config.showDiff = value;
    }
    /**
     * @param {string} name
     * @param {Function} fn
     */
    static addProperty(name, fn) {
      addProperty(this.prototype, name, fn);
    }
    /**
     * @param {string} name
     * @param {Function} fn
     */
    static addMethod(name, fn) {
      addMethod(this.prototype, name, fn);
    }
    /**
     * @param {string} name
     * @param {Function} fn
     * @param {Function} chainingBehavior
     */
    static addChainableMethod(name, fn, chainingBehavior) {
      addChainableMethod(this.prototype, name, fn, chainingBehavior);
    }
    /**
     * @param {string} name
     * @param {Function} fn
     */
    static overwriteProperty(name, fn) {
      overwriteProperty(this.prototype, name, fn);
    }
    /**
     * @param {string} name
     * @param {Function} fn
     */
    static overwriteMethod(name, fn) {
      overwriteMethod(this.prototype, name, fn);
    }
    /**
     * @param {string} name
     * @param {Function} fn
     * @param {Function} chainingBehavior
     */
    static overwriteChainableMethod(name, fn, chainingBehavior) {
      overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
    }
    /**
     * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
     *
     * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
     *
     * @name assert
     * @param {unknown} _expr to be tested
     * @param {string | Function} msg or function that returns message to display if expression fails
     * @param {string | Function} _negateMsg or function that returns negatedMessage to display if negated expression fails
     * @param {unknown} expected value (remember to check for negation)
     * @param {unknown} _actual (optional) will default to `this.obj`
     * @param {boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
     * @returns {void}
     */
    assert(_expr, msg, _negateMsg, expected, _actual, showDiff) {
      const ok = test(this, arguments);
      if (false !== showDiff) showDiff = true;
      if (void 0 === expected && void 0 === _actual) showDiff = false;
      if (true !== config.showDiff) showDiff = false;
      if (!ok) {
        msg = getMessage2(this, arguments);
        const actual = getActual(this, arguments);
        const assertionErrorObjectProperties = {
          actual,
          expected,
          showDiff
        };
        const operator = getOperator(this, arguments);
        if (operator) {
          assertionErrorObjectProperties.operator = operator;
        }
        throw new AssertionError(
          msg,
          assertionErrorObjectProperties,
          // @ts-expect-error Not sure what to do about these types yet
          config.includeStack ? this.assert : flag(this, "ssfi")
        );
      }
    }
    /**
     * Quick reference to stored `actual` value for plugin developers.
     *
     * @returns {unknown}
     */
    get _obj() {
      return flag(this, "object");
    }
    /**
     * Quick reference to stored `actual` value for plugin developers.
     *
     * @param {unknown} val
     */
    set _obj(val) {
      flag(this, "object", val);
    }
  };
  function isProxyEnabled() {
    return config.useProxy && typeof Proxy !== "undefined" && typeof Reflect !== "undefined";
  }
  __name(isProxyEnabled, "isProxyEnabled");
  function addProperty(ctx, name, getter) {
    getter = getter === void 0 ? function() {
    } : getter;
    Object.defineProperty(ctx, name, {
      get: /* @__PURE__ */ __name(function propertyGetter() {
        if (!isProxyEnabled() && !flag(this, "lockSsfi")) {
          flag(this, "ssfi", propertyGetter);
        }
        let result = getter.call(this);
        if (result !== void 0) return result;
        let newAssertion = new Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      }, "propertyGetter"),
      configurable: true
    });
  }
  __name(addProperty, "addProperty");
  var fnLengthDesc = Object.getOwnPropertyDescriptor(function() {
  }, "length");
  function addLengthGuard(fn, assertionName, isChainable) {
    if (!fnLengthDesc.configurable) return fn;
    Object.defineProperty(fn, "length", {
      get: /* @__PURE__ */ __name(function() {
        if (isChainable) {
          throw Error(
            "Invalid Chai property: " + assertionName + '.length. Due to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.'
          );
        }
        throw Error(
          "Invalid Chai property: " + assertionName + '.length. See docs for proper usage of "' + assertionName + '".'
        );
      }, "get")
    });
    return fn;
  }
  __name(addLengthGuard, "addLengthGuard");
  function getProperties(object) {
    let result = Object.getOwnPropertyNames(object);
    function addProperty2(property) {
      if (result.indexOf(property) === -1) {
        result.push(property);
      }
    }
    __name(addProperty2, "addProperty");
    let proto = Object.getPrototypeOf(object);
    while (proto !== null) {
      Object.getOwnPropertyNames(proto).forEach(addProperty2);
      proto = Object.getPrototypeOf(proto);
    }
    return result;
  }
  __name(getProperties, "getProperties");
  var builtins = ["__flags", "__methods", "_obj", "assert"];
  function proxify(obj, nonChainableMethodName) {
    if (!isProxyEnabled()) return obj;
    return new Proxy(obj, {
      get: /* @__PURE__ */ __name(function proxyGetter(target, property) {
        if (typeof property === "string" && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
          if (nonChainableMethodName) {
            throw Error(
              "Invalid Chai property: " + nonChainableMethodName + "." + property + '. See docs for proper usage of "' + nonChainableMethodName + '".'
            );
          }
          let suggestion = null;
          let suggestionDistance = 4;
          getProperties(target).forEach(function(prop) {
            if (
              // we actually mean to check `Object.prototype` here
              // eslint-disable-next-line no-prototype-builtins
              !Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1
            ) {
              let dist = stringDistanceCapped(property, prop, suggestionDistance);
              if (dist < suggestionDistance) {
                suggestion = prop;
                suggestionDistance = dist;
              }
            }
          });
          if (suggestion !== null) {
            throw Error(
              "Invalid Chai property: " + property + '. Did you mean "' + suggestion + '"?'
            );
          } else {
            throw Error("Invalid Chai property: " + property);
          }
        }
        if (builtins.indexOf(property) === -1 && !flag(target, "lockSsfi")) {
          flag(target, "ssfi", proxyGetter);
        }
        return Reflect.get(target, property);
      }, "proxyGetter")
    });
  }
  __name(proxify, "proxify");
  function stringDistanceCapped(strA, strB, cap) {
    if (Math.abs(strA.length - strB.length) >= cap) {
      return cap;
    }
    let memo = [];
    for (let i = 0; i <= strA.length; i++) {
      memo[i] = Array(strB.length + 1).fill(0);
      memo[i][0] = i;
    }
    for (let j = 0; j < strB.length; j++) {
      memo[0][j] = j;
    }
    for (let i = 1; i <= strA.length; i++) {
      let ch = strA.charCodeAt(i - 1);
      for (let j = 1; j <= strB.length; j++) {
        if (Math.abs(i - j) >= cap) {
          memo[i][j] = cap;
          continue;
        }
        memo[i][j] = Math.min(
          memo[i - 1][j] + 1,
          memo[i][j - 1] + 1,
          memo[i - 1][j - 1] + (ch === strB.charCodeAt(j - 1) ? 0 : 1)
        );
      }
    }
    return memo[strA.length][strB.length];
  }
  __name(stringDistanceCapped, "stringDistanceCapped");
  function addMethod(ctx, name, method) {
    let methodWrapper = /* @__PURE__ */ __name(function() {
      if (!flag(this, "lockSsfi")) {
        flag(this, "ssfi", methodWrapper);
      }
      let result = method.apply(this, arguments);
      if (result !== void 0) return result;
      let newAssertion = new Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    }, "methodWrapper");
    addLengthGuard(methodWrapper, name, false);
    ctx[name] = proxify(methodWrapper, name);
  }
  __name(addMethod, "addMethod");
  function overwriteProperty(ctx, name, getter) {
    let _get = Object.getOwnPropertyDescriptor(ctx, name), _super = /* @__PURE__ */ __name(function() {
    }, "_super");
    if (_get && "function" === typeof _get.get) _super = _get.get;
    Object.defineProperty(ctx, name, {
      get: /* @__PURE__ */ __name(function overwritingPropertyGetter() {
        if (!isProxyEnabled() && !flag(this, "lockSsfi")) {
          flag(this, "ssfi", overwritingPropertyGetter);
        }
        let origLockSsfi = flag(this, "lockSsfi");
        flag(this, "lockSsfi", true);
        let result = getter(_super).call(this);
        flag(this, "lockSsfi", origLockSsfi);
        if (result !== void 0) {
          return result;
        }
        let newAssertion = new Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      }, "overwritingPropertyGetter"),
      configurable: true
    });
  }
  __name(overwriteProperty, "overwriteProperty");
  function overwriteMethod(ctx, name, method) {
    let _method = ctx[name], _super = /* @__PURE__ */ __name(function() {
      throw new Error(name + " is not a function");
    }, "_super");
    if (_method && "function" === typeof _method) _super = _method;
    let overwritingMethodWrapper = /* @__PURE__ */ __name(function() {
      if (!flag(this, "lockSsfi")) {
        flag(this, "ssfi", overwritingMethodWrapper);
      }
      let origLockSsfi = flag(this, "lockSsfi");
      flag(this, "lockSsfi", true);
      let result = method(_super).apply(this, arguments);
      flag(this, "lockSsfi", origLockSsfi);
      if (result !== void 0) {
        return result;
      }
      let newAssertion = new Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    }, "overwritingMethodWrapper");
    addLengthGuard(overwritingMethodWrapper, name, false);
    ctx[name] = proxify(overwritingMethodWrapper, name);
  }
  __name(overwriteMethod, "overwriteMethod");
  var canSetPrototype = typeof Object.setPrototypeOf === "function";
  var testFn = /* @__PURE__ */ __name(function() {
  }, "testFn");
  var excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
    let propDesc = Object.getOwnPropertyDescriptor(testFn, name);
    if (typeof propDesc !== "object") return true;
    return !propDesc.configurable;
  });
  var call = Function.prototype.call;
  var apply = Function.prototype.apply;
  function addChainableMethod(ctx, name, method, chainingBehavior) {
    if (typeof chainingBehavior !== "function") {
      chainingBehavior = /* @__PURE__ */ __name(function() {
      }, "chainingBehavior");
    }
    let chainableBehavior = {
      method,
      chainingBehavior
    };
    if (!ctx.__methods) {
      ctx.__methods = {};
    }
    ctx.__methods[name] = chainableBehavior;
    Object.defineProperty(ctx, name, {
      get: /* @__PURE__ */ __name(function chainableMethodGetter() {
        chainableBehavior.chainingBehavior.call(this);
        let chainableMethodWrapper = /* @__PURE__ */ __name(function() {
          if (!flag(this, "lockSsfi")) {
            flag(this, "ssfi", chainableMethodWrapper);
          }
          let result = chainableBehavior.method.apply(this, arguments);
          if (result !== void 0) {
            return result;
          }
          let newAssertion = new Assertion();
          transferFlags(this, newAssertion);
          return newAssertion;
        }, "chainableMethodWrapper");
        addLengthGuard(chainableMethodWrapper, name, true);
        if (canSetPrototype) {
          let prototype = Object.create(this);
          prototype.call = call;
          prototype.apply = apply;
          Object.setPrototypeOf(chainableMethodWrapper, prototype);
        } else {
          let asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function(asserterName) {
            if (excludeNames.indexOf(asserterName) !== -1) {
              return;
            }
            let pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
            Object.defineProperty(chainableMethodWrapper, asserterName, pd);
          });
        }
        transferFlags(this, chainableMethodWrapper);
        return proxify(chainableMethodWrapper);
      }, "chainableMethodGetter"),
      configurable: true
    });
  }
  __name(addChainableMethod, "addChainableMethod");
  function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
    let chainableBehavior = ctx.__methods[name];
    let _chainingBehavior = chainableBehavior.chainingBehavior;
    chainableBehavior.chainingBehavior = /* @__PURE__ */ __name(function overwritingChainableMethodGetter() {
      let result = chainingBehavior(_chainingBehavior).call(this);
      if (result !== void 0) {
        return result;
      }
      let newAssertion = new Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    }, "overwritingChainableMethodGetter");
    let _method = chainableBehavior.method;
    chainableBehavior.method = /* @__PURE__ */ __name(function overwritingChainableMethodWrapper() {
      let result = method(_method).apply(this, arguments);
      if (result !== void 0) {
        return result;
      }
      let newAssertion = new Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    }, "overwritingChainableMethodWrapper");
  }
  __name(overwriteChainableMethod, "overwriteChainableMethod");
  function compareByInspect(a, b) {
    return inspect2(a) < inspect2(b) ? -1 : 1;
  }
  __name(compareByInspect, "compareByInspect");
  function getOwnEnumerablePropertySymbols(obj) {
    if (typeof Object.getOwnPropertySymbols !== "function") return [];
    return Object.getOwnPropertySymbols(obj).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
    });
  }
  __name(getOwnEnumerablePropertySymbols, "getOwnEnumerablePropertySymbols");
  function getOwnEnumerableProperties(obj) {
    return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
  }
  __name(getOwnEnumerableProperties, "getOwnEnumerableProperties");
  var isNaN22 = Number.isNaN;
  function isObjectType(obj) {
    let objectType = type(obj);
    let objectTypes = ["Array", "Object", "Function"];
    return objectTypes.indexOf(objectType) !== -1;
  }
  __name(isObjectType, "isObjectType");
  function getOperator(obj, args) {
    let operator = flag(obj, "operator");
    let negate = flag(obj, "negate");
    let expected = args[3];
    let msg = negate ? args[2] : args[1];
    if (operator) {
      return operator;
    }
    if (typeof msg === "function") msg = msg();
    msg = msg || "";
    if (!msg) {
      return void 0;
    }
    if (/\shave\s/.test(msg)) {
      return void 0;
    }
    let isObject2 = isObjectType(expected);
    if (/\snot\s/.test(msg)) {
      return isObject2 ? "notDeepStrictEqual" : "notStrictEqual";
    }
    return isObject2 ? "deepStrictEqual" : "strictEqual";
  }
  __name(getOperator, "getOperator");
  function getName(fn) {
    return fn.name;
  }
  __name(getName, "getName");
  function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  }
  __name(isRegExp2, "isRegExp");
  function isNumeric(obj) {
    return ["Number", "BigInt"].includes(type(obj));
  }
  __name(isNumeric, "isNumeric");
  var { flag: flag2 } = utils_exports;
  [
    "to",
    "be",
    "been",
    "is",
    "and",
    "has",
    "have",
    "with",
    "that",
    "which",
    "at",
    "of",
    "same",
    "but",
    "does",
    "still",
    "also"
  ].forEach(function(chain) {
    Assertion.addProperty(chain);
  });
  Assertion.addProperty("not", function() {
    flag2(this, "negate", true);
  });
  Assertion.addProperty("deep", function() {
    flag2(this, "deep", true);
  });
  Assertion.addProperty("nested", function() {
    flag2(this, "nested", true);
  });
  Assertion.addProperty("own", function() {
    flag2(this, "own", true);
  });
  Assertion.addProperty("ordered", function() {
    flag2(this, "ordered", true);
  });
  Assertion.addProperty("any", function() {
    flag2(this, "any", true);
    flag2(this, "all", false);
  });
  Assertion.addProperty("all", function() {
    flag2(this, "all", true);
    flag2(this, "any", false);
  });
  var functionTypes = {
    function: [
      "function",
      "asyncfunction",
      "generatorfunction",
      "asyncgeneratorfunction"
    ],
    asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
    generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
    asyncgeneratorfunction: ["asyncgeneratorfunction"]
  };
  function an(type3, msg) {
    if (msg) flag2(this, "message", msg);
    type3 = type3.toLowerCase();
    let obj = flag2(this, "object"), article = ~["a", "e", "i", "o", "u"].indexOf(type3.charAt(0)) ? "an " : "a ";
    const detectedType = type(obj).toLowerCase();
    if (functionTypes["function"].includes(type3)) {
      this.assert(
        functionTypes[type3].includes(detectedType),
        "expected #{this} to be " + article + type3,
        "expected #{this} not to be " + article + type3
      );
    } else {
      this.assert(
        type3 === detectedType,
        "expected #{this} to be " + article + type3,
        "expected #{this} not to be " + article + type3
      );
    }
  }
  __name(an, "an");
  Assertion.addChainableMethod("an", an);
  Assertion.addChainableMethod("a", an);
  function SameValueZero(a, b) {
    return isNaN22(a) && isNaN22(b) || a === b;
  }
  __name(SameValueZero, "SameValueZero");
  function includeChainingBehavior() {
    flag2(this, "contains", true);
  }
  __name(includeChainingBehavior, "includeChainingBehavior");
  function include(val, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), negate = flag2(this, "negate"), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), descriptor = isDeep ? "deep " : "", isEql = isDeep ? flag2(this, "eql") : SameValueZero;
    flagMsg = flagMsg ? flagMsg + ": " : "";
    let included = false;
    switch (objType) {
      case "string":
        included = obj.indexOf(val) !== -1;
        break;
      case "weakset":
        if (isDeep) {
          throw new AssertionError(
            flagMsg + "unable to use .deep.include with WeakSet",
            void 0,
            ssfi
          );
        }
        included = obj.has(val);
        break;
      case "map":
        obj.forEach(function(item) {
          included = included || isEql(item, val);
        });
        break;
      case "set":
        if (isDeep) {
          obj.forEach(function(item) {
            included = included || isEql(item, val);
          });
        } else {
          included = obj.has(val);
        }
        break;
      case "array":
        if (isDeep) {
          included = obj.some(function(item) {
            return isEql(item, val);
          });
        } else {
          included = obj.indexOf(val) !== -1;
        }
        break;
      default: {
        if (val !== Object(val)) {
          throw new AssertionError(
            flagMsg + "the given combination of arguments (" + objType + " and " + type(val).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + type(val).toLowerCase(),
            void 0,
            ssfi
          );
        }
        let props = Object.keys(val);
        let firstErr = null;
        let numErrs = 0;
        props.forEach(function(prop) {
          let propAssertion = new Assertion(obj);
          transferFlags(this, propAssertion, true);
          flag2(propAssertion, "lockSsfi", true);
          if (!negate || props.length === 1) {
            propAssertion.property(prop, val[prop]);
            return;
          }
          try {
            propAssertion.property(prop, val[prop]);
          } catch (err) {
            if (!check_error_exports.compatibleConstructor(err, AssertionError)) {
              throw err;
            }
            if (firstErr === null) firstErr = err;
            numErrs++;
          }
        }, this);
        if (negate && props.length > 1 && numErrs === props.length) {
          throw firstErr;
        }
        return;
      }
    }
    this.assert(
      included,
      "expected #{this} to " + descriptor + "include " + inspect2(val),
      "expected #{this} to not " + descriptor + "include " + inspect2(val)
    );
  }
  __name(include, "include");
  Assertion.addChainableMethod("include", include, includeChainingBehavior);
  Assertion.addChainableMethod("contain", include, includeChainingBehavior);
  Assertion.addChainableMethod("contains", include, includeChainingBehavior);
  Assertion.addChainableMethod("includes", include, includeChainingBehavior);
  Assertion.addProperty("ok", function() {
    this.assert(
      flag2(this, "object"),
      "expected #{this} to be truthy",
      "expected #{this} to be falsy"
    );
  });
  Assertion.addProperty("true", function() {
    this.assert(
      true === flag2(this, "object"),
      "expected #{this} to be true",
      "expected #{this} to be false",
      flag2(this, "negate") ? false : true
    );
  });
  Assertion.addProperty("numeric", function() {
    const object = flag2(this, "object");
    this.assert(
      ["Number", "BigInt"].includes(type(object)),
      "expected #{this} to be numeric",
      "expected #{this} to not be numeric",
      flag2(this, "negate") ? false : true
    );
  });
  Assertion.addProperty("callable", function() {
    const val = flag2(this, "object");
    const ssfi = flag2(this, "ssfi");
    const message = flag2(this, "message");
    const msg = message ? `${message}: ` : "";
    const negate = flag2(this, "negate");
    const assertionMessage = negate ? `${msg}expected ${inspect2(val)} not to be a callable function` : `${msg}expected ${inspect2(val)} to be a callable function`;
    const isCallable2 = [
      "Function",
      "AsyncFunction",
      "GeneratorFunction",
      "AsyncGeneratorFunction"
    ].includes(type(val));
    if (isCallable2 && negate || !isCallable2 && !negate) {
      throw new AssertionError(assertionMessage, void 0, ssfi);
    }
  });
  Assertion.addProperty("false", function() {
    this.assert(
      false === flag2(this, "object"),
      "expected #{this} to be false",
      "expected #{this} to be true",
      flag2(this, "negate") ? true : false
    );
  });
  Assertion.addProperty("null", function() {
    this.assert(
      null === flag2(this, "object"),
      "expected #{this} to be null",
      "expected #{this} not to be null"
    );
  });
  Assertion.addProperty("undefined", function() {
    this.assert(
      void 0 === flag2(this, "object"),
      "expected #{this} to be undefined",
      "expected #{this} not to be undefined"
    );
  });
  Assertion.addProperty("NaN", function() {
    this.assert(
      isNaN22(flag2(this, "object")),
      "expected #{this} to be NaN",
      "expected #{this} not to be NaN"
    );
  });
  function assertExist() {
    let val = flag2(this, "object");
    this.assert(
      val !== null && val !== void 0,
      "expected #{this} to exist",
      "expected #{this} to not exist"
    );
  }
  __name(assertExist, "assertExist");
  Assertion.addProperty("exist", assertExist);
  Assertion.addProperty("exists", assertExist);
  Assertion.addProperty("empty", function() {
    let val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), itemsCount;
    flagMsg = flagMsg ? flagMsg + ": " : "";
    switch (type(val).toLowerCase()) {
      case "array":
      case "string":
        itemsCount = val.length;
        break;
      case "map":
      case "set":
        itemsCount = val.size;
        break;
      case "weakmap":
      case "weakset":
        throw new AssertionError(
          flagMsg + ".empty was passed a weak collection",
          void 0,
          ssfi
        );
      case "function": {
        const msg = flagMsg + ".empty was passed a function " + getName(val);
        throw new AssertionError(msg.trim(), void 0, ssfi);
      }
      default:
        if (val !== Object(val)) {
          throw new AssertionError(
            flagMsg + ".empty was passed non-string primitive " + inspect2(val),
            void 0,
            ssfi
          );
        }
        itemsCount = Object.keys(val).length;
    }
    this.assert(
      0 === itemsCount,
      "expected #{this} to be empty",
      "expected #{this} not to be empty"
    );
  });
  function checkArguments() {
    let obj = flag2(this, "object"), type3 = type(obj);
    this.assert(
      "Arguments" === type3,
      "expected #{this} to be arguments but got " + type3,
      "expected #{this} to not be arguments"
    );
  }
  __name(checkArguments, "checkArguments");
  Assertion.addProperty("arguments", checkArguments);
  Assertion.addProperty("Arguments", checkArguments);
  function assertEqual(val, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object");
    if (flag2(this, "deep")) {
      let prevLockSsfi = flag2(this, "lockSsfi");
      flag2(this, "lockSsfi", true);
      this.eql(val);
      flag2(this, "lockSsfi", prevLockSsfi);
    } else {
      this.assert(
        val === obj,
        "expected #{this} to equal #{exp}",
        "expected #{this} to not equal #{exp}",
        val,
        this._obj,
        true
      );
    }
  }
  __name(assertEqual, "assertEqual");
  Assertion.addMethod("equal", assertEqual);
  Assertion.addMethod("equals", assertEqual);
  Assertion.addMethod("eq", assertEqual);
  function assertEql(obj, msg) {
    if (msg) flag2(this, "message", msg);
    let eql = flag2(this, "eql");
    this.assert(
      eql(obj, flag2(this, "object")),
      "expected #{this} to deeply equal #{exp}",
      "expected #{this} to not deeply equal #{exp}",
      obj,
      this._obj,
      true
    );
  }
  __name(assertEql, "assertEql");
  Assertion.addMethod("eql", assertEql);
  Assertion.addMethod("eqls", assertEql);
  function assertAbove(n, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n).toLowerCase();
    if (doLength && objType !== "map" && objType !== "set") {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
    }
    if (!doLength && objType === "date" && nType !== "date") {
      throw new AssertionError(
        msgPrefix + "the argument to above must be a date",
        void 0,
        ssfi
      );
    } else if (!isNumeric(n) && (doLength || isNumeric(obj))) {
      throw new AssertionError(
        msgPrefix + "the argument to above must be a number",
        void 0,
        ssfi
      );
    } else if (!doLength && objType !== "date" && !isNumeric(obj)) {
      let printObj = objType === "string" ? "'" + obj + "'" : obj;
      throw new AssertionError(
        msgPrefix + "expected " + printObj + " to be a number or a date",
        void 0,
        ssfi
      );
    }
    if (doLength) {
      let descriptor = "length", itemsCount;
      if (objType === "map" || objType === "set") {
        descriptor = "size";
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
        itemsCount > n,
        "expected #{this} to have a " + descriptor + " above #{exp} but got #{act}",
        "expected #{this} to not have a " + descriptor + " above #{exp}",
        n,
        itemsCount
      );
    } else {
      this.assert(
        obj > n,
        "expected #{this} to be above #{exp}",
        "expected #{this} to be at most #{exp}",
        n
      );
    }
  }
  __name(assertAbove, "assertAbove");
  Assertion.addMethod("above", assertAbove);
  Assertion.addMethod("gt", assertAbove);
  Assertion.addMethod("greaterThan", assertAbove);
  function assertLeast(n, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n).toLowerCase(), errorMessage, shouldThrow = true;
    if (doLength && objType !== "map" && objType !== "set") {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
    }
    if (!doLength && objType === "date" && nType !== "date") {
      errorMessage = msgPrefix + "the argument to least must be a date";
    } else if (!isNumeric(n) && (doLength || isNumeric(obj))) {
      errorMessage = msgPrefix + "the argument to least must be a number";
    } else if (!doLength && objType !== "date" && !isNumeric(obj)) {
      let printObj = objType === "string" ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
    } else {
      shouldThrow = false;
    }
    if (shouldThrow) {
      throw new AssertionError(errorMessage, void 0, ssfi);
    }
    if (doLength) {
      let descriptor = "length", itemsCount;
      if (objType === "map" || objType === "set") {
        descriptor = "size";
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
        itemsCount >= n,
        "expected #{this} to have a " + descriptor + " at least #{exp} but got #{act}",
        "expected #{this} to have a " + descriptor + " below #{exp}",
        n,
        itemsCount
      );
    } else {
      this.assert(
        obj >= n,
        "expected #{this} to be at least #{exp}",
        "expected #{this} to be below #{exp}",
        n
      );
    }
  }
  __name(assertLeast, "assertLeast");
  Assertion.addMethod("least", assertLeast);
  Assertion.addMethod("gte", assertLeast);
  Assertion.addMethod("greaterThanOrEqual", assertLeast);
  function assertBelow(n, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n).toLowerCase(), errorMessage, shouldThrow = true;
    if (doLength && objType !== "map" && objType !== "set") {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
    }
    if (!doLength && objType === "date" && nType !== "date") {
      errorMessage = msgPrefix + "the argument to below must be a date";
    } else if (!isNumeric(n) && (doLength || isNumeric(obj))) {
      errorMessage = msgPrefix + "the argument to below must be a number";
    } else if (!doLength && objType !== "date" && !isNumeric(obj)) {
      let printObj = objType === "string" ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
    } else {
      shouldThrow = false;
    }
    if (shouldThrow) {
      throw new AssertionError(errorMessage, void 0, ssfi);
    }
    if (doLength) {
      let descriptor = "length", itemsCount;
      if (objType === "map" || objType === "set") {
        descriptor = "size";
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
        itemsCount < n,
        "expected #{this} to have a " + descriptor + " below #{exp} but got #{act}",
        "expected #{this} to not have a " + descriptor + " below #{exp}",
        n,
        itemsCount
      );
    } else {
      this.assert(
        obj < n,
        "expected #{this} to be below #{exp}",
        "expected #{this} to be at least #{exp}",
        n
      );
    }
  }
  __name(assertBelow, "assertBelow");
  Assertion.addMethod("below", assertBelow);
  Assertion.addMethod("lt", assertBelow);
  Assertion.addMethod("lessThan", assertBelow);
  function assertMost(n, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n).toLowerCase(), errorMessage, shouldThrow = true;
    if (doLength && objType !== "map" && objType !== "set") {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
    }
    if (!doLength && objType === "date" && nType !== "date") {
      errorMessage = msgPrefix + "the argument to most must be a date";
    } else if (!isNumeric(n) && (doLength || isNumeric(obj))) {
      errorMessage = msgPrefix + "the argument to most must be a number";
    } else if (!doLength && objType !== "date" && !isNumeric(obj)) {
      let printObj = objType === "string" ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
    } else {
      shouldThrow = false;
    }
    if (shouldThrow) {
      throw new AssertionError(errorMessage, void 0, ssfi);
    }
    if (doLength) {
      let descriptor = "length", itemsCount;
      if (objType === "map" || objType === "set") {
        descriptor = "size";
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
        itemsCount <= n,
        "expected #{this} to have a " + descriptor + " at most #{exp} but got #{act}",
        "expected #{this} to have a " + descriptor + " above #{exp}",
        n,
        itemsCount
      );
    } else {
      this.assert(
        obj <= n,
        "expected #{this} to be at most #{exp}",
        "expected #{this} to be above #{exp}",
        n
      );
    }
  }
  __name(assertMost, "assertMost");
  Assertion.addMethod("most", assertMost);
  Assertion.addMethod("lte", assertMost);
  Assertion.addMethod("lessThanOrEqual", assertMost);
  Assertion.addMethod("within", function(start, finish, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), startType = type(start).toLowerCase(), finishType = type(finish).toLowerCase(), errorMessage, shouldThrow = true, range = startType === "date" && finishType === "date" ? start.toISOString() + ".." + finish.toISOString() : start + ".." + finish;
    if (doLength && objType !== "map" && objType !== "set") {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
    }
    if (!doLength && objType === "date" && (startType !== "date" || finishType !== "date")) {
      errorMessage = msgPrefix + "the arguments to within must be dates";
    } else if ((!isNumeric(start) || !isNumeric(finish)) && (doLength || isNumeric(obj))) {
      errorMessage = msgPrefix + "the arguments to within must be numbers";
    } else if (!doLength && objType !== "date" && !isNumeric(obj)) {
      let printObj = objType === "string" ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
    } else {
      shouldThrow = false;
    }
    if (shouldThrow) {
      throw new AssertionError(errorMessage, void 0, ssfi);
    }
    if (doLength) {
      let descriptor = "length", itemsCount;
      if (objType === "map" || objType === "set") {
        descriptor = "size";
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
        itemsCount >= start && itemsCount <= finish,
        "expected #{this} to have a " + descriptor + " within " + range,
        "expected #{this} to not have a " + descriptor + " within " + range
      );
    } else {
      this.assert(
        obj >= start && obj <= finish,
        "expected #{this} to be within " + range,
        "expected #{this} to not be within " + range
      );
    }
  });
  function assertInstanceOf(constructor, msg) {
    if (msg) flag2(this, "message", msg);
    let target = flag2(this, "object");
    let ssfi = flag2(this, "ssfi");
    let flagMsg = flag2(this, "message");
    let isInstanceOf;
    try {
      isInstanceOf = target instanceof constructor;
    } catch (err) {
      if (err instanceof TypeError) {
        flagMsg = flagMsg ? flagMsg + ": " : "";
        throw new AssertionError(
          flagMsg + "The instanceof assertion needs a constructor but " + type(constructor) + " was given.",
          void 0,
          ssfi
        );
      }
      throw err;
    }
    let name = getName(constructor);
    if (name == null) {
      name = "an unnamed constructor";
    }
    this.assert(
      isInstanceOf,
      "expected #{this} to be an instance of " + name,
      "expected #{this} to not be an instance of " + name
    );
  }
  __name(assertInstanceOf, "assertInstanceOf");
  Assertion.addMethod("instanceof", assertInstanceOf);
  Assertion.addMethod("instanceOf", assertInstanceOf);
  function assertProperty(name, val, msg) {
    if (msg) flag2(this, "message", msg);
    let isNested = flag2(this, "nested"), isOwn = flag2(this, "own"), flagMsg = flag2(this, "message"), obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), nameType = typeof name;
    flagMsg = flagMsg ? flagMsg + ": " : "";
    if (isNested) {
      if (nameType !== "string") {
        throw new AssertionError(
          flagMsg + "the argument to property must be a string when using nested syntax",
          void 0,
          ssfi
        );
      }
    } else {
      if (nameType !== "string" && nameType !== "number" && nameType !== "symbol") {
        throw new AssertionError(
          flagMsg + "the argument to property must be a string, number, or symbol",
          void 0,
          ssfi
        );
      }
    }
    if (isNested && isOwn) {
      throw new AssertionError(
        flagMsg + 'The "nested" and "own" flags cannot be combined.',
        void 0,
        ssfi
      );
    }
    if (obj === null || obj === void 0) {
      throw new AssertionError(
        flagMsg + "Target cannot be null or undefined.",
        void 0,
        ssfi
      );
    }
    let isDeep = flag2(this, "deep"), negate = flag2(this, "negate"), pathInfo = isNested ? getPathInfo(obj, name) : null, value = isNested ? pathInfo.value : obj[name], isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
    let descriptor = "";
    if (isDeep) descriptor += "deep ";
    if (isOwn) descriptor += "own ";
    if (isNested) descriptor += "nested ";
    descriptor += "property ";
    let hasProperty2;
    if (isOwn) hasProperty2 = Object.prototype.hasOwnProperty.call(obj, name);
    else if (isNested) hasProperty2 = pathInfo.exists;
    else hasProperty2 = hasProperty(obj, name);
    if (!negate || arguments.length === 1) {
      this.assert(
        hasProperty2,
        "expected #{this} to have " + descriptor + inspect2(name),
        "expected #{this} to not have " + descriptor + inspect2(name)
      );
    }
    if (arguments.length > 1) {
      this.assert(
        hasProperty2 && isEql(val, value),
        "expected #{this} to have " + descriptor + inspect2(name) + " of #{exp}, but got #{act}",
        "expected #{this} to not have " + descriptor + inspect2(name) + " of #{act}",
        val,
        value
      );
    }
    flag2(this, "object", value);
  }
  __name(assertProperty, "assertProperty");
  Assertion.addMethod("property", assertProperty);
  function assertOwnProperty(_name, _value, _msg) {
    flag2(this, "own", true);
    assertProperty.apply(this, arguments);
  }
  __name(assertOwnProperty, "assertOwnProperty");
  Assertion.addMethod("ownProperty", assertOwnProperty);
  Assertion.addMethod("haveOwnProperty", assertOwnProperty);
  function assertOwnPropertyDescriptor(name, descriptor, msg) {
    if (typeof descriptor === "string") {
      msg = descriptor;
      descriptor = null;
    }
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object");
    let actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
    let eql = flag2(this, "eql");
    if (actualDescriptor && descriptor) {
      this.assert(
        eql(descriptor, actualDescriptor),
        "expected the own property descriptor for " + inspect2(name) + " on #{this} to match " + inspect2(descriptor) + ", got " + inspect2(actualDescriptor),
        "expected the own property descriptor for " + inspect2(name) + " on #{this} to not match " + inspect2(descriptor),
        descriptor,
        actualDescriptor,
        true
      );
    } else {
      this.assert(
        actualDescriptor,
        "expected #{this} to have an own property descriptor for " + inspect2(name),
        "expected #{this} to not have an own property descriptor for " + inspect2(name)
      );
    }
    flag2(this, "object", actualDescriptor);
  }
  __name(assertOwnPropertyDescriptor, "assertOwnPropertyDescriptor");
  Assertion.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
  Assertion.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);
  function assertLengthChain() {
    flag2(this, "doLength", true);
  }
  __name(assertLengthChain, "assertLengthChain");
  function assertLength(n, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), descriptor = "length", itemsCount;
    switch (objType) {
      case "map":
      case "set":
        descriptor = "size";
        itemsCount = obj.size;
        break;
      default:
        new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
        itemsCount = obj.length;
    }
    this.assert(
      itemsCount == n,
      "expected #{this} to have a " + descriptor + " of #{exp} but got #{act}",
      "expected #{this} to not have a " + descriptor + " of #{act}",
      n,
      itemsCount
    );
  }
  __name(assertLength, "assertLength");
  Assertion.addChainableMethod("length", assertLength, assertLengthChain);
  Assertion.addChainableMethod("lengthOf", assertLength, assertLengthChain);
  function assertMatch(re, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object");
    this.assert(
      re.exec(obj),
      "expected #{this} to match " + re,
      "expected #{this} not to match " + re
    );
  }
  __name(assertMatch, "assertMatch");
  Assertion.addMethod("match", assertMatch);
  Assertion.addMethod("matches", assertMatch);
  Assertion.addMethod("string", function(str, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
    new Assertion(obj, flagMsg, ssfi, true).is.a("string");
    this.assert(
      ~obj.indexOf(str),
      "expected #{this} to contain " + inspect2(str),
      "expected #{this} to not contain " + inspect2(str)
    );
  });
  function assertKeys(keys) {
    let obj = flag2(this, "object"), objType = type(obj), keysType = type(keys), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), str, deepStr = "", actual, ok = true, flagMsg = flag2(this, "message");
    flagMsg = flagMsg ? flagMsg + ": " : "";
    let mixedArgsMsg = flagMsg + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
    if (objType === "Map" || objType === "Set") {
      deepStr = isDeep ? "deeply " : "";
      actual = [];
      obj.forEach(function(val, key) {
        actual.push(key);
      });
      if (keysType !== "Array") {
        keys = Array.prototype.slice.call(arguments);
      }
    } else {
      actual = getOwnEnumerableProperties(obj);
      switch (keysType) {
        case "Array":
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, void 0, ssfi);
          }
          break;
        case "Object":
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, void 0, ssfi);
          }
          keys = Object.keys(keys);
          break;
        default:
          keys = Array.prototype.slice.call(arguments);
      }
      keys = keys.map(function(val) {
        return typeof val === "symbol" ? val : String(val);
      });
    }
    if (!keys.length) {
      throw new AssertionError(flagMsg + "keys required", void 0, ssfi);
    }
    let len = keys.length, any = flag2(this, "any"), all = flag2(this, "all"), expected = keys, isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
    if (!any && !all) {
      all = true;
    }
    if (any) {
      ok = expected.some(function(expectedKey) {
        return actual.some(function(actualKey) {
          return isEql(expectedKey, actualKey);
        });
      });
    }
    if (all) {
      ok = expected.every(function(expectedKey) {
        return actual.some(function(actualKey) {
          return isEql(expectedKey, actualKey);
        });
      });
      if (!flag2(this, "contains")) {
        ok = ok && keys.length == actual.length;
      }
    }
    if (len > 1) {
      keys = keys.map(function(key) {
        return inspect2(key);
      });
      let last = keys.pop();
      if (all) {
        str = keys.join(", ") + ", and " + last;
      }
      if (any) {
        str = keys.join(", ") + ", or " + last;
      }
    } else {
      str = inspect2(keys[0]);
    }
    str = (len > 1 ? "keys " : "key ") + str;
    str = (flag2(this, "contains") ? "contain " : "have ") + str;
    this.assert(
      ok,
      "expected #{this} to " + deepStr + str,
      "expected #{this} to not " + deepStr + str,
      expected.slice(0).sort(compareByInspect),
      actual.sort(compareByInspect),
      true
    );
  }
  __name(assertKeys, "assertKeys");
  Assertion.addMethod("keys", assertKeys);
  Assertion.addMethod("key", assertKeys);
  function assertThrows(errorLike, errMsgMatcher, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), negate = flag2(this, "negate") || false;
    new Assertion(obj, flagMsg, ssfi, true).is.a("function");
    if (isRegExp2(errorLike) || typeof errorLike === "string") {
      errMsgMatcher = errorLike;
      errorLike = null;
    }
    let caughtErr;
    let errorWasThrown = false;
    try {
      obj();
    } catch (err) {
      errorWasThrown = true;
      caughtErr = err;
    }
    let everyArgIsUndefined = errorLike === void 0 && errMsgMatcher === void 0;
    let everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
    let errorLikeFail = false;
    let errMsgMatcherFail = false;
    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
      let errorLikeString = "an error";
      if (errorLike instanceof Error) {
        errorLikeString = "#{exp}";
      } else if (errorLike) {
        errorLikeString = check_error_exports.getConstructorName(errorLike);
      }
      let actual = caughtErr;
      if (caughtErr instanceof Error) {
        actual = caughtErr.toString();
      } else if (typeof caughtErr === "string") {
        actual = caughtErr;
      } else if (caughtErr && (typeof caughtErr === "object" || typeof caughtErr === "function")) {
        try {
          actual = check_error_exports.getConstructorName(caughtErr);
        } catch (_err) {
        }
      }
      this.assert(
        errorWasThrown,
        "expected #{this} to throw " + errorLikeString,
        "expected #{this} to not throw an error but #{act} was thrown",
        errorLike && errorLike.toString(),
        actual
      );
    }
    if (errorLike && caughtErr) {
      if (errorLike instanceof Error) {
        let isCompatibleInstance = check_error_exports.compatibleInstance(
          caughtErr,
          errorLike
        );
        if (isCompatibleInstance === negate) {
          if (everyArgIsDefined && negate) {
            errorLikeFail = true;
          } else {
            this.assert(
              negate,
              "expected #{this} to throw #{exp} but #{act} was thrown",
              "expected #{this} to not throw #{exp}" + (caughtErr && !negate ? " but #{act} was thrown" : ""),
              errorLike.toString(),
              caughtErr.toString()
            );
          }
        }
      }
      let isCompatibleConstructor = check_error_exports.compatibleConstructor(
        caughtErr,
        errorLike
      );
      if (isCompatibleConstructor === negate) {
        if (everyArgIsDefined && negate) {
          errorLikeFail = true;
        } else {
          this.assert(
            negate,
            "expected #{this} to throw #{exp} but #{act} was thrown",
            "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
            errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
            caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
          );
        }
      }
    }
    if (caughtErr && errMsgMatcher !== void 0 && errMsgMatcher !== null) {
      let placeholder = "including";
      if (isRegExp2(errMsgMatcher)) {
        placeholder = "matching";
      }
      let isCompatibleMessage = check_error_exports.compatibleMessage(
        caughtErr,
        errMsgMatcher
      );
      if (isCompatibleMessage === negate) {
        if (everyArgIsDefined && negate) {
          errMsgMatcherFail = true;
        } else {
          this.assert(
            negate,
            "expected #{this} to throw error " + placeholder + " #{exp} but got #{act}",
            "expected #{this} to throw error not " + placeholder + " #{exp}",
            errMsgMatcher,
            check_error_exports.getMessage(caughtErr)
          );
        }
      }
    }
    if (errorLikeFail && errMsgMatcherFail) {
      this.assert(
        negate,
        "expected #{this} to throw #{exp} but #{act} was thrown",
        "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
        errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
        caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
      );
    }
    flag2(this, "object", caughtErr);
  }
  __name(assertThrows, "assertThrows");
  Assertion.addMethod("throw", assertThrows);
  Assertion.addMethod("throws", assertThrows);
  Assertion.addMethod("Throw", assertThrows);
  function respondTo(method, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), itself = flag2(this, "itself"), context = "function" === typeof obj && !itself ? obj.prototype[method] : obj[method];
    this.assert(
      "function" === typeof context,
      "expected #{this} to respond to " + inspect2(method),
      "expected #{this} to not respond to " + inspect2(method)
    );
  }
  __name(respondTo, "respondTo");
  Assertion.addMethod("respondTo", respondTo);
  Assertion.addMethod("respondsTo", respondTo);
  Assertion.addProperty("itself", function() {
    flag2(this, "itself", true);
  });
  function satisfy(matcher, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object");
    let result = matcher(obj);
    this.assert(
      result,
      "expected #{this} to satisfy " + objDisplay(matcher),
      "expected #{this} to not satisfy" + objDisplay(matcher),
      flag2(this, "negate") ? false : true,
      result
    );
  }
  __name(satisfy, "satisfy");
  Assertion.addMethod("satisfy", satisfy);
  Assertion.addMethod("satisfies", satisfy);
  function closeTo(expected, delta, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
    new Assertion(obj, flagMsg, ssfi, true).is.numeric;
    let message = "A `delta` value is required for `closeTo`";
    if (delta == void 0) {
      throw new AssertionError(
        flagMsg ? `${flagMsg}: ${message}` : message,
        void 0,
        ssfi
      );
    }
    new Assertion(delta, flagMsg, ssfi, true).is.numeric;
    message = "A `expected` value is required for `closeTo`";
    if (expected == void 0) {
      throw new AssertionError(
        flagMsg ? `${flagMsg}: ${message}` : message,
        void 0,
        ssfi
      );
    }
    new Assertion(expected, flagMsg, ssfi, true).is.numeric;
    const abs = /* @__PURE__ */ __name((x) => x < 0n ? -x : x, "abs");
    const strip = /* @__PURE__ */ __name((number) => parseFloat(parseFloat(number).toPrecision(12)), "strip");
    this.assert(
      strip(abs(obj - expected)) <= delta,
      "expected #{this} to be close to " + expected + " +/- " + delta,
      "expected #{this} not to be close to " + expected + " +/- " + delta
    );
  }
  __name(closeTo, "closeTo");
  Assertion.addMethod("closeTo", closeTo);
  Assertion.addMethod("approximately", closeTo);
  function isSubsetOf(_subset, _superset, cmp, contains, ordered) {
    let superset = Array.from(_superset);
    let subset = Array.from(_subset);
    if (!contains) {
      if (subset.length !== superset.length) return false;
      superset = superset.slice();
    }
    return subset.every(function(elem, idx) {
      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
      if (!cmp) {
        let matchIdx = superset.indexOf(elem);
        if (matchIdx === -1) return false;
        if (!contains) superset.splice(matchIdx, 1);
        return true;
      }
      return superset.some(function(elem2, matchIdx) {
        if (!cmp(elem, elem2)) return false;
        if (!contains) superset.splice(matchIdx, 1);
        return true;
      });
    });
  }
  __name(isSubsetOf, "isSubsetOf");
  Assertion.addMethod("members", function(subset, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
    new Assertion(obj, flagMsg, ssfi, true).to.be.iterable;
    new Assertion(subset, flagMsg, ssfi, true).to.be.iterable;
    let contains = flag2(this, "contains");
    let ordered = flag2(this, "ordered");
    let subject, failMsg, failNegateMsg;
    if (contains) {
      subject = ordered ? "an ordered superset" : "a superset";
      failMsg = "expected #{this} to be " + subject + " of #{exp}";
      failNegateMsg = "expected #{this} to not be " + subject + " of #{exp}";
    } else {
      subject = ordered ? "ordered members" : "members";
      failMsg = "expected #{this} to have the same " + subject + " as #{exp}";
      failNegateMsg = "expected #{this} to not have the same " + subject + " as #{exp}";
    }
    let cmp = flag2(this, "deep") ? flag2(this, "eql") : void 0;
    this.assert(
      isSubsetOf(subset, obj, cmp, contains, ordered),
      failMsg,
      failNegateMsg,
      subset,
      obj,
      true
    );
  });
  Assertion.addProperty("iterable", function(msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object");
    this.assert(
      obj != void 0 && obj[Symbol.iterator],
      "expected #{this} to be an iterable",
      "expected #{this} to not be an iterable",
      obj
    );
  });
  function oneOf(list, msg) {
    if (msg) flag2(this, "message", msg);
    let expected = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), contains = flag2(this, "contains"), isDeep = flag2(this, "deep"), eql = flag2(this, "eql");
    new Assertion(list, flagMsg, ssfi, true).to.be.an("array");
    if (contains) {
      this.assert(
        list.some(function(possibility) {
          return expected.indexOf(possibility) > -1;
        }),
        "expected #{this} to contain one of #{exp}",
        "expected #{this} to not contain one of #{exp}",
        list,
        expected
      );
    } else {
      if (isDeep) {
        this.assert(
          list.some(function(possibility) {
            return eql(expected, possibility);
          }),
          "expected #{this} to deeply equal one of #{exp}",
          "expected #{this} to deeply equal one of #{exp}",
          list,
          expected
        );
      } else {
        this.assert(
          list.indexOf(expected) > -1,
          "expected #{this} to be one of #{exp}",
          "expected #{this} to not be one of #{exp}",
          list,
          expected
        );
      }
    }
  }
  __name(oneOf, "oneOf");
  Assertion.addMethod("oneOf", oneOf);
  function assertChanges(subject, prop, msg) {
    if (msg) flag2(this, "message", msg);
    let fn = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
    new Assertion(fn, flagMsg, ssfi, true).is.a("function");
    let initial;
    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a("function");
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }
    fn();
    let final = prop === void 0 || prop === null ? subject() : subject[prop];
    let msgObj = prop === void 0 || prop === null ? initial : "." + prop;
    flag2(this, "deltaMsgObj", msgObj);
    flag2(this, "initialDeltaValue", initial);
    flag2(this, "finalDeltaValue", final);
    flag2(this, "deltaBehavior", "change");
    flag2(this, "realDelta", final !== initial);
    this.assert(
      initial !== final,
      "expected " + msgObj + " to change",
      "expected " + msgObj + " to not change"
    );
  }
  __name(assertChanges, "assertChanges");
  Assertion.addMethod("change", assertChanges);
  Assertion.addMethod("changes", assertChanges);
  function assertIncreases(subject, prop, msg) {
    if (msg) flag2(this, "message", msg);
    let fn = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
    new Assertion(fn, flagMsg, ssfi, true).is.a("function");
    let initial;
    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a("function");
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }
    new Assertion(initial, flagMsg, ssfi, true).is.a("number");
    fn();
    let final = prop === void 0 || prop === null ? subject() : subject[prop];
    let msgObj = prop === void 0 || prop === null ? initial : "." + prop;
    flag2(this, "deltaMsgObj", msgObj);
    flag2(this, "initialDeltaValue", initial);
    flag2(this, "finalDeltaValue", final);
    flag2(this, "deltaBehavior", "increase");
    flag2(this, "realDelta", final - initial);
    this.assert(
      final - initial > 0,
      "expected " + msgObj + " to increase",
      "expected " + msgObj + " to not increase"
    );
  }
  __name(assertIncreases, "assertIncreases");
  Assertion.addMethod("increase", assertIncreases);
  Assertion.addMethod("increases", assertIncreases);
  function assertDecreases(subject, prop, msg) {
    if (msg) flag2(this, "message", msg);
    let fn = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
    new Assertion(fn, flagMsg, ssfi, true).is.a("function");
    let initial;
    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a("function");
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }
    new Assertion(initial, flagMsg, ssfi, true).is.a("number");
    fn();
    let final = prop === void 0 || prop === null ? subject() : subject[prop];
    let msgObj = prop === void 0 || prop === null ? initial : "." + prop;
    flag2(this, "deltaMsgObj", msgObj);
    flag2(this, "initialDeltaValue", initial);
    flag2(this, "finalDeltaValue", final);
    flag2(this, "deltaBehavior", "decrease");
    flag2(this, "realDelta", initial - final);
    this.assert(
      final - initial < 0,
      "expected " + msgObj + " to decrease",
      "expected " + msgObj + " to not decrease"
    );
  }
  __name(assertDecreases, "assertDecreases");
  Assertion.addMethod("decrease", assertDecreases);
  Assertion.addMethod("decreases", assertDecreases);
  function assertDelta(delta, msg) {
    if (msg) flag2(this, "message", msg);
    let msgObj = flag2(this, "deltaMsgObj");
    let initial = flag2(this, "initialDeltaValue");
    let final = flag2(this, "finalDeltaValue");
    let behavior = flag2(this, "deltaBehavior");
    let realDelta = flag2(this, "realDelta");
    let expression;
    if (behavior === "change") {
      expression = Math.abs(final - initial) === Math.abs(delta);
    } else {
      expression = realDelta === Math.abs(delta);
    }
    this.assert(
      expression,
      "expected " + msgObj + " to " + behavior + " by " + delta,
      "expected " + msgObj + " to not " + behavior + " by " + delta
    );
  }
  __name(assertDelta, "assertDelta");
  Assertion.addMethod("by", assertDelta);
  Assertion.addProperty("extensible", function() {
    let obj = flag2(this, "object");
    let isExtensible = obj === Object(obj) && Object.isExtensible(obj);
    this.assert(
      isExtensible,
      "expected #{this} to be extensible",
      "expected #{this} to not be extensible"
    );
  });
  Assertion.addProperty("sealed", function() {
    let obj = flag2(this, "object");
    let isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
    this.assert(
      isSealed,
      "expected #{this} to be sealed",
      "expected #{this} to not be sealed"
    );
  });
  Assertion.addProperty("frozen", function() {
    let obj = flag2(this, "object");
    let isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
    this.assert(
      isFrozen,
      "expected #{this} to be frozen",
      "expected #{this} to not be frozen"
    );
  });
  Assertion.addProperty("finite", function(_msg) {
    let obj = flag2(this, "object");
    this.assert(
      typeof obj === "number" && isFinite(obj),
      "expected #{this} to be a finite number",
      "expected #{this} to not be a finite number"
    );
  });
  function compareSubset(expected, actual) {
    if (expected === actual) {
      return true;
    }
    if (typeof actual !== typeof expected) {
      return false;
    }
    if (typeof expected !== "object" || expected === null) {
      return expected === actual;
    }
    if (!actual) {
      return false;
    }
    if (Array.isArray(expected)) {
      if (!Array.isArray(actual)) {
        return false;
      }
      return expected.every(function(exp) {
        return actual.some(function(act) {
          return compareSubset(exp, act);
        });
      });
    }
    if (expected instanceof Date) {
      if (actual instanceof Date) {
        return expected.getTime() === actual.getTime();
      } else {
        return false;
      }
    }
    return Object.keys(expected).every(function(key) {
      let expectedValue = expected[key];
      let actualValue = actual[key];
      if (typeof expectedValue === "object" && expectedValue !== null && actualValue !== null) {
        return compareSubset(expectedValue, actualValue);
      }
      if (typeof expectedValue === "function") {
        return expectedValue(actualValue);
      }
      return actualValue === expectedValue;
    });
  }
  __name(compareSubset, "compareSubset");
  Assertion.addMethod("containSubset", function(expected) {
    const actual = flag(this, "object");
    const showDiff = config.showDiff;
    this.assert(
      compareSubset(expected, actual),
      "expected #{act} to contain subset #{exp}",
      "expected #{act} to not contain subset #{exp}",
      expected,
      actual,
      showDiff
    );
  });
  function expect(val, message) {
    return new Assertion(val, message);
  }
  __name(expect, "expect");
  expect.fail = function(actual, expected, message, operator) {
    if (arguments.length < 2) {
      message = actual;
      actual = void 0;
    }
    message = message || "expect.fail()";
    throw new AssertionError(
      message,
      {
        actual,
        expected,
        operator
      },
      expect.fail
    );
  };
  var should_exports = {};
  __export2(should_exports, {
    Should: () => Should,
    should: () => should
  });
  function loadShould() {
    function shouldGetter() {
      if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === "function" && this instanceof Symbol || typeof BigInt === "function" && this instanceof BigInt) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    __name(shouldGetter, "shouldGetter");
    function shouldSetter(value) {
      Object.defineProperty(this, "should", {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    __name(shouldSetter, "shouldSetter");
    Object.defineProperty(Object.prototype, "should", {
      set: shouldSetter,
      get: shouldGetter,
      configurable: true
    });
    let should2 = {};
    should2.fail = function(actual, expected, message, operator) {
      if (arguments.length < 2) {
        message = actual;
        actual = void 0;
      }
      message = message || "should.fail()";
      throw new AssertionError(
        message,
        {
          actual,
          expected,
          operator
        },
        should2.fail
      );
    };
    should2.equal = function(actual, expected, message) {
      new Assertion(actual, message).to.equal(expected);
    };
    should2.Throw = function(fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };
    should2.exist = function(val, msg) {
      new Assertion(val, msg).to.exist;
    };
    should2.not = {};
    should2.not.equal = function(actual, expected, msg) {
      new Assertion(actual, msg).to.not.equal(expected);
    };
    should2.not.Throw = function(fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };
    should2.not.exist = function(val, msg) {
      new Assertion(val, msg).to.not.exist;
    };
    should2["throw"] = should2["Throw"];
    should2.not["throw"] = should2.not["Throw"];
    return should2;
  }
  __name(loadShould, "loadShould");
  var should = loadShould;
  var Should = loadShould;
  function assert(express, errmsg) {
    let test2 = new Assertion(null, null, assert, true);
    test2.assert(express, errmsg, "[ negation message unavailable ]");
  }
  __name(assert, "assert");
  assert.fail = function(actual, expected, message, operator) {
    if (arguments.length < 2) {
      message = actual;
      actual = void 0;
    }
    message = message || "assert.fail()";
    throw new AssertionError(
      message,
      {
        actual,
        expected,
        operator
      },
      assert.fail
    );
  };
  assert.isOk = function(val, msg) {
    new Assertion(val, msg, assert.isOk, true).is.ok;
  };
  assert.isNotOk = function(val, msg) {
    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
  };
  assert.equal = function(act, exp, msg) {
    let test2 = new Assertion(act, msg, assert.equal, true);
    test2.assert(
      exp == flag(test2, "object"),
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{act}",
      exp,
      act,
      true
    );
  };
  assert.notEqual = function(act, exp, msg) {
    let test2 = new Assertion(act, msg, assert.notEqual, true);
    test2.assert(
      exp != flag(test2, "object"),
      "expected #{this} to not equal #{exp}",
      "expected #{this} to equal #{act}",
      exp,
      act,
      true
    );
  };
  assert.strictEqual = function(act, exp, msg) {
    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
  };
  assert.notStrictEqual = function(act, exp, msg) {
    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
  };
  assert.deepEqual = assert.deepStrictEqual = function(act, exp, msg) {
    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
  };
  assert.notDeepEqual = function(act, exp, msg) {
    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
  };
  assert.isAbove = function(val, abv, msg) {
    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
  };
  assert.isAtLeast = function(val, atlst, msg) {
    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
  };
  assert.isBelow = function(val, blw, msg) {
    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
  };
  assert.isAtMost = function(val, atmst, msg) {
    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
  };
  assert.isTrue = function(val, msg) {
    new Assertion(val, msg, assert.isTrue, true).is["true"];
  };
  assert.isNotTrue = function(val, msg) {
    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
  };
  assert.isFalse = function(val, msg) {
    new Assertion(val, msg, assert.isFalse, true).is["false"];
  };
  assert.isNotFalse = function(val, msg) {
    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
  };
  assert.isNull = function(val, msg) {
    new Assertion(val, msg, assert.isNull, true).to.equal(null);
  };
  assert.isNotNull = function(val, msg) {
    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
  };
  assert.isNaN = function(val, msg) {
    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
  };
  assert.isNotNaN = function(value, message) {
    new Assertion(value, message, assert.isNotNaN, true).not.to.be.NaN;
  };
  assert.exists = function(val, msg) {
    new Assertion(val, msg, assert.exists, true).to.exist;
  };
  assert.notExists = function(val, msg) {
    new Assertion(val, msg, assert.notExists, true).to.not.exist;
  };
  assert.isUndefined = function(val, msg) {
    new Assertion(val, msg, assert.isUndefined, true).to.equal(void 0);
  };
  assert.isDefined = function(val, msg) {
    new Assertion(val, msg, assert.isDefined, true).to.not.equal(void 0);
  };
  assert.isCallable = function(value, message) {
    new Assertion(value, message, assert.isCallable, true).is.callable;
  };
  assert.isNotCallable = function(value, message) {
    new Assertion(value, message, assert.isNotCallable, true).is.not.callable;
  };
  assert.isObject = function(val, msg) {
    new Assertion(val, msg, assert.isObject, true).to.be.a("object");
  };
  assert.isNotObject = function(val, msg) {
    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a("object");
  };
  assert.isArray = function(val, msg) {
    new Assertion(val, msg, assert.isArray, true).to.be.an("array");
  };
  assert.isNotArray = function(val, msg) {
    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an("array");
  };
  assert.isString = function(val, msg) {
    new Assertion(val, msg, assert.isString, true).to.be.a("string");
  };
  assert.isNotString = function(val, msg) {
    new Assertion(val, msg, assert.isNotString, true).to.not.be.a("string");
  };
  assert.isNumber = function(val, msg) {
    new Assertion(val, msg, assert.isNumber, true).to.be.a("number");
  };
  assert.isNotNumber = function(val, msg) {
    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a("number");
  };
  assert.isNumeric = function(val, msg) {
    new Assertion(val, msg, assert.isNumeric, true).is.numeric;
  };
  assert.isNotNumeric = function(val, msg) {
    new Assertion(val, msg, assert.isNotNumeric, true).is.not.numeric;
  };
  assert.isFinite = function(val, msg) {
    new Assertion(val, msg, assert.isFinite, true).to.be.finite;
  };
  assert.isBoolean = function(val, msg) {
    new Assertion(val, msg, assert.isBoolean, true).to.be.a("boolean");
  };
  assert.isNotBoolean = function(val, msg) {
    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a("boolean");
  };
  assert.typeOf = function(val, type3, msg) {
    new Assertion(val, msg, assert.typeOf, true).to.be.a(type3);
  };
  assert.notTypeOf = function(value, type3, message) {
    new Assertion(value, message, assert.notTypeOf, true).to.not.be.a(type3);
  };
  assert.instanceOf = function(val, type3, msg) {
    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type3);
  };
  assert.notInstanceOf = function(val, type3, msg) {
    new Assertion(val, msg, assert.notInstanceOf, true).to.not.be.instanceOf(
      type3
    );
  };
  assert.include = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.include, true).include(inc);
  };
  assert.notInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
  };
  assert.deepInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
  };
  assert.notDeepInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
  };
  assert.nestedInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
  };
  assert.notNestedInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.notNestedInclude, true).not.nested.include(
      inc
    );
  };
  assert.deepNestedInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.deepNestedInclude, true).deep.nested.include(
      inc
    );
  };
  assert.notDeepNestedInclude = function(exp, inc, msg) {
    new Assertion(
      exp,
      msg,
      assert.notDeepNestedInclude,
      true
    ).not.deep.nested.include(inc);
  };
  assert.ownInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
  };
  assert.notOwnInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
  };
  assert.deepOwnInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.deepOwnInclude, true).deep.own.include(inc);
  };
  assert.notDeepOwnInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepOwnInclude, true).not.deep.own.include(
      inc
    );
  };
  assert.match = function(exp, re, msg) {
    new Assertion(exp, msg, assert.match, true).to.match(re);
  };
  assert.notMatch = function(exp, re, msg) {
    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);
  };
  assert.property = function(obj, prop, msg) {
    new Assertion(obj, msg, assert.property, true).to.have.property(prop);
  };
  assert.notProperty = function(obj, prop, msg) {
    new Assertion(obj, msg, assert.notProperty, true).to.not.have.property(prop);
  };
  assert.propertyVal = function(obj, prop, val, msg) {
    new Assertion(obj, msg, assert.propertyVal, true).to.have.property(prop, val);
  };
  assert.notPropertyVal = function(obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notPropertyVal, true).to.not.have.property(
      prop,
      val
    );
  };
  assert.deepPropertyVal = function(obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepPropertyVal, true).to.have.deep.property(
      prop,
      val
    );
  };
  assert.notDeepPropertyVal = function(obj, prop, val, msg) {
    new Assertion(
      obj,
      msg,
      assert.notDeepPropertyVal,
      true
    ).to.not.have.deep.property(prop, val);
  };
  assert.ownProperty = function(obj, prop, msg) {
    new Assertion(obj, msg, assert.ownProperty, true).to.have.own.property(prop);
  };
  assert.notOwnProperty = function(obj, prop, msg) {
    new Assertion(obj, msg, assert.notOwnProperty, true).to.not.have.own.property(
      prop
    );
  };
  assert.ownPropertyVal = function(obj, prop, value, msg) {
    new Assertion(obj, msg, assert.ownPropertyVal, true).to.have.own.property(
      prop,
      value
    );
  };
  assert.notOwnPropertyVal = function(obj, prop, value, msg) {
    new Assertion(
      obj,
      msg,
      assert.notOwnPropertyVal,
      true
    ).to.not.have.own.property(prop, value);
  };
  assert.deepOwnPropertyVal = function(obj, prop, value, msg) {
    new Assertion(
      obj,
      msg,
      assert.deepOwnPropertyVal,
      true
    ).to.have.deep.own.property(prop, value);
  };
  assert.notDeepOwnPropertyVal = function(obj, prop, value, msg) {
    new Assertion(
      obj,
      msg,
      assert.notDeepOwnPropertyVal,
      true
    ).to.not.have.deep.own.property(prop, value);
  };
  assert.nestedProperty = function(obj, prop, msg) {
    new Assertion(obj, msg, assert.nestedProperty, true).to.have.nested.property(
      prop
    );
  };
  assert.notNestedProperty = function(obj, prop, msg) {
    new Assertion(
      obj,
      msg,
      assert.notNestedProperty,
      true
    ).to.not.have.nested.property(prop);
  };
  assert.nestedPropertyVal = function(obj, prop, val, msg) {
    new Assertion(
      obj,
      msg,
      assert.nestedPropertyVal,
      true
    ).to.have.nested.property(prop, val);
  };
  assert.notNestedPropertyVal = function(obj, prop, val, msg) {
    new Assertion(
      obj,
      msg,
      assert.notNestedPropertyVal,
      true
    ).to.not.have.nested.property(prop, val);
  };
  assert.deepNestedPropertyVal = function(obj, prop, val, msg) {
    new Assertion(
      obj,
      msg,
      assert.deepNestedPropertyVal,
      true
    ).to.have.deep.nested.property(prop, val);
  };
  assert.notDeepNestedPropertyVal = function(obj, prop, val, msg) {
    new Assertion(
      obj,
      msg,
      assert.notDeepNestedPropertyVal,
      true
    ).to.not.have.deep.nested.property(prop, val);
  };
  assert.lengthOf = function(exp, len, msg) {
    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
  };
  assert.hasAnyKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);
  };
  assert.hasAllKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);
  };
  assert.containsAllKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllKeys, true).to.contain.all.keys(
      keys
    );
  };
  assert.doesNotHaveAnyKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(
      keys
    );
  };
  assert.doesNotHaveAllKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true).to.not.have.all.keys(
      keys
    );
  };
  assert.hasAnyDeepKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyDeepKeys, true).to.have.any.deep.keys(
      keys
    );
  };
  assert.hasAllDeepKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllDeepKeys, true).to.have.all.deep.keys(
      keys
    );
  };
  assert.containsAllDeepKeys = function(obj, keys, msg) {
    new Assertion(
      obj,
      msg,
      assert.containsAllDeepKeys,
      true
    ).to.contain.all.deep.keys(keys);
  };
  assert.doesNotHaveAnyDeepKeys = function(obj, keys, msg) {
    new Assertion(
      obj,
      msg,
      assert.doesNotHaveAnyDeepKeys,
      true
    ).to.not.have.any.deep.keys(keys);
  };
  assert.doesNotHaveAllDeepKeys = function(obj, keys, msg) {
    new Assertion(
      obj,
      msg,
      assert.doesNotHaveAllDeepKeys,
      true
    ).to.not.have.all.deep.keys(keys);
  };
  assert.throws = function(fn, errorLike, errMsgMatcher, msg) {
    if ("string" === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }
    let assertErr = new Assertion(fn, msg, assert.throws, true).to.throw(
      errorLike,
      errMsgMatcher
    );
    return flag(assertErr, "object");
  };
  assert.doesNotThrow = function(fn, errorLike, errMsgMatcher, message) {
    if ("string" === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }
    new Assertion(fn, message, assert.doesNotThrow, true).to.not.throw(
      errorLike,
      errMsgMatcher
    );
  };
  assert.operator = function(val, operator, val2, msg) {
    let ok;
    switch (operator) {
      case "==":
        ok = val == val2;
        break;
      case "===":
        ok = val === val2;
        break;
      case ">":
        ok = val > val2;
        break;
      case ">=":
        ok = val >= val2;
        break;
      case "<":
        ok = val < val2;
        break;
      case "<=":
        ok = val <= val2;
        break;
      case "!=":
        ok = val != val2;
        break;
      case "!==":
        ok = val !== val2;
        break;
      default:
        msg = msg ? msg + ": " : msg;
        throw new AssertionError(
          msg + 'Invalid operator "' + operator + '"',
          void 0,
          assert.operator
        );
    }
    let test2 = new Assertion(ok, msg, assert.operator, true);
    test2.assert(
      true === flag(test2, "object"),
      "expected " + inspect2(val) + " to be " + operator + " " + inspect2(val2),
      "expected " + inspect2(val) + " to not be " + operator + " " + inspect2(val2)
    );
  };
  assert.closeTo = function(act, exp, delta, msg) {
    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
  };
  assert.approximately = function(act, exp, delta, msg) {
    new Assertion(act, msg, assert.approximately, true).to.be.approximately(
      exp,
      delta
    );
  };
  assert.sameMembers = function(set1, set2, msg) {
    new Assertion(set1, msg, assert.sameMembers, true).to.have.same.members(set2);
  };
  assert.notSameMembers = function(set1, set2, msg) {
    new Assertion(
      set1,
      msg,
      assert.notSameMembers,
      true
    ).to.not.have.same.members(set2);
  };
  assert.sameDeepMembers = function(set1, set2, msg) {
    new Assertion(
      set1,
      msg,
      assert.sameDeepMembers,
      true
    ).to.have.same.deep.members(set2);
  };
  assert.notSameDeepMembers = function(set1, set2, msg) {
    new Assertion(
      set1,
      msg,
      assert.notSameDeepMembers,
      true
    ).to.not.have.same.deep.members(set2);
  };
  assert.sameOrderedMembers = function(set1, set2, msg) {
    new Assertion(
      set1,
      msg,
      assert.sameOrderedMembers,
      true
    ).to.have.same.ordered.members(set2);
  };
  assert.notSameOrderedMembers = function(set1, set2, msg) {
    new Assertion(
      set1,
      msg,
      assert.notSameOrderedMembers,
      true
    ).to.not.have.same.ordered.members(set2);
  };
  assert.sameDeepOrderedMembers = function(set1, set2, msg) {
    new Assertion(
      set1,
      msg,
      assert.sameDeepOrderedMembers,
      true
    ).to.have.same.deep.ordered.members(set2);
  };
  assert.notSameDeepOrderedMembers = function(set1, set2, msg) {
    new Assertion(
      set1,
      msg,
      assert.notSameDeepOrderedMembers,
      true
    ).to.not.have.same.deep.ordered.members(set2);
  };
  assert.includeMembers = function(superset, subset, msg) {
    new Assertion(superset, msg, assert.includeMembers, true).to.include.members(
      subset
    );
  };
  assert.notIncludeMembers = function(superset, subset, msg) {
    new Assertion(
      superset,
      msg,
      assert.notIncludeMembers,
      true
    ).to.not.include.members(subset);
  };
  assert.includeDeepMembers = function(superset, subset, msg) {
    new Assertion(
      superset,
      msg,
      assert.includeDeepMembers,
      true
    ).to.include.deep.members(subset);
  };
  assert.notIncludeDeepMembers = function(superset, subset, msg) {
    new Assertion(
      superset,
      msg,
      assert.notIncludeDeepMembers,
      true
    ).to.not.include.deep.members(subset);
  };
  assert.includeOrderedMembers = function(superset, subset, msg) {
    new Assertion(
      superset,
      msg,
      assert.includeOrderedMembers,
      true
    ).to.include.ordered.members(subset);
  };
  assert.notIncludeOrderedMembers = function(superset, subset, msg) {
    new Assertion(
      superset,
      msg,
      assert.notIncludeOrderedMembers,
      true
    ).to.not.include.ordered.members(subset);
  };
  assert.includeDeepOrderedMembers = function(superset, subset, msg) {
    new Assertion(
      superset,
      msg,
      assert.includeDeepOrderedMembers,
      true
    ).to.include.deep.ordered.members(subset);
  };
  assert.notIncludeDeepOrderedMembers = function(superset, subset, msg) {
    new Assertion(
      superset,
      msg,
      assert.notIncludeDeepOrderedMembers,
      true
    ).to.not.include.deep.ordered.members(subset);
  };
  assert.oneOf = function(inList, list, msg) {
    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
  };
  assert.isIterable = function(obj, msg) {
    if (obj == void 0 || !obj[Symbol.iterator]) {
      msg = msg ? `${msg} expected ${inspect2(obj)} to be an iterable` : `expected ${inspect2(obj)} to be an iterable`;
      throw new AssertionError(msg, void 0, assert.isIterable);
    }
  };
  assert.changes = function(fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === "function") {
      msg = prop;
      prop = null;
    }
    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);
  };
  assert.changesBy = function(fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === "function") {
      let tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }
    new Assertion(fn, msg, assert.changesBy, true).to.change(obj, prop).by(delta);
  };
  assert.doesNotChange = function(fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === "function") {
      msg = prop;
      prop = null;
    }
    return new Assertion(fn, msg, assert.doesNotChange, true).to.not.change(
      obj,
      prop
    );
  };
  assert.changesButNotBy = function(fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === "function") {
      let tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }
    new Assertion(fn, msg, assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
  };
  assert.increases = function(fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === "function") {
      msg = prop;
      prop = null;
    }
    return new Assertion(fn, msg, assert.increases, true).to.increase(obj, prop);
  };
  assert.increasesBy = function(fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === "function") {
      let tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }
    new Assertion(fn, msg, assert.increasesBy, true).to.increase(obj, prop).by(delta);
  };
  assert.doesNotIncrease = function(fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === "function") {
      msg = prop;
      prop = null;
    }
    return new Assertion(fn, msg, assert.doesNotIncrease, true).to.not.increase(
      obj,
      prop
    );
  };
  assert.increasesButNotBy = function(fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === "function") {
      let tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }
    new Assertion(fn, msg, assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
  };
  assert.decreases = function(fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === "function") {
      msg = prop;
      prop = null;
    }
    return new Assertion(fn, msg, assert.decreases, true).to.decrease(obj, prop);
  };
  assert.decreasesBy = function(fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === "function") {
      let tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }
    new Assertion(fn, msg, assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
  };
  assert.doesNotDecrease = function(fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === "function") {
      msg = prop;
      prop = null;
    }
    return new Assertion(fn, msg, assert.doesNotDecrease, true).to.not.decrease(
      obj,
      prop
    );
  };
  assert.doesNotDecreaseBy = function(fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === "function") {
      let tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }
    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
  };
  assert.decreasesButNotBy = function(fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === "function") {
      let tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }
    new Assertion(fn, msg, assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
  };
  assert.ifError = function(val) {
    if (val) {
      throw val;
    }
  };
  assert.isExtensible = function(obj, msg) {
    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
  };
  assert.isNotExtensible = function(obj, msg) {
    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
  };
  assert.isSealed = function(obj, msg) {
    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
  };
  assert.isNotSealed = function(obj, msg) {
    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
  };
  assert.isFrozen = function(obj, msg) {
    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
  };
  assert.isNotFrozen = function(obj, msg) {
    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
  };
  assert.isEmpty = function(val, msg) {
    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
  };
  assert.isNotEmpty = function(val, msg) {
    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
  };
  assert.containsSubset = function(val, exp, msg) {
    new Assertion(val, msg).to.containSubset(exp);
  };
  assert.doesNotContainSubset = function(val, exp, msg) {
    new Assertion(val, msg).to.not.containSubset(exp);
  };
  var aliases = [
    ["isOk", "ok"],
    ["isNotOk", "notOk"],
    ["throws", "throw"],
    ["throws", "Throw"],
    ["isExtensible", "extensible"],
    ["isNotExtensible", "notExtensible"],
    ["isSealed", "sealed"],
    ["isNotSealed", "notSealed"],
    ["isFrozen", "frozen"],
    ["isNotFrozen", "notFrozen"],
    ["isEmpty", "empty"],
    ["isNotEmpty", "notEmpty"],
    ["isCallable", "isFunction"],
    ["isNotCallable", "isNotFunction"],
    ["containsSubset", "containSubset"]
  ];
  for (const [name, as] of aliases) {
    assert[as] = assert[name];
  }
  var used = [];
  function use(fn) {
    const exports = {
      use,
      AssertionError,
      util: utils_exports,
      config,
      expect,
      assert,
      Assertion,
      ...should_exports
    };
    if (!~used.indexOf(fn)) {
      fn(exports, utils_exports);
      used.push(fn);
    }
    return exports;
  }
  __name(use, "use");

  // tests/runner.ts
  var import_mocha7 = __toESM(require_mocha());

  // node_modules/.pnpm/@testing-library+dom@10.4.1/node_modules/@testing-library/dom/dist/@testing-library/dom.esm.js
  var prettyFormat = __toESM(require_build());

  // node_modules/.pnpm/dom-accessibility-api@0.5.16/node_modules/dom-accessibility-api/dist/polyfills/array.from.mjs
  var toStr = Object.prototype.toString;
  function isCallable(fn) {
    return typeof fn === "function" || toStr.call(fn) === "[object Function]";
  }
  function toInteger(value) {
    var number = Number(value);
    if (isNaN(number)) {
      return 0;
    }
    if (number === 0 || !isFinite(number)) {
      return number;
    }
    return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
  }
  var maxSafeInteger = Math.pow(2, 53) - 1;
  function toLength(value) {
    var len = toInteger(value);
    return Math.min(Math.max(len, 0), maxSafeInteger);
  }
  function arrayFrom(arrayLike, mapFn) {
    var C = Array;
    var items = Object(arrayLike);
    if (arrayLike == null) {
      throw new TypeError("Array.from requires an array-like object - not null or undefined");
    }
    if (typeof mapFn !== "undefined") {
      if (!isCallable(mapFn)) {
        throw new TypeError("Array.from: when provided, the second argument must be a function");
      }
    }
    var len = toLength(items.length);
    var A = isCallable(C) ? Object(new C(len)) : new Array(len);
    var k = 0;
    var kValue;
    while (k < len) {
      kValue = items[k];
      if (mapFn) {
        A[k] = mapFn(kValue, k);
      } else {
        A[k] = kValue;
      }
      k += 1;
    }
    A.length = len;
    return A;
  }

  // node_modules/.pnpm/dom-accessibility-api@0.5.16/node_modules/dom-accessibility-api/dist/polyfills/SetLike.mjs
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var SetLike = /* @__PURE__ */ (function() {
    function SetLike2() {
      var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      _classCallCheck(this, SetLike2);
      _defineProperty(this, "items", void 0);
      this.items = items;
    }
    _createClass(SetLike2, [{
      key: "add",
      value: function add(value) {
        if (this.has(value) === false) {
          this.items.push(value);
        }
        return this;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.items = [];
      }
    }, {
      key: "delete",
      value: function _delete(value) {
        var previousLength = this.items.length;
        this.items = this.items.filter(function(item) {
          return item !== value;
        });
        return previousLength !== this.items.length;
      }
    }, {
      key: "forEach",
      value: function forEach(callbackfn) {
        var _this = this;
        this.items.forEach(function(item) {
          callbackfn(item, item, _this);
        });
      }
    }, {
      key: "has",
      value: function has(value) {
        return this.items.indexOf(value) !== -1;
      }
    }, {
      key: "size",
      get: function get2() {
        return this.items.length;
      }
    }]);
    return SetLike2;
  })();
  var SetLike_default = typeof Set === "undefined" ? Set : SetLike;

  // node_modules/.pnpm/dom-accessibility-api@0.5.16/node_modules/dom-accessibility-api/dist/getRole.mjs
  function getLocalName(element) {
    var _element$localName;
    return (
      // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
      (_element$localName = element.localName) !== null && _element$localName !== void 0 ? _element$localName : (
        // eslint-disable-next-line no-restricted-properties -- required for the fallback
        element.tagName.toLowerCase()
      )
    );
  }
  var localNameToRoleMappings = {
    article: "article",
    aside: "complementary",
    button: "button",
    datalist: "listbox",
    dd: "definition",
    details: "group",
    dialog: "dialog",
    dt: "term",
    fieldset: "group",
    figure: "figure",
    // WARNING: Only with an accessible name
    form: "form",
    footer: "contentinfo",
    h1: "heading",
    h2: "heading",
    h3: "heading",
    h4: "heading",
    h5: "heading",
    h6: "heading",
    header: "banner",
    hr: "separator",
    html: "document",
    legend: "legend",
    li: "listitem",
    math: "math",
    main: "main",
    menu: "list",
    nav: "navigation",
    ol: "list",
    optgroup: "group",
    // WARNING: Only in certain context
    option: "option",
    output: "status",
    progress: "progressbar",
    // WARNING: Only with an accessible name
    section: "region",
    summary: "button",
    table: "table",
    tbody: "rowgroup",
    textarea: "textbox",
    tfoot: "rowgroup",
    // WARNING: Only in certain context
    td: "cell",
    th: "columnheader",
    thead: "rowgroup",
    tr: "row",
    ul: "list"
  };
  var prohibitedAttributes = {
    caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
    code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
    deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
    emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
    generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
    insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
    paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
    presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
    strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
    subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
    superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
  };
  function hasGlobalAriaAttributes(element, role) {
    return [
      "aria-atomic",
      "aria-busy",
      "aria-controls",
      "aria-current",
      "aria-describedby",
      "aria-details",
      // "disabled",
      "aria-dropeffect",
      // "errormessage",
      "aria-flowto",
      "aria-grabbed",
      // "haspopup",
      "aria-hidden",
      // "invalid",
      "aria-keyshortcuts",
      "aria-label",
      "aria-labelledby",
      "aria-live",
      "aria-owns",
      "aria-relevant",
      "aria-roledescription"
    ].some(function(attributeName) {
      var _prohibitedAttributes;
      return element.hasAttribute(attributeName) && !((_prohibitedAttributes = prohibitedAttributes[role]) !== null && _prohibitedAttributes !== void 0 && _prohibitedAttributes.has(attributeName));
    });
  }
  function ignorePresentationalRole(element, implicitRole) {
    return hasGlobalAriaAttributes(element, implicitRole);
  }
  function getRole(element) {
    var explicitRole = getExplicitRole(element);
    if (explicitRole === null || explicitRole === "presentation") {
      var implicitRole = getImplicitRole(element);
      if (explicitRole !== "presentation" || ignorePresentationalRole(element, implicitRole || "")) {
        return implicitRole;
      }
    }
    return explicitRole;
  }
  function getImplicitRole(element) {
    var mappedByTag = localNameToRoleMappings[getLocalName(element)];
    if (mappedByTag !== void 0) {
      return mappedByTag;
    }
    switch (getLocalName(element)) {
      case "a":
      case "area":
      case "link":
        if (element.hasAttribute("href")) {
          return "link";
        }
        break;
      case "img":
        if (element.getAttribute("alt") === "" && !ignorePresentationalRole(element, "img")) {
          return "presentation";
        }
        return "img";
      case "input": {
        var _ref = element, type3 = _ref.type;
        switch (type3) {
          case "button":
          case "image":
          case "reset":
          case "submit":
            return "button";
          case "checkbox":
          case "radio":
            return type3;
          case "range":
            return "slider";
          case "email":
          case "tel":
          case "text":
          case "url":
            if (element.hasAttribute("list")) {
              return "combobox";
            }
            return "textbox";
          case "search":
            if (element.hasAttribute("list")) {
              return "combobox";
            }
            return "searchbox";
          case "number":
            return "spinbutton";
          default:
            return null;
        }
      }
      case "select":
        if (element.hasAttribute("multiple") || element.size > 1) {
          return "listbox";
        }
        return "combobox";
    }
    return null;
  }
  function getExplicitRole(element) {
    var role = element.getAttribute("role");
    if (role !== null) {
      var explicitRole = role.trim().split(" ")[0];
      if (explicitRole.length > 0) {
        return explicitRole;
      }
    }
    return null;
  }

  // node_modules/.pnpm/dom-accessibility-api@0.5.16/node_modules/dom-accessibility-api/dist/util.mjs
  function isElement(node) {
    return node !== null && node.nodeType === node.ELEMENT_NODE;
  }
  function isHTMLTableCaptionElement(node) {
    return isElement(node) && getLocalName(node) === "caption";
  }
  function isHTMLInputElement(node) {
    return isElement(node) && getLocalName(node) === "input";
  }
  function isHTMLOptGroupElement(node) {
    return isElement(node) && getLocalName(node) === "optgroup";
  }
  function isHTMLSelectElement(node) {
    return isElement(node) && getLocalName(node) === "select";
  }
  function isHTMLTableElement(node) {
    return isElement(node) && getLocalName(node) === "table";
  }
  function isHTMLTextAreaElement(node) {
    return isElement(node) && getLocalName(node) === "textarea";
  }
  function safeWindow(node) {
    var _ref = node.ownerDocument === null ? node : node.ownerDocument, defaultView = _ref.defaultView;
    if (defaultView === null) {
      throw new TypeError("no window available");
    }
    return defaultView;
  }
  function isHTMLFieldSetElement(node) {
    return isElement(node) && getLocalName(node) === "fieldset";
  }
  function isHTMLLegendElement(node) {
    return isElement(node) && getLocalName(node) === "legend";
  }
  function isHTMLSlotElement(node) {
    return isElement(node) && getLocalName(node) === "slot";
  }
  function isSVGElement(node) {
    return isElement(node) && node.ownerSVGElement !== void 0;
  }
  function isSVGSVGElement(node) {
    return isElement(node) && getLocalName(node) === "svg";
  }
  function isSVGTitleElement(node) {
    return isSVGElement(node) && getLocalName(node) === "title";
  }
  function queryIdRefs(node, attributeName) {
    if (isElement(node) && node.hasAttribute(attributeName)) {
      var ids = node.getAttribute(attributeName).split(" ");
      var root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
      return ids.map(function(id) {
        return root.getElementById(id);
      }).filter(
        function(element) {
          return element !== null;
        }
        // TODO: why does this not narrow?
      );
    }
    return [];
  }
  function hasAnyConcreteRoles(node, roles2) {
    if (isElement(node)) {
      return roles2.indexOf(getRole(node)) !== -1;
    }
    return false;
  }

  // node_modules/.pnpm/dom-accessibility-api@0.5.16/node_modules/dom-accessibility-api/dist/accessible-name-and-description.mjs
  function asFlatString(s) {
    return s.trim().replace(/\s\s+/g, " ");
  }
  function isHidden(node, getComputedStyleImplementation) {
    if (!isElement(node)) {
      return false;
    }
    if (node.hasAttribute("hidden") || node.getAttribute("aria-hidden") === "true") {
      return true;
    }
    var style = getComputedStyleImplementation(node);
    return style.getPropertyValue("display") === "none" || style.getPropertyValue("visibility") === "hidden";
  }
  function isControl(node) {
    return hasAnyConcreteRoles(node, ["button", "combobox", "listbox", "textbox"]) || hasAbstractRole(node, "range");
  }
  function hasAbstractRole(node, role) {
    if (!isElement(node)) {
      return false;
    }
    switch (role) {
      case "range":
        return hasAnyConcreteRoles(node, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
      default:
        throw new TypeError("No knowledge about abstract role '".concat(role, "'. This is likely a bug :("));
    }
  }
  function querySelectorAllSubtree(element, selectors) {
    var elements = arrayFrom(element.querySelectorAll(selectors));
    queryIdRefs(element, "aria-owns").forEach(function(root) {
      elements.push.apply(elements, arrayFrom(root.querySelectorAll(selectors)));
    });
    return elements;
  }
  function querySelectedOptions(listbox) {
    if (isHTMLSelectElement(listbox)) {
      return listbox.selectedOptions || querySelectorAllSubtree(listbox, "[selected]");
    }
    return querySelectorAllSubtree(listbox, '[aria-selected="true"]');
  }
  function isMarkedPresentational(node) {
    return hasAnyConcreteRoles(node, ["none", "presentation"]);
  }
  function isNativeHostLanguageTextAlternativeElement(node) {
    return isHTMLTableCaptionElement(node);
  }
  function allowsNameFromContent(node) {
    return hasAnyConcreteRoles(node, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
  }
  function isDescendantOfNativeHostLanguageTextAlternativeElement(node) {
    return false;
  }
  function getValueOfTextbox(element) {
    if (isHTMLInputElement(element) || isHTMLTextAreaElement(element)) {
      return element.value;
    }
    return element.textContent || "";
  }
  function getTextualContent(declaration) {
    var content = declaration.getPropertyValue("content");
    if (/^["'].*["']$/.test(content)) {
      return content.slice(1, -1);
    }
    return "";
  }
  function isLabelableElement(element) {
    var localName = getLocalName(element);
    return localName === "button" || localName === "input" && element.getAttribute("type") !== "hidden" || localName === "meter" || localName === "output" || localName === "progress" || localName === "select" || localName === "textarea";
  }
  function findLabelableElement(element) {
    if (isLabelableElement(element)) {
      return element;
    }
    var labelableElement = null;
    element.childNodes.forEach(function(childNode) {
      if (labelableElement === null && isElement(childNode)) {
        var descendantLabelableElement = findLabelableElement(childNode);
        if (descendantLabelableElement !== null) {
          labelableElement = descendantLabelableElement;
        }
      }
    });
    return labelableElement;
  }
  function getControlOfLabel(label) {
    if (label.control !== void 0) {
      return label.control;
    }
    var htmlFor = label.getAttribute("for");
    if (htmlFor !== null) {
      return label.ownerDocument.getElementById(htmlFor);
    }
    return findLabelableElement(label);
  }
  function getLabels(element) {
    var labelsProperty = element.labels;
    if (labelsProperty === null) {
      return labelsProperty;
    }
    if (labelsProperty !== void 0) {
      return arrayFrom(labelsProperty);
    }
    if (!isLabelableElement(element)) {
      return null;
    }
    var document2 = element.ownerDocument;
    return arrayFrom(document2.querySelectorAll("label")).filter(function(label) {
      return getControlOfLabel(label) === element;
    });
  }
  function getSlotContents(slot) {
    var assignedNodes = slot.assignedNodes();
    if (assignedNodes.length === 0) {
      return arrayFrom(slot.childNodes);
    }
    return assignedNodes;
  }
  function computeTextAlternative(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var consultedNodes = new SetLike_default();
    var window2 = safeWindow(root);
    var _options$compute = options.compute, compute = _options$compute === void 0 ? "name" : _options$compute, _options$computedStyl = options.computedStyleSupportsPseudoElements, computedStyleSupportsPseudoElements = _options$computedStyl === void 0 ? options.getComputedStyle !== void 0 : _options$computedStyl, _options$getComputedS = options.getComputedStyle, getComputedStyle2 = _options$getComputedS === void 0 ? window2.getComputedStyle.bind(window2) : _options$getComputedS, _options$hidden = options.hidden, hidden = _options$hidden === void 0 ? false : _options$hidden;
    function computeMiscTextAlternative(node, context) {
      var accumulatedText = "";
      if (isElement(node) && computedStyleSupportsPseudoElements) {
        var pseudoBefore = getComputedStyle2(node, "::before");
        var beforeContent = getTextualContent(pseudoBefore);
        accumulatedText = "".concat(beforeContent, " ").concat(accumulatedText);
      }
      var childNodes = isHTMLSlotElement(node) ? getSlotContents(node) : arrayFrom(node.childNodes).concat(queryIdRefs(node, "aria-owns"));
      childNodes.forEach(function(child) {
        var result = computeTextAlternative2(child, {
          isEmbeddedInLabel: context.isEmbeddedInLabel,
          isReferenced: false,
          recursion: true
        });
        var display = isElement(child) ? getComputedStyle2(child).getPropertyValue("display") : "inline";
        var separator = display !== "inline" ? " " : "";
        accumulatedText += "".concat(separator).concat(result).concat(separator);
      });
      if (isElement(node) && computedStyleSupportsPseudoElements) {
        var pseudoAfter = getComputedStyle2(node, "::after");
        var afterContent = getTextualContent(pseudoAfter);
        accumulatedText = "".concat(accumulatedText, " ").concat(afterContent);
      }
      return accumulatedText.trim();
    }
    function useAttribute(element, attributeName) {
      var attribute = element.getAttributeNode(attributeName);
      if (attribute !== null && !consultedNodes.has(attribute) && attribute.value.trim() !== "") {
        consultedNodes.add(attribute);
        return attribute.value;
      }
      return null;
    }
    function computeTooltipAttributeValue(node) {
      if (!isElement(node)) {
        return null;
      }
      return useAttribute(node, "title");
    }
    function computeElementTextAlternative(node) {
      if (!isElement(node)) {
        return null;
      }
      if (isHTMLFieldSetElement(node)) {
        consultedNodes.add(node);
        var children = arrayFrom(node.childNodes);
        for (var i = 0; i < children.length; i += 1) {
          var child = children[i];
          if (isHTMLLegendElement(child)) {
            return computeTextAlternative2(child, {
              isEmbeddedInLabel: false,
              isReferenced: false,
              recursion: false
            });
          }
        }
      } else if (isHTMLTableElement(node)) {
        consultedNodes.add(node);
        var _children = arrayFrom(node.childNodes);
        for (var _i = 0; _i < _children.length; _i += 1) {
          var _child = _children[_i];
          if (isHTMLTableCaptionElement(_child)) {
            return computeTextAlternative2(_child, {
              isEmbeddedInLabel: false,
              isReferenced: false,
              recursion: false
            });
          }
        }
      } else if (isSVGSVGElement(node)) {
        consultedNodes.add(node);
        var _children2 = arrayFrom(node.childNodes);
        for (var _i2 = 0; _i2 < _children2.length; _i2 += 1) {
          var _child2 = _children2[_i2];
          if (isSVGTitleElement(_child2)) {
            return _child2.textContent;
          }
        }
        return null;
      } else if (getLocalName(node) === "img" || getLocalName(node) === "area") {
        var nameFromAlt = useAttribute(node, "alt");
        if (nameFromAlt !== null) {
          return nameFromAlt;
        }
      } else if (isHTMLOptGroupElement(node)) {
        var nameFromLabel = useAttribute(node, "label");
        if (nameFromLabel !== null) {
          return nameFromLabel;
        }
      }
      if (isHTMLInputElement(node) && (node.type === "button" || node.type === "submit" || node.type === "reset")) {
        var nameFromValue = useAttribute(node, "value");
        if (nameFromValue !== null) {
          return nameFromValue;
        }
        if (node.type === "submit") {
          return "Submit";
        }
        if (node.type === "reset") {
          return "Reset";
        }
      }
      var labels = getLabels(node);
      if (labels !== null && labels.length !== 0) {
        consultedNodes.add(node);
        return arrayFrom(labels).map(function(element) {
          return computeTextAlternative2(element, {
            isEmbeddedInLabel: true,
            isReferenced: false,
            recursion: true
          });
        }).filter(function(label) {
          return label.length > 0;
        }).join(" ");
      }
      if (isHTMLInputElement(node) && node.type === "image") {
        var _nameFromAlt = useAttribute(node, "alt");
        if (_nameFromAlt !== null) {
          return _nameFromAlt;
        }
        var nameFromTitle = useAttribute(node, "title");
        if (nameFromTitle !== null) {
          return nameFromTitle;
        }
        return "Submit Query";
      }
      if (hasAnyConcreteRoles(node, ["button"])) {
        var nameFromSubTree = computeMiscTextAlternative(node, {
          isEmbeddedInLabel: false,
          isReferenced: false
        });
        if (nameFromSubTree !== "") {
          return nameFromSubTree;
        }
      }
      return null;
    }
    function computeTextAlternative2(current, context) {
      if (consultedNodes.has(current)) {
        return "";
      }
      if (!hidden && isHidden(current, getComputedStyle2) && !context.isReferenced) {
        consultedNodes.add(current);
        return "";
      }
      var labelAttributeNode = isElement(current) ? current.getAttributeNode("aria-labelledby") : null;
      var labelElements = labelAttributeNode !== null && !consultedNodes.has(labelAttributeNode) ? queryIdRefs(current, "aria-labelledby") : [];
      if (compute === "name" && !context.isReferenced && labelElements.length > 0) {
        consultedNodes.add(labelAttributeNode);
        return labelElements.map(function(element) {
          return computeTextAlternative2(element, {
            isEmbeddedInLabel: context.isEmbeddedInLabel,
            isReferenced: true,
            // this isn't recursion as specified, otherwise we would skip
            // `aria-label` in
            // <input id="myself" aria-label="foo" aria-labelledby="myself"
            recursion: false
          });
        }).join(" ");
      }
      var skipToStep2E = context.recursion && isControl(current) && compute === "name";
      if (!skipToStep2E) {
        var ariaLabel = (isElement(current) && current.getAttribute("aria-label") || "").trim();
        if (ariaLabel !== "" && compute === "name") {
          consultedNodes.add(current);
          return ariaLabel;
        }
        if (!isMarkedPresentational(current)) {
          var elementTextAlternative = computeElementTextAlternative(current);
          if (elementTextAlternative !== null) {
            consultedNodes.add(current);
            return elementTextAlternative;
          }
        }
      }
      if (hasAnyConcreteRoles(current, ["menu"])) {
        consultedNodes.add(current);
        return "";
      }
      if (skipToStep2E || context.isEmbeddedInLabel || context.isReferenced) {
        if (hasAnyConcreteRoles(current, ["combobox", "listbox"])) {
          consultedNodes.add(current);
          var selectedOptions = querySelectedOptions(current);
          if (selectedOptions.length === 0) {
            return isHTMLInputElement(current) ? current.value : "";
          }
          return arrayFrom(selectedOptions).map(function(selectedOption) {
            return computeTextAlternative2(selectedOption, {
              isEmbeddedInLabel: context.isEmbeddedInLabel,
              isReferenced: false,
              recursion: true
            });
          }).join(" ");
        }
        if (hasAbstractRole(current, "range")) {
          consultedNodes.add(current);
          if (current.hasAttribute("aria-valuetext")) {
            return current.getAttribute("aria-valuetext");
          }
          if (current.hasAttribute("aria-valuenow")) {
            return current.getAttribute("aria-valuenow");
          }
          return current.getAttribute("value") || "";
        }
        if (hasAnyConcreteRoles(current, ["textbox"])) {
          consultedNodes.add(current);
          return getValueOfTextbox(current);
        }
      }
      if (allowsNameFromContent(current) || isElement(current) && context.isReferenced || isNativeHostLanguageTextAlternativeElement(current) || isDescendantOfNativeHostLanguageTextAlternativeElement(current)) {
        var accumulatedText2F = computeMiscTextAlternative(current, {
          isEmbeddedInLabel: context.isEmbeddedInLabel,
          isReferenced: false
        });
        if (accumulatedText2F !== "") {
          consultedNodes.add(current);
          return accumulatedText2F;
        }
      }
      if (current.nodeType === current.TEXT_NODE) {
        consultedNodes.add(current);
        return current.textContent || "";
      }
      if (context.recursion) {
        consultedNodes.add(current);
        return computeMiscTextAlternative(current, {
          isEmbeddedInLabel: context.isEmbeddedInLabel,
          isReferenced: false
        });
      }
      var tooltipAttributeValue = computeTooltipAttributeValue(current);
      if (tooltipAttributeValue !== null) {
        consultedNodes.add(current);
        return tooltipAttributeValue;
      }
      consultedNodes.add(current);
      return "";
    }
    return asFlatString(computeTextAlternative2(root, {
      isEmbeddedInLabel: false,
      // by spec computeAccessibleDescription starts with the referenced elements as roots
      isReferenced: compute === "description",
      recursion: false
    }));
  }

  // node_modules/.pnpm/dom-accessibility-api@0.5.16/node_modules/dom-accessibility-api/dist/accessible-description.mjs
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof2(obj);
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey2(arg) {
    var key = _toPrimitive2(arg, "string");
    return _typeof2(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive2(input, hint) {
    if (_typeof2(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (_typeof2(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function computeAccessibleDescription(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var description = queryIdRefs(root, "aria-describedby").map(function(element) {
      return computeTextAlternative(element, _objectSpread(_objectSpread({}, options), {}, {
        compute: "description"
      }));
    }).join(" ");
    if (description === "") {
      var title = root.getAttribute("title");
      description = title === null ? "" : title;
    }
    return description;
  }

  // node_modules/.pnpm/dom-accessibility-api@0.5.16/node_modules/dom-accessibility-api/dist/accessible-name.mjs
  function prohibitsNaming(node) {
    return hasAnyConcreteRoles(node, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]);
  }
  function computeAccessibleName(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (prohibitsNaming(root)) {
      return "";
    }
    return computeTextAlternative(root, options);
  }

  // node_modules/.pnpm/@testing-library+dom@10.4.1/node_modules/@testing-library/dom/dist/@testing-library/dom.esm.js
  var import_aria_query = __toESM(require_lib());
  var import_lz_string = __toESM(require_lz_string());
  function escapeHTML(str) {
    return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  var printProps = (keys, props, config3, indentation, depth, refs, printer) => {
    const indentationNext = indentation + config3.indent;
    const colors = config3.colors;
    return keys.map((key) => {
      const value = props[key];
      let printed = printer(value, config3, indentationNext, depth, refs);
      if (typeof value !== "string") {
        if (printed.indexOf("\n") !== -1) {
          printed = config3.spacingOuter + indentationNext + printed + config3.spacingOuter + indentation;
        }
        printed = "{" + printed + "}";
      }
      return config3.spacingInner + indentation + colors.prop.open + key + colors.prop.close + "=" + colors.value.open + printed + colors.value.close;
    }).join("");
  };
  var NodeTypeTextNode = 3;
  var printChildren = (children, config3, indentation, depth, refs, printer) => children.map((child) => {
    const printedChild = typeof child === "string" ? printText(child, config3) : printer(child, config3, indentation, depth, refs);
    if (printedChild === "" && typeof child === "object" && child !== null && child.nodeType !== NodeTypeTextNode) {
      return "";
    }
    return config3.spacingOuter + indentation + printedChild;
  }).join("");
  var printText = (text, config3) => {
    const contentColor = config3.colors.content;
    return contentColor.open + escapeHTML(text) + contentColor.close;
  };
  var printComment = (comment, config3) => {
    const commentColor = config3.colors.comment;
    return commentColor.open + "<!--" + escapeHTML(comment) + "-->" + commentColor.close;
  };
  var printElement = (type3, printedProps, printedChildren, config3, indentation) => {
    const tagColor = config3.colors.tag;
    return tagColor.open + "<" + type3 + (printedProps && tagColor.close + printedProps + config3.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config3.spacingOuter + indentation + tagColor.open + "</" + type3 : (printedProps && !config3.min ? "" : " ") + "/") + ">" + tagColor.close;
  };
  var printElementAsLeaf = (type3, config3) => {
    const tagColor = config3.colors.tag;
    return tagColor.open + "<" + type3 + tagColor.close + " \u2026" + tagColor.open + " />" + tagColor.close;
  };
  var ELEMENT_NODE$1 = 1;
  var TEXT_NODE$1 = 3;
  var COMMENT_NODE$1 = 8;
  var FRAGMENT_NODE = 11;
  var ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;
  var isCustomElement = (val) => {
    const {
      tagName
    } = val;
    return Boolean(typeof tagName === "string" && tagName.includes("-") || typeof val.hasAttribute === "function" && val.hasAttribute("is"));
  };
  var testNode = (val) => {
    const constructorName = val.constructor.name;
    const {
      nodeType
    } = val;
    return nodeType === ELEMENT_NODE$1 && (ELEMENT_REGEXP.test(constructorName) || isCustomElement(val)) || nodeType === TEXT_NODE$1 && constructorName === "Text" || nodeType === COMMENT_NODE$1 && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
  };
  function nodeIsText(node) {
    return node.nodeType === TEXT_NODE$1;
  }
  function nodeIsComment(node) {
    return node.nodeType === COMMENT_NODE$1;
  }
  function nodeIsFragment(node) {
    return node.nodeType === FRAGMENT_NODE;
  }
  function createDOMElementFilter(filterNode) {
    return {
      test: (val) => {
        var _val$constructor2;
        return ((val == null || (_val$constructor2 = val.constructor) == null ? void 0 : _val$constructor2.name) || isCustomElement(val)) && testNode(val);
      },
      serialize: (node, config3, indentation, depth, refs, printer) => {
        if (nodeIsText(node)) {
          return printText(node.data, config3);
        }
        if (nodeIsComment(node)) {
          return printComment(node.data, config3);
        }
        const type3 = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
        if (++depth > config3.maxDepth) {
          return printElementAsLeaf(type3, config3);
        }
        return printElement(type3, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes).map((attr) => attr.name).sort(), nodeIsFragment(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => {
          props[attribute.name] = attribute.value;
          return props;
        }, {}), config3, indentation + config3.indent, depth, refs, printer), printChildren(Array.prototype.slice.call(node.childNodes || node.children).filter(filterNode), config3, indentation + config3.indent, depth, refs, printer), config3, indentation);
      }
    };
  }
  var picocolors = null;
  var readFileSync = null;
  var codeFrameColumns = null;
  try {
    const nodeRequire = module && module.require;
    readFileSync = nodeRequire.call(module, "fs").readFileSync;
    codeFrameColumns = nodeRequire.call(module, "@babel/code-frame").codeFrameColumns;
    picocolors = nodeRequire.call(module, "picocolors");
  } catch {
  }
  function getCodeFrame(frame7) {
    const locationStart = frame7.indexOf("(") + 1;
    const locationEnd = frame7.indexOf(")");
    const frameLocation = frame7.slice(locationStart, locationEnd);
    const frameLocationElements = frameLocation.split(":");
    const [filename, line, column] = [frameLocationElements[0], parseInt(frameLocationElements[1], 10), parseInt(frameLocationElements[2], 10)];
    let rawFileContents = "";
    try {
      rawFileContents = readFileSync(filename, "utf-8");
    } catch {
      return "";
    }
    const codeFrame = codeFrameColumns(rawFileContents, {
      start: {
        line,
        column
      }
    }, {
      highlightCode: true,
      linesBelow: 0
    });
    return picocolors.dim(frameLocation) + "\n" + codeFrame + "\n";
  }
  function getUserCodeFrame() {
    if (!readFileSync || !codeFrameColumns) {
      return "";
    }
    const err = new Error();
    const firstClientCodeFrame = err.stack.split("\n").slice(1).find((frame7) => !frame7.includes("node_modules/"));
    return getCodeFrame(firstClientCodeFrame);
  }
  var TEXT_NODE = 3;
  function jestFakeTimersAreEnabled() {
    if (typeof jest !== "undefined" && jest !== null) {
      return (
        // legacy timers
        setTimeout._isMockFunction === true || // modern timers
        // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix
        Object.prototype.hasOwnProperty.call(setTimeout, "clock")
      );
    }
    return false;
  }
  function getDocument() {
    if (typeof window === "undefined") {
      throw new Error("Could not find default container");
    }
    return window.document;
  }
  function getWindowFromNode(node) {
    if (node.defaultView) {
      return node.defaultView;
    } else if (node.ownerDocument && node.ownerDocument.defaultView) {
      return node.ownerDocument.defaultView;
    } else if (node.window) {
      return node.window;
    } else if (node.ownerDocument && node.ownerDocument.defaultView === null) {
      throw new Error("It looks like the window object is not available for the provided node.");
    } else if (node.then instanceof Function) {
      throw new Error("It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?");
    } else if (Array.isArray(node)) {
      throw new Error("It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?");
    } else if (typeof node.debug === "function" && typeof node.logTestingPlaygroundURL === "function") {
      throw new Error("It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?");
    } else {
      throw new Error("The given node is not an Element, the node type is: " + typeof node + ".");
    }
  }
  function checkContainerType(container) {
    if (!container || !(typeof container.querySelector === "function") || !(typeof container.querySelectorAll === "function")) {
      throw new TypeError("Expected container to be an Element, a Document or a DocumentFragment but got " + getTypeName(container) + ".");
    }
    function getTypeName(object) {
      if (typeof object === "object") {
        return object === null ? "null" : object.constructor.name;
      }
      return typeof object;
    }
  }
  var shouldHighlight = () => {
    if (typeof process === "undefined") {
      return false;
    }
    let colors;
    try {
      var _process$env;
      const colorsJSON = (_process$env = process.env) == null ? void 0 : _process$env.COLORS;
      if (colorsJSON) {
        colors = JSON.parse(colorsJSON);
      }
    } catch {
    }
    if (typeof colors === "boolean") {
      return colors;
    } else {
      return process.versions !== void 0 && process.versions.node !== void 0;
    }
  };
  var {
    DOMCollection
  } = prettyFormat.plugins;
  var ELEMENT_NODE = 1;
  var COMMENT_NODE = 8;
  function filterCommentsAndDefaultIgnoreTagsTags(value) {
    return value.nodeType !== COMMENT_NODE && (value.nodeType !== ELEMENT_NODE || !value.matches(getConfig().defaultIgnore));
  }
  function prettyDOM(dom, maxLength, options) {
    if (options === void 0) {
      options = {};
    }
    if (!dom) {
      dom = getDocument().body;
    }
    if (typeof maxLength !== "number") {
      maxLength = typeof process !== "undefined" && typeof process.env !== "undefined" && process.env.DEBUG_PRINT_LIMIT || 7e3;
    }
    if (maxLength === 0) {
      return "";
    }
    if (dom.documentElement) {
      dom = dom.documentElement;
    }
    let domTypeName = typeof dom;
    if (domTypeName === "object") {
      domTypeName = dom.constructor.name;
    } else {
      dom = {};
    }
    if (!("outerHTML" in dom)) {
      throw new TypeError("Expected an element or document but got " + domTypeName);
    }
    const {
      filterNode = filterCommentsAndDefaultIgnoreTagsTags,
      ...prettyFormatOptions
    } = options;
    const debugContent = prettyFormat.format(dom, {
      plugins: [createDOMElementFilter(filterNode), DOMCollection],
      printFunctionName: false,
      highlight: shouldHighlight(),
      ...prettyFormatOptions
    });
    return maxLength !== void 0 && dom.outerHTML.length > maxLength ? debugContent.slice(0, maxLength) + "..." : debugContent;
  }
  var logDOM = function() {
    const userCodeFrame = getUserCodeFrame();
    if (userCodeFrame) {
      console.log(prettyDOM(...arguments) + "\n\n" + userCodeFrame);
    } else {
      console.log(prettyDOM(...arguments));
    }
  };
  var config2 = {
    testIdAttribute: "data-testid",
    asyncUtilTimeout: 1e3,
    // asyncWrapper and advanceTimersWrapper is to support React's async `act` function.
    // forcing react-testing-library to wrap all async functions would've been
    // a total nightmare (consider wrapping every findBy* query and then also
    // updating `within` so those would be wrapped too. Total nightmare).
    // so we have this config option that's really only intended for
    // react-testing-library to use. For that reason, this feature will remain
    // undocumented.
    asyncWrapper: (cb) => cb(),
    unstable_advanceTimersWrapper: (cb) => cb(),
    eventWrapper: (cb) => cb(),
    // default value for the `hidden` option in `ByRole` queries
    defaultHidden: false,
    // default value for the `ignore` option in `ByText` queries
    defaultIgnore: "script, style",
    // showOriginalStackTrace flag to show the full error stack traces for async errors
    showOriginalStackTrace: false,
    // throw errors w/ suggestions for better queries. Opt in so off by default.
    throwSuggestions: false,
    // called when getBy* queries fail. (message, container) => Error
    getElementError(message, container) {
      const prettifiedDOM = prettyDOM(container);
      const error = new Error([message, "Ignored nodes: comments, " + config2.defaultIgnore + "\n" + prettifiedDOM].filter(Boolean).join("\n\n"));
      error.name = "TestingLibraryElementError";
      return error;
    },
    _disableExpensiveErrorDiagnostics: false,
    computedStyleSupportsPseudoElements: false
  };
  function runWithExpensiveErrorDiagnosticsDisabled(callback) {
    try {
      config2._disableExpensiveErrorDiagnostics = true;
      return callback();
    } finally {
      config2._disableExpensiveErrorDiagnostics = false;
    }
  }
  function getConfig() {
    return config2;
  }
  var labelledNodeNames = ["button", "meter", "output", "progress", "select", "textarea", "input"];
  function getTextContent(node) {
    if (labelledNodeNames.includes(node.nodeName.toLowerCase())) {
      return "";
    }
    if (node.nodeType === TEXT_NODE) return node.textContent;
    return Array.from(node.childNodes).map((childNode) => getTextContent(childNode)).join("");
  }
  function getLabelContent(element) {
    let textContent;
    if (element.tagName.toLowerCase() === "label") {
      textContent = getTextContent(element);
    } else {
      textContent = element.value || element.textContent;
    }
    return textContent;
  }
  function getRealLabels(element) {
    if (element.labels !== void 0) {
      var _labels;
      return (_labels = element.labels) != null ? _labels : [];
    }
    if (!isLabelable(element)) return [];
    const labels = element.ownerDocument.querySelectorAll("label");
    return Array.from(labels).filter((label) => label.control === element);
  }
  function isLabelable(element) {
    return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(element.tagName) || element.tagName === "INPUT" && element.getAttribute("type") !== "hidden";
  }
  function getLabels2(container, element, _temp) {
    let {
      selector = "*"
    } = _temp === void 0 ? {} : _temp;
    const ariaLabelledBy = element.getAttribute("aria-labelledby");
    const labelsId = ariaLabelledBy ? ariaLabelledBy.split(" ") : [];
    return labelsId.length ? labelsId.map((labelId) => {
      const labellingElement = container.querySelector('[id="' + labelId + '"]');
      return labellingElement ? {
        content: getLabelContent(labellingElement),
        formControl: null
      } : {
        content: "",
        formControl: null
      };
    }) : Array.from(getRealLabels(element)).map((label) => {
      const textToMatch = getLabelContent(label);
      const formControlSelector = "button, input, meter, output, progress, select, textarea";
      const labelledFormControl = Array.from(label.querySelectorAll(formControlSelector)).filter((formControlElement) => formControlElement.matches(selector))[0];
      return {
        content: textToMatch,
        formControl: labelledFormControl
      };
    });
  }
  function assertNotNullOrUndefined(matcher) {
    if (matcher === null || matcher === void 0) {
      throw new Error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`
        "It looks like " + matcher + " was passed instead of a matcher. Did you do something like getByText(" + matcher + ")?"
      );
    }
  }
  function fuzzyMatches(textToMatch, node, matcher, normalizer) {
    if (typeof textToMatch !== "string") {
      return false;
    }
    assertNotNullOrUndefined(matcher);
    const normalizedText = normalizer(textToMatch);
    if (typeof matcher === "string" || typeof matcher === "number") {
      return normalizedText.toLowerCase().includes(matcher.toString().toLowerCase());
    } else if (typeof matcher === "function") {
      return matcher(normalizedText, node);
    } else {
      return matchRegExp(matcher, normalizedText);
    }
  }
  function matches(textToMatch, node, matcher, normalizer) {
    if (typeof textToMatch !== "string") {
      return false;
    }
    assertNotNullOrUndefined(matcher);
    const normalizedText = normalizer(textToMatch);
    if (matcher instanceof Function) {
      return matcher(normalizedText, node);
    } else if (matcher instanceof RegExp) {
      return matchRegExp(matcher, normalizedText);
    } else {
      return normalizedText === String(matcher);
    }
  }
  function getDefaultNormalizer(_temp) {
    let {
      trim = true,
      collapseWhitespace = true
    } = _temp === void 0 ? {} : _temp;
    return (text) => {
      let normalizedText = text;
      normalizedText = trim ? normalizedText.trim() : normalizedText;
      normalizedText = collapseWhitespace ? normalizedText.replace(/\s+/g, " ") : normalizedText;
      return normalizedText;
    };
  }
  function makeNormalizer(_ref) {
    let {
      trim,
      collapseWhitespace,
      normalizer
    } = _ref;
    if (!normalizer) {
      return getDefaultNormalizer({
        trim,
        collapseWhitespace
      });
    }
    if (typeof trim !== "undefined" || typeof collapseWhitespace !== "undefined") {
      throw new Error('trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
    }
    return normalizer;
  }
  function matchRegExp(matcher, text) {
    const match = matcher.test(text);
    if (matcher.global && matcher.lastIndex !== 0) {
      console.warn("To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp.");
      matcher.lastIndex = 0;
    }
    return match;
  }
  function getNodeText(node) {
    if (node.matches("input[type=submit], input[type=button], input[type=reset]")) {
      return node.value;
    }
    return Array.from(node.childNodes).filter((child) => child.nodeType === TEXT_NODE && Boolean(child.textContent)).map((c) => c.textContent).join("");
  }
  var elementRoleList = buildElementRoleList(import_aria_query.elementRoles);
  function isSubtreeInaccessible(element) {
    if (element.hidden === true) {
      return true;
    }
    if (element.getAttribute("aria-hidden") === "true") {
      return true;
    }
    const window2 = element.ownerDocument.defaultView;
    if (window2.getComputedStyle(element).display === "none") {
      return true;
    }
    return false;
  }
  function isInaccessible(element, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      isSubtreeInaccessible: isSubtreeInaccessibleImpl = isSubtreeInaccessible
    } = options;
    const window2 = element.ownerDocument.defaultView;
    if (window2.getComputedStyle(element).visibility === "hidden") {
      return true;
    }
    let currentElement = element;
    while (currentElement) {
      if (isSubtreeInaccessibleImpl(currentElement)) {
        return true;
      }
      currentElement = currentElement.parentElement;
    }
    return false;
  }
  function getImplicitAriaRoles(currentNode) {
    for (const {
      match,
      roles: roles2
    } of elementRoleList) {
      if (match(currentNode)) {
        return [...roles2];
      }
    }
    return [];
  }
  function buildElementRoleList(elementRolesMap) {
    function makeElementSelector(_ref) {
      let {
        name,
        attributes
      } = _ref;
      return "" + name + attributes.map((_ref2) => {
        let {
          name: attributeName,
          value,
          constraints = []
        } = _ref2;
        const shouldNotExist = constraints.indexOf("undefined") !== -1;
        const shouldBeNonEmpty = constraints.indexOf("set") !== -1;
        const hasExplicitValue = typeof value !== "undefined";
        if (hasExplicitValue) {
          return "[" + attributeName + '="' + value + '"]';
        } else if (shouldNotExist) {
          return ":not([" + attributeName + "])";
        } else if (shouldBeNonEmpty) {
          return "[" + attributeName + "]:not([" + attributeName + '=""])';
        }
        return "[" + attributeName + "]";
      }).join("");
    }
    function getSelectorSpecificity(_ref3) {
      let {
        attributes = []
      } = _ref3;
      return attributes.length;
    }
    function bySelectorSpecificity(_ref4, _ref5) {
      let {
        specificity: leftSpecificity
      } = _ref4;
      let {
        specificity: rightSpecificity
      } = _ref5;
      return rightSpecificity - leftSpecificity;
    }
    function match(element) {
      let {
        attributes = []
      } = element;
      const typeTextIndex = attributes.findIndex((attribute) => attribute.value && attribute.name === "type" && attribute.value === "text");
      if (typeTextIndex >= 0) {
        attributes = [...attributes.slice(0, typeTextIndex), ...attributes.slice(typeTextIndex + 1)];
      }
      const selector = makeElementSelector({
        ...element,
        attributes
      });
      return (node) => {
        if (typeTextIndex >= 0 && node.type !== "text") {
          return false;
        }
        return node.matches(selector);
      };
    }
    let result = [];
    for (const [element, roles2] of elementRolesMap.entries()) {
      result = [...result, {
        match: match(element),
        roles: Array.from(roles2),
        specificity: getSelectorSpecificity(element)
      }];
    }
    return result.sort(bySelectorSpecificity);
  }
  function getRoles(container, _temp) {
    let {
      hidden = false
    } = _temp === void 0 ? {} : _temp;
    function flattenDOM(node) {
      return [node, ...Array.from(node.children).reduce((acc, child) => [...acc, ...flattenDOM(child)], [])];
    }
    return flattenDOM(container).filter((element) => {
      return hidden === false ? isInaccessible(element) === false : true;
    }).reduce((acc, node) => {
      let roles2 = [];
      if (node.hasAttribute("role")) {
        roles2 = node.getAttribute("role").split(" ").slice(0, 1);
      } else {
        roles2 = getImplicitAriaRoles(node);
      }
      return roles2.reduce((rolesAcc, role) => Array.isArray(rolesAcc[role]) ? {
        ...rolesAcc,
        [role]: [...rolesAcc[role], node]
      } : {
        ...rolesAcc,
        [role]: [node]
      }, acc);
    }, {});
  }
  function prettyRoles(dom, _ref6) {
    let {
      hidden,
      includeDescription
    } = _ref6;
    const roles2 = getRoles(dom, {
      hidden
    });
    return Object.entries(roles2).filter((_ref7) => {
      let [role] = _ref7;
      return role !== "generic";
    }).map((_ref8) => {
      let [role, elements] = _ref8;
      const delimiterBar = "-".repeat(50);
      const elementsString = elements.map((el) => {
        const nameString = 'Name "' + computeAccessibleName(el, {
          computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
        }) + '":\n';
        const domString = prettyDOM(el.cloneNode(false));
        if (includeDescription) {
          const descriptionString = 'Description "' + computeAccessibleDescription(el, {
            computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
          }) + '":\n';
          return "" + nameString + descriptionString + domString;
        }
        return "" + nameString + domString;
      }).join("\n\n");
      return role + ":\n\n" + elementsString + "\n\n" + delimiterBar;
    }).join("\n");
  }
  function computeAriaSelected(element) {
    if (element.tagName === "OPTION") {
      return element.selected;
    }
    return checkBooleanAttribute(element, "aria-selected");
  }
  function computeAriaBusy(element) {
    return element.getAttribute("aria-busy") === "true";
  }
  function computeAriaChecked(element) {
    if ("indeterminate" in element && element.indeterminate) {
      return void 0;
    }
    if ("checked" in element) {
      return element.checked;
    }
    return checkBooleanAttribute(element, "aria-checked");
  }
  function computeAriaPressed(element) {
    return checkBooleanAttribute(element, "aria-pressed");
  }
  function computeAriaCurrent(element) {
    var _ref9, _checkBooleanAttribut;
    return (_ref9 = (_checkBooleanAttribut = checkBooleanAttribute(element, "aria-current")) != null ? _checkBooleanAttribut : element.getAttribute("aria-current")) != null ? _ref9 : false;
  }
  function computeAriaExpanded(element) {
    return checkBooleanAttribute(element, "aria-expanded");
  }
  function checkBooleanAttribute(element, attribute) {
    const attributeValue = element.getAttribute(attribute);
    if (attributeValue === "true") {
      return true;
    }
    if (attributeValue === "false") {
      return false;
    }
    return void 0;
  }
  function computeHeadingLevel(element) {
    const implicitHeadingLevels = {
      H1: 1,
      H2: 2,
      H3: 3,
      H4: 4,
      H5: 5,
      H6: 6
    };
    const ariaLevelAttribute = element.getAttribute("aria-level") && Number(element.getAttribute("aria-level"));
    return ariaLevelAttribute || implicitHeadingLevels[element.tagName];
  }
  function computeAriaValueNow(element) {
    const valueNow = element.getAttribute("aria-valuenow");
    return valueNow === null ? void 0 : +valueNow;
  }
  function computeAriaValueMax(element) {
    const valueMax = element.getAttribute("aria-valuemax");
    return valueMax === null ? void 0 : +valueMax;
  }
  function computeAriaValueMin(element) {
    const valueMin = element.getAttribute("aria-valuemin");
    return valueMin === null ? void 0 : +valueMin;
  }
  function computeAriaValueText(element) {
    const valueText = element.getAttribute("aria-valuetext");
    return valueText === null ? void 0 : valueText;
  }
  var normalize = getDefaultNormalizer();
  function escapeRegExp(string) {
    return string.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
  }
  function getRegExpMatcher(string) {
    return new RegExp(escapeRegExp(string.toLowerCase()), "i");
  }
  function makeSuggestion(queryName, element, content, _ref) {
    let {
      variant,
      name
    } = _ref;
    let warning = "";
    const queryOptions = {};
    const queryArgs = [["Role", "TestId"].includes(queryName) ? content : getRegExpMatcher(content)];
    if (name) {
      queryOptions.name = getRegExpMatcher(name);
    }
    if (queryName === "Role" && isInaccessible(element)) {
      queryOptions.hidden = true;
      warning = "Element is inaccessible. This means that the element and all its children are invisible to screen readers.\n    If you are using the aria-hidden prop, make sure this is the right choice for your case.\n    ";
    }
    if (Object.keys(queryOptions).length > 0) {
      queryArgs.push(queryOptions);
    }
    const queryMethod = variant + "By" + queryName;
    return {
      queryName,
      queryMethod,
      queryArgs,
      variant,
      warning,
      toString() {
        if (warning) {
          console.warn(warning);
        }
        let [text, options] = queryArgs;
        text = typeof text === "string" ? "'" + text + "'" : text;
        options = options ? ", { " + Object.entries(options).map((_ref2) => {
          let [k, v] = _ref2;
          return k + ": " + v;
        }).join(", ") + " }" : "";
        return queryMethod + "(" + text + options + ")";
      }
    };
  }
  function canSuggest(currentMethod, requestedMethod, data) {
    return data && (!requestedMethod || requestedMethod.toLowerCase() === currentMethod.toLowerCase());
  }
  function getSuggestedQuery(element, variant, method) {
    var _element$getAttribute, _getImplicitAriaRoles;
    if (variant === void 0) {
      variant = "get";
    }
    if (element.matches(getConfig().defaultIgnore)) {
      return void 0;
    }
    const role = (_element$getAttribute = element.getAttribute("role")) != null ? _element$getAttribute : (_getImplicitAriaRoles = getImplicitAriaRoles(element)) == null ? void 0 : _getImplicitAriaRoles[0];
    if (role !== "generic" && canSuggest("Role", method, role)) {
      return makeSuggestion("Role", element, role, {
        variant,
        name: computeAccessibleName(element, {
          computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
        })
      });
    }
    const labelText = getLabels2(document, element).map((label) => label.content).join(" ");
    if (canSuggest("LabelText", method, labelText)) {
      return makeSuggestion("LabelText", element, labelText, {
        variant
      });
    }
    const placeholderText = element.getAttribute("placeholder");
    if (canSuggest("PlaceholderText", method, placeholderText)) {
      return makeSuggestion("PlaceholderText", element, placeholderText, {
        variant
      });
    }
    const textContent = normalize(getNodeText(element));
    if (canSuggest("Text", method, textContent)) {
      return makeSuggestion("Text", element, textContent, {
        variant
      });
    }
    if (canSuggest("DisplayValue", method, element.value)) {
      return makeSuggestion("DisplayValue", element, normalize(element.value), {
        variant
      });
    }
    const alt = element.getAttribute("alt");
    if (canSuggest("AltText", method, alt)) {
      return makeSuggestion("AltText", element, alt, {
        variant
      });
    }
    const title = element.getAttribute("title");
    if (canSuggest("Title", method, title)) {
      return makeSuggestion("Title", element, title, {
        variant
      });
    }
    const testId = element.getAttribute(getConfig().testIdAttribute);
    if (canSuggest("TestId", method, testId)) {
      return makeSuggestion("TestId", element, testId, {
        variant
      });
    }
    return void 0;
  }
  function copyStackTrace(target, source) {
    target.stack = source.stack.replace(source.message, target.message);
  }
  function waitFor(callback, _ref) {
    let {
      container = getDocument(),
      timeout = getConfig().asyncUtilTimeout,
      showOriginalStackTrace = getConfig().showOriginalStackTrace,
      stackTraceError,
      interval = 50,
      onTimeout = (error) => {
        Object.defineProperty(error, "message", {
          value: getConfig().getElementError(error.message, container).message
        });
        return error;
      },
      mutationObserverOptions = {
        subtree: true,
        childList: true,
        attributes: true,
        characterData: true
      }
    } = _ref;
    if (typeof callback !== "function") {
      throw new TypeError("Received `callback` arg must be a function");
    }
    return new Promise(async (resolve, reject) => {
      let lastError2, intervalId, observer;
      let finished = false;
      let promiseStatus = "idle";
      const overallTimeoutTimer = setTimeout(handleTimeout, timeout);
      const usingJestFakeTimers = jestFakeTimersAreEnabled();
      if (usingJestFakeTimers) {
        const {
          unstable_advanceTimersWrapper: advanceTimersWrapper
        } = getConfig();
        checkCallback();
        while (!finished) {
          if (!jestFakeTimersAreEnabled()) {
            const error = new Error("Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
            if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);
            reject(error);
            return;
          }
          await advanceTimersWrapper(async () => {
            jest.advanceTimersByTime(interval);
          });
          if (finished) {
            break;
          }
          checkCallback();
        }
      } else {
        try {
          checkContainerType(container);
        } catch (e) {
          reject(e);
          return;
        }
        intervalId = setInterval(checkRealTimersCallback, interval);
        const {
          MutationObserver: MutationObserver2
        } = getWindowFromNode(container);
        observer = new MutationObserver2(checkRealTimersCallback);
        observer.observe(container, mutationObserverOptions);
        checkCallback();
      }
      function onDone(error, result) {
        finished = true;
        clearTimeout(overallTimeoutTimer);
        if (!usingJestFakeTimers) {
          clearInterval(intervalId);
          observer.disconnect();
        }
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      }
      function checkRealTimersCallback() {
        if (jestFakeTimersAreEnabled()) {
          const error = new Error("Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
          if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);
          return reject(error);
        } else {
          return checkCallback();
        }
      }
      function checkCallback() {
        if (promiseStatus === "pending") return;
        try {
          const result = runWithExpensiveErrorDiagnosticsDisabled(callback);
          if (typeof (result == null ? void 0 : result.then) === "function") {
            promiseStatus = "pending";
            result.then((resolvedValue) => {
              promiseStatus = "resolved";
              onDone(null, resolvedValue);
            }, (rejectedValue) => {
              promiseStatus = "rejected";
              lastError2 = rejectedValue;
            });
          } else {
            onDone(null, result);
          }
        } catch (error) {
          lastError2 = error;
        }
      }
      function handleTimeout() {
        let error;
        if (lastError2) {
          error = lastError2;
          if (!showOriginalStackTrace && error.name === "TestingLibraryElementError") {
            copyStackTrace(error, stackTraceError);
          }
        } else {
          error = new Error("Timed out in waitFor.");
          if (!showOriginalStackTrace) {
            copyStackTrace(error, stackTraceError);
          }
        }
        onDone(onTimeout(error), null);
      }
    });
  }
  function waitForWrapper(callback, options) {
    const stackTraceError = new Error("STACK_TRACE_MESSAGE");
    return getConfig().asyncWrapper(() => waitFor(callback, {
      stackTraceError,
      ...options
    }));
  }
  function getElementError(message, container) {
    return getConfig().getElementError(message, container);
  }
  function getMultipleElementsFoundError(message, container) {
    return getElementError(message + "\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).", container);
  }
  function queryAllByAttribute(attribute, container, text, _temp) {
    let {
      exact = true,
      collapseWhitespace,
      trim,
      normalizer
    } = _temp === void 0 ? {} : _temp;
    const matcher = exact ? matches : fuzzyMatches;
    const matchNormalizer = makeNormalizer({
      collapseWhitespace,
      trim,
      normalizer
    });
    return Array.from(container.querySelectorAll("[" + attribute + "]")).filter((node) => matcher(node.getAttribute(attribute), node, text, matchNormalizer));
  }
  function makeSingleQuery(allQuery, getMultipleError2) {
    return function(container) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      const els = allQuery(container, ...args);
      if (els.length > 1) {
        const elementStrings = els.map((element) => getElementError(null, element).message).join("\n\n");
        throw getMultipleElementsFoundError(getMultipleError2(container, ...args) + "\n\nHere are the matching elements:\n\n" + elementStrings, container);
      }
      return els[0] || null;
    };
  }
  function getSuggestionError(suggestion, container) {
    return getConfig().getElementError("A better query is available, try this:\n" + suggestion.toString() + "\n", container);
  }
  function makeGetAllQuery(allQuery, getMissingError2) {
    return function(container) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      const els = allQuery(container, ...args);
      if (!els.length) {
        throw getConfig().getElementError(getMissingError2(container, ...args), container);
      }
      return els;
    };
  }
  function makeFindQuery(getter) {
    return (container, text, options, waitForOptions) => {
      return waitForWrapper(() => {
        return getter(container, text, options);
      }, {
        container,
        ...waitForOptions
      });
    };
  }
  var wrapSingleQueryWithSuggestion = (query2, queryAllByName, variant) => function(container) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    const element = query2(container, ...args);
    const [{
      suggest = getConfig().throwSuggestions
    } = {}] = args.slice(-1);
    if (element && suggest) {
      const suggestion = getSuggestedQuery(element, variant);
      if (suggestion && !queryAllByName.endsWith(suggestion.queryName)) {
        throw getSuggestionError(suggestion.toString(), container);
      }
    }
    return element;
  };
  var wrapAllByQueryWithSuggestion = (query2, queryAllByName, variant) => function(container) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }
    const els = query2(container, ...args);
    const [{
      suggest = getConfig().throwSuggestions
    } = {}] = args.slice(-1);
    if (els.length && suggest) {
      const uniqueSuggestionMessages = [...new Set(els.map((element) => {
        var _getSuggestedQuery;
        return (_getSuggestedQuery = getSuggestedQuery(element, variant)) == null ? void 0 : _getSuggestedQuery.toString();
      }))];
      if (
        // only want to suggest if all the els have the same suggestion.
        uniqueSuggestionMessages.length === 1 && !queryAllByName.endsWith(
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TODO: Can this be null at runtime?
          getSuggestedQuery(els[0], variant).queryName
        )
      ) {
        throw getSuggestionError(uniqueSuggestionMessages[0], container);
      }
    }
    return els;
  };
  function buildQueries(queryAllBy, getMultipleError2, getMissingError2) {
    const queryBy = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllBy, getMultipleError2), queryAllBy.name, "query");
    const getAllBy = makeGetAllQuery(queryAllBy, getMissingError2);
    const getBy = makeSingleQuery(getAllBy, getMultipleError2);
    const getByWithSuggestions = wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "get");
    const getAllWithSuggestions = wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name.replace("query", "get"), "getAll");
    const findAllBy = makeFindQuery(wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name, "findAll"));
    const findBy = makeFindQuery(wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "find"));
    return [queryBy, getAllWithSuggestions, getByWithSuggestions, findAllBy, findBy];
  }
  function queryAllLabels(container) {
    return Array.from(container.querySelectorAll("label,input")).map((node) => {
      return {
        node,
        textToMatch: getLabelContent(node)
      };
    }).filter((_ref) => {
      let {
        textToMatch
      } = _ref;
      return textToMatch !== null;
    });
  }
  var queryAllLabelsByText = function(container, text, _temp) {
    let {
      exact = true,
      trim,
      collapseWhitespace,
      normalizer
    } = _temp === void 0 ? {} : _temp;
    const matcher = exact ? matches : fuzzyMatches;
    const matchNormalizer = makeNormalizer({
      collapseWhitespace,
      trim,
      normalizer
    });
    const textToMatchByLabels = queryAllLabels(container);
    return textToMatchByLabels.filter((_ref2) => {
      let {
        node,
        textToMatch
      } = _ref2;
      return matcher(textToMatch, node, text, matchNormalizer);
    }).map((_ref3) => {
      let {
        node
      } = _ref3;
      return node;
    });
  };
  var queryAllByLabelText = function(container, text, _temp2) {
    let {
      selector = "*",
      exact = true,
      collapseWhitespace,
      trim,
      normalizer
    } = _temp2 === void 0 ? {} : _temp2;
    checkContainerType(container);
    const matcher = exact ? matches : fuzzyMatches;
    const matchNormalizer = makeNormalizer({
      collapseWhitespace,
      trim,
      normalizer
    });
    const matchingLabelledElements = Array.from(container.querySelectorAll("*")).filter((element) => {
      return getRealLabels(element).length || element.hasAttribute("aria-labelledby");
    }).reduce((labelledElements, labelledElement) => {
      const labelList = getLabels2(container, labelledElement, {
        selector
      });
      labelList.filter((label) => Boolean(label.formControl)).forEach((label) => {
        if (matcher(label.content, label.formControl, text, matchNormalizer) && label.formControl) {
          labelledElements.push(label.formControl);
        }
      });
      const labelsValue = labelList.filter((label) => Boolean(label.content)).map((label) => label.content);
      if (matcher(labelsValue.join(" "), labelledElement, text, matchNormalizer)) {
        labelledElements.push(labelledElement);
      }
      if (labelsValue.length > 1) {
        labelsValue.forEach((labelValue, index) => {
          if (matcher(labelValue, labelledElement, text, matchNormalizer)) {
            labelledElements.push(labelledElement);
          }
          const labelsFiltered = [...labelsValue];
          labelsFiltered.splice(index, 1);
          if (labelsFiltered.length > 1) {
            if (matcher(labelsFiltered.join(" "), labelledElement, text, matchNormalizer)) {
              labelledElements.push(labelledElement);
            }
          }
        });
      }
      return labelledElements;
    }, []).concat(queryAllByAttribute("aria-label", container, text, {
      exact,
      normalizer: matchNormalizer
    }));
    return Array.from(new Set(matchingLabelledElements)).filter((element) => element.matches(selector));
  };
  var getAllByLabelText = function(container, text) {
    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      rest[_key - 2] = arguments[_key];
    }
    const els = queryAllByLabelText(container, text, ...rest);
    if (!els.length) {
      const labels = queryAllLabelsByText(container, text, ...rest);
      if (labels.length) {
        const tagNames = labels.map((label) => getTagNameOfElementAssociatedWithLabelViaFor(container, label)).filter((tagName) => !!tagName);
        if (tagNames.length) {
          throw getConfig().getElementError(tagNames.map((tagName) => "Found a label with the text of: " + text + ", however the element associated with this label (<" + tagName + " />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <" + tagName + " />, you can use aria-label or aria-labelledby instead.").join("\n\n"), container);
        } else {
          throw getConfig().getElementError("Found a label with the text of: " + text + `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`, container);
        }
      } else {
        throw getConfig().getElementError("Unable to find a label with the text of: " + text, container);
      }
    }
    return els;
  };
  function getTagNameOfElementAssociatedWithLabelViaFor(container, label) {
    const htmlFor = label.getAttribute("for");
    if (!htmlFor) {
      return null;
    }
    const element = container.querySelector('[id="' + htmlFor + '"]');
    return element ? element.tagName.toLowerCase() : null;
  }
  var getMultipleError$7 = (c, text) => "Found multiple elements with the text of: " + text;
  var queryByLabelText = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllByLabelText, getMultipleError$7), queryAllByLabelText.name, "query");
  var getByLabelText = makeSingleQuery(getAllByLabelText, getMultipleError$7);
  var findAllByLabelText = makeFindQuery(wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "findAll"));
  var findByLabelText = makeFindQuery(wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "find"));
  var getAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "getAll");
  var getByLabelTextWithSuggestions = wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "get");
  var queryAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByLabelText, queryAllByLabelText.name, "queryAll");
  var queryAllByPlaceholderText = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    checkContainerType(args[0]);
    return queryAllByAttribute("placeholder", ...args);
  };
  var getMultipleError$6 = (c, text) => "Found multiple elements with the placeholder text of: " + text;
  var getMissingError$6 = (c, text) => "Unable to find an element with the placeholder text of: " + text;
  var queryAllByPlaceholderTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByPlaceholderText, queryAllByPlaceholderText.name, "queryAll");
  var [queryByPlaceholderText, getAllByPlaceholderText, getByPlaceholderText, findAllByPlaceholderText, findByPlaceholderText] = buildQueries(queryAllByPlaceholderText, getMultipleError$6, getMissingError$6);
  var queryAllByText = function(container, text, _temp) {
    let {
      selector = "*",
      exact = true,
      collapseWhitespace,
      trim,
      ignore = getConfig().defaultIgnore,
      normalizer
    } = _temp === void 0 ? {} : _temp;
    checkContainerType(container);
    const matcher = exact ? matches : fuzzyMatches;
    const matchNormalizer = makeNormalizer({
      collapseWhitespace,
      trim,
      normalizer
    });
    let baseArray = [];
    if (typeof container.matches === "function" && container.matches(selector)) {
      baseArray = [container];
    }
    return [...baseArray, ...Array.from(container.querySelectorAll(selector))].filter((node) => !ignore || !node.matches(ignore)).filter((node) => matcher(getNodeText(node), node, text, matchNormalizer));
  };
  var getMultipleError$5 = (c, text) => "Found multiple elements with the text: " + text;
  var getMissingError$5 = function(c, text, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      collapseWhitespace,
      trim,
      normalizer,
      selector
    } = options;
    const matchNormalizer = makeNormalizer({
      collapseWhitespace,
      trim,
      normalizer
    });
    const normalizedText = matchNormalizer(text.toString());
    const isNormalizedDifferent = normalizedText !== text.toString();
    const isCustomSelector = (selector != null ? selector : "*") !== "*";
    return "Unable to find an element with the text: " + (isNormalizedDifferent ? normalizedText + " (normalized from '" + text + "')" : text) + (isCustomSelector ? ", which matches selector '" + selector + "'" : "") + ". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.";
  };
  var queryAllByTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByText, queryAllByText.name, "queryAll");
  var [queryByText, getAllByText, getByText, findAllByText, findByText] = buildQueries(queryAllByText, getMultipleError$5, getMissingError$5);
  var queryAllByDisplayValue = function(container, value, _temp) {
    let {
      exact = true,
      collapseWhitespace,
      trim,
      normalizer
    } = _temp === void 0 ? {} : _temp;
    checkContainerType(container);
    const matcher = exact ? matches : fuzzyMatches;
    const matchNormalizer = makeNormalizer({
      collapseWhitespace,
      trim,
      normalizer
    });
    return Array.from(container.querySelectorAll("input,textarea,select")).filter((node) => {
      if (node.tagName === "SELECT") {
        const selectedOptions = Array.from(node.options).filter((option) => option.selected);
        return selectedOptions.some((optionNode) => matcher(getNodeText(optionNode), optionNode, value, matchNormalizer));
      } else {
        return matcher(node.value, node, value, matchNormalizer);
      }
    });
  };
  var getMultipleError$4 = (c, value) => "Found multiple elements with the display value: " + value + ".";
  var getMissingError$4 = (c, value) => "Unable to find an element with the display value: " + value + ".";
  var queryAllByDisplayValueWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByDisplayValue, queryAllByDisplayValue.name, "queryAll");
  var [queryByDisplayValue, getAllByDisplayValue, getByDisplayValue, findAllByDisplayValue, findByDisplayValue] = buildQueries(queryAllByDisplayValue, getMultipleError$4, getMissingError$4);
  var VALID_TAG_REGEXP = /^(img|input|area|.+-.+)$/i;
  var queryAllByAltText = function(container, alt, options) {
    if (options === void 0) {
      options = {};
    }
    checkContainerType(container);
    return queryAllByAttribute("alt", container, alt, options).filter((node) => VALID_TAG_REGEXP.test(node.tagName));
  };
  var getMultipleError$3 = (c, alt) => "Found multiple elements with the alt text: " + alt;
  var getMissingError$3 = (c, alt) => "Unable to find an element with the alt text: " + alt;
  var queryAllByAltTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByAltText, queryAllByAltText.name, "queryAll");
  var [queryByAltText, getAllByAltText, getByAltText, findAllByAltText, findByAltText] = buildQueries(queryAllByAltText, getMultipleError$3, getMissingError$3);
  var isSvgTitle = (node) => {
    var _node$parentElement;
    return node.tagName.toLowerCase() === "title" && ((_node$parentElement = node.parentElement) == null ? void 0 : _node$parentElement.tagName.toLowerCase()) === "svg";
  };
  var queryAllByTitle = function(container, text, _temp) {
    let {
      exact = true,
      collapseWhitespace,
      trim,
      normalizer
    } = _temp === void 0 ? {} : _temp;
    checkContainerType(container);
    const matcher = exact ? matches : fuzzyMatches;
    const matchNormalizer = makeNormalizer({
      collapseWhitespace,
      trim,
      normalizer
    });
    return Array.from(container.querySelectorAll("[title], svg > title")).filter((node) => matcher(node.getAttribute("title"), node, text, matchNormalizer) || isSvgTitle(node) && matcher(getNodeText(node), node, text, matchNormalizer));
  };
  var getMultipleError$2 = (c, title) => "Found multiple elements with the title: " + title + ".";
  var getMissingError$2 = (c, title) => "Unable to find an element with the title: " + title + ".";
  var queryAllByTitleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTitle, queryAllByTitle.name, "queryAll");
  var [queryByTitle, getAllByTitle, getByTitle, findAllByTitle, findByTitle] = buildQueries(queryAllByTitle, getMultipleError$2, getMissingError$2);
  var queryAllByRole = function(container, role, _temp) {
    let {
      hidden = getConfig().defaultHidden,
      name,
      description,
      queryFallbacks = false,
      selected,
      busy,
      checked,
      pressed,
      current,
      level,
      expanded,
      value: {
        now: valueNow,
        min: valueMin,
        max: valueMax,
        text: valueText
      } = {}
    } = _temp === void 0 ? {} : _temp;
    checkContainerType(container);
    if (selected !== void 0) {
      var _allRoles$get;
      if (((_allRoles$get = import_aria_query.roles.get(role)) == null ? void 0 : _allRoles$get.props["aria-selected"]) === void 0) {
        throw new Error('"aria-selected" is not supported on role "' + role + '".');
      }
    }
    if (busy !== void 0) {
      var _allRoles$get2;
      if (((_allRoles$get2 = import_aria_query.roles.get(role)) == null ? void 0 : _allRoles$get2.props["aria-busy"]) === void 0) {
        throw new Error('"aria-busy" is not supported on role "' + role + '".');
      }
    }
    if (checked !== void 0) {
      var _allRoles$get3;
      if (((_allRoles$get3 = import_aria_query.roles.get(role)) == null ? void 0 : _allRoles$get3.props["aria-checked"]) === void 0) {
        throw new Error('"aria-checked" is not supported on role "' + role + '".');
      }
    }
    if (pressed !== void 0) {
      var _allRoles$get4;
      if (((_allRoles$get4 = import_aria_query.roles.get(role)) == null ? void 0 : _allRoles$get4.props["aria-pressed"]) === void 0) {
        throw new Error('"aria-pressed" is not supported on role "' + role + '".');
      }
    }
    if (current !== void 0) {
      var _allRoles$get5;
      if (((_allRoles$get5 = import_aria_query.roles.get(role)) == null ? void 0 : _allRoles$get5.props["aria-current"]) === void 0) {
        throw new Error('"aria-current" is not supported on role "' + role + '".');
      }
    }
    if (level !== void 0) {
      if (role !== "heading") {
        throw new Error('Role "' + role + '" cannot have "level" property.');
      }
    }
    if (valueNow !== void 0) {
      var _allRoles$get6;
      if (((_allRoles$get6 = import_aria_query.roles.get(role)) == null ? void 0 : _allRoles$get6.props["aria-valuenow"]) === void 0) {
        throw new Error('"aria-valuenow" is not supported on role "' + role + '".');
      }
    }
    if (valueMax !== void 0) {
      var _allRoles$get7;
      if (((_allRoles$get7 = import_aria_query.roles.get(role)) == null ? void 0 : _allRoles$get7.props["aria-valuemax"]) === void 0) {
        throw new Error('"aria-valuemax" is not supported on role "' + role + '".');
      }
    }
    if (valueMin !== void 0) {
      var _allRoles$get8;
      if (((_allRoles$get8 = import_aria_query.roles.get(role)) == null ? void 0 : _allRoles$get8.props["aria-valuemin"]) === void 0) {
        throw new Error('"aria-valuemin" is not supported on role "' + role + '".');
      }
    }
    if (valueText !== void 0) {
      var _allRoles$get9;
      if (((_allRoles$get9 = import_aria_query.roles.get(role)) == null ? void 0 : _allRoles$get9.props["aria-valuetext"]) === void 0) {
        throw new Error('"aria-valuetext" is not supported on role "' + role + '".');
      }
    }
    if (expanded !== void 0) {
      var _allRoles$get0;
      if (((_allRoles$get0 = import_aria_query.roles.get(role)) == null ? void 0 : _allRoles$get0.props["aria-expanded"]) === void 0) {
        throw new Error('"aria-expanded" is not supported on role "' + role + '".');
      }
    }
    const subtreeIsInaccessibleCache = /* @__PURE__ */ new WeakMap();
    function cachedIsSubtreeInaccessible(element) {
      if (!subtreeIsInaccessibleCache.has(element)) {
        subtreeIsInaccessibleCache.set(element, isSubtreeInaccessible(element));
      }
      return subtreeIsInaccessibleCache.get(element);
    }
    return Array.from(container.querySelectorAll(
      // Only query elements that can be matched by the following filters
      makeRoleSelector(role)
    )).filter((node) => {
      const isRoleSpecifiedExplicitly = node.hasAttribute("role");
      if (isRoleSpecifiedExplicitly) {
        const roleValue = node.getAttribute("role");
        if (queryFallbacks) {
          return roleValue.split(" ").filter(Boolean).some((roleAttributeToken) => roleAttributeToken === role);
        }
        const [firstRoleAttributeToken] = roleValue.split(" ");
        return firstRoleAttributeToken === role;
      }
      const implicitRoles = getImplicitAriaRoles(node);
      return implicitRoles.some((implicitRole) => {
        return implicitRole === role;
      });
    }).filter((element) => {
      if (selected !== void 0) {
        return selected === computeAriaSelected(element);
      }
      if (busy !== void 0) {
        return busy === computeAriaBusy(element);
      }
      if (checked !== void 0) {
        return checked === computeAriaChecked(element);
      }
      if (pressed !== void 0) {
        return pressed === computeAriaPressed(element);
      }
      if (current !== void 0) {
        return current === computeAriaCurrent(element);
      }
      if (expanded !== void 0) {
        return expanded === computeAriaExpanded(element);
      }
      if (level !== void 0) {
        return level === computeHeadingLevel(element);
      }
      if (valueNow !== void 0 || valueMax !== void 0 || valueMin !== void 0 || valueText !== void 0) {
        let valueMatches = true;
        if (valueNow !== void 0) {
          valueMatches && (valueMatches = valueNow === computeAriaValueNow(element));
        }
        if (valueMax !== void 0) {
          valueMatches && (valueMatches = valueMax === computeAriaValueMax(element));
        }
        if (valueMin !== void 0) {
          valueMatches && (valueMatches = valueMin === computeAriaValueMin(element));
        }
        if (valueText !== void 0) {
          var _computeAriaValueText;
          valueMatches && (valueMatches = matches((_computeAriaValueText = computeAriaValueText(element)) != null ? _computeAriaValueText : null, element, valueText, (text) => text));
        }
        return valueMatches;
      }
      return true;
    }).filter((element) => {
      if (name === void 0) {
        return true;
      }
      return matches(computeAccessibleName(element, {
        computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
      }), element, name, (text) => text);
    }).filter((element) => {
      if (description === void 0) {
        return true;
      }
      return matches(computeAccessibleDescription(element, {
        computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
      }), element, description, (text) => text);
    }).filter((element) => {
      return hidden === false ? isInaccessible(element, {
        isSubtreeInaccessible: cachedIsSubtreeInaccessible
      }) === false : true;
    });
  };
  function makeRoleSelector(role) {
    var _roleElements$get;
    const explicitRoleSelector = '*[role~="' + role + '"]';
    const roleRelations = (_roleElements$get = import_aria_query.roleElements.get(role)) != null ? _roleElements$get : /* @__PURE__ */ new Set();
    const implicitRoleSelectors = new Set(Array.from(roleRelations).map((_ref) => {
      let {
        name
      } = _ref;
      return name;
    }));
    return [explicitRoleSelector].concat(Array.from(implicitRoleSelectors)).join(",");
  }
  var getNameHint = (name) => {
    let nameHint = "";
    if (name === void 0) {
      nameHint = "";
    } else if (typeof name === "string") {
      nameHint = ' and name "' + name + '"';
    } else {
      nameHint = " and name `" + name + "`";
    }
    return nameHint;
  };
  var getMultipleError$1 = function(c, role, _temp2) {
    let {
      name
    } = _temp2 === void 0 ? {} : _temp2;
    return 'Found multiple elements with the role "' + role + '"' + getNameHint(name);
  };
  var getMissingError$1 = function(container, role, _temp3) {
    let {
      hidden = getConfig().defaultHidden,
      name,
      description
    } = _temp3 === void 0 ? {} : _temp3;
    if (getConfig()._disableExpensiveErrorDiagnostics) {
      return 'Unable to find role="' + role + '"' + getNameHint(name);
    }
    let roles2 = "";
    Array.from(container.children).forEach((childElement) => {
      roles2 += prettyRoles(childElement, {
        hidden,
        includeDescription: description !== void 0
      });
    });
    let roleMessage;
    if (roles2.length === 0) {
      if (hidden === false) {
        roleMessage = "There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole";
      } else {
        roleMessage = "There are no available roles.";
      }
    } else {
      roleMessage = ("\nHere are the " + (hidden === false ? "accessible" : "available") + " roles:\n\n  " + roles2.replace(/\n/g, "\n  ").replace(/\n\s\s\n/g, "\n\n") + "\n").trim();
    }
    let nameHint = "";
    if (name === void 0) {
      nameHint = "";
    } else if (typeof name === "string") {
      nameHint = ' and name "' + name + '"';
    } else {
      nameHint = " and name `" + name + "`";
    }
    let descriptionHint = "";
    if (description === void 0) {
      descriptionHint = "";
    } else if (typeof description === "string") {
      descriptionHint = ' and description "' + description + '"';
    } else {
      descriptionHint = " and description `" + description + "`";
    }
    return ("\nUnable to find an " + (hidden === false ? "accessible " : "") + 'element with the role "' + role + '"' + nameHint + descriptionHint + "\n\n" + roleMessage).trim();
  };
  var queryAllByRoleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByRole, queryAllByRole.name, "queryAll");
  var [queryByRole, getAllByRole, getByRole, findAllByRole, findByRole] = buildQueries(queryAllByRole, getMultipleError$1, getMissingError$1);
  var getTestIdAttribute = () => getConfig().testIdAttribute;
  var queryAllByTestId = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    checkContainerType(args[0]);
    return queryAllByAttribute(getTestIdAttribute(), ...args);
  };
  var getMultipleError = (c, id) => "Found multiple elements by: [" + getTestIdAttribute() + '="' + id + '"]';
  var getMissingError = (c, id) => "Unable to find an element by: [" + getTestIdAttribute() + '="' + id + '"]';
  var queryAllByTestIdWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTestId, queryAllByTestId.name, "queryAll");
  var [queryByTestId, getAllByTestId, getByTestId, findAllByTestId, findByTestId] = buildQueries(queryAllByTestId, getMultipleError, getMissingError);
  var queries = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    queryAllByLabelText: queryAllByLabelTextWithSuggestions,
    queryByLabelText,
    getAllByLabelText: getAllByLabelTextWithSuggestions,
    getByLabelText: getByLabelTextWithSuggestions,
    findAllByLabelText,
    findByLabelText,
    queryByPlaceholderText,
    queryAllByPlaceholderText: queryAllByPlaceholderTextWithSuggestions,
    getByPlaceholderText,
    getAllByPlaceholderText,
    findAllByPlaceholderText,
    findByPlaceholderText,
    queryByText,
    queryAllByText: queryAllByTextWithSuggestions,
    getByText,
    getAllByText,
    findAllByText,
    findByText,
    queryByDisplayValue,
    queryAllByDisplayValue: queryAllByDisplayValueWithSuggestions,
    getByDisplayValue,
    getAllByDisplayValue,
    findAllByDisplayValue,
    findByDisplayValue,
    queryByAltText,
    queryAllByAltText: queryAllByAltTextWithSuggestions,
    getByAltText,
    getAllByAltText,
    findAllByAltText,
    findByAltText,
    queryByTitle,
    queryAllByTitle: queryAllByTitleWithSuggestions,
    getByTitle,
    getAllByTitle,
    findAllByTitle,
    findByTitle,
    queryByRole,
    queryAllByRole: queryAllByRoleWithSuggestions,
    getAllByRole,
    getByRole,
    findAllByRole,
    findByRole,
    queryByTestId,
    queryAllByTestId: queryAllByTestIdWithSuggestions,
    getByTestId,
    getAllByTestId,
    findAllByTestId,
    findByTestId
  });
  function getQueriesForElement(element, queries$1, initialValue2) {
    if (queries$1 === void 0) {
      queries$1 = queries;
    }
    if (initialValue2 === void 0) {
      initialValue2 = {};
    }
    return Object.keys(queries$1).reduce((helpers, key) => {
      const fn = queries$1[key];
      helpers[key] = fn.bind(null, element);
      return helpers;
    }, initialValue2);
  }
  var eventMap = {
    // Clipboard Events
    copy: {
      EventType: "ClipboardEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    cut: {
      EventType: "ClipboardEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    paste: {
      EventType: "ClipboardEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    // Composition Events
    compositionEnd: {
      EventType: "CompositionEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    compositionStart: {
      EventType: "CompositionEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    compositionUpdate: {
      EventType: "CompositionEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    // Keyboard Events
    keyDown: {
      EventType: "KeyboardEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        charCode: 0,
        composed: true
      }
    },
    keyPress: {
      EventType: "KeyboardEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        charCode: 0,
        composed: true
      }
    },
    keyUp: {
      EventType: "KeyboardEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        charCode: 0,
        composed: true
      }
    },
    // Focus Events
    focus: {
      EventType: "FocusEvent",
      defaultInit: {
        bubbles: false,
        cancelable: false,
        composed: true
      }
    },
    blur: {
      EventType: "FocusEvent",
      defaultInit: {
        bubbles: false,
        cancelable: false,
        composed: true
      }
    },
    focusIn: {
      EventType: "FocusEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false,
        composed: true
      }
    },
    focusOut: {
      EventType: "FocusEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false,
        composed: true
      }
    },
    // Form Events
    change: {
      EventType: "Event",
      defaultInit: {
        bubbles: true,
        cancelable: false
      }
    },
    input: {
      EventType: "InputEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false,
        composed: true
      }
    },
    invalid: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: true
      }
    },
    submit: {
      EventType: "Event",
      defaultInit: {
        bubbles: true,
        cancelable: true
      }
    },
    reset: {
      EventType: "Event",
      defaultInit: {
        bubbles: true,
        cancelable: true
      }
    },
    // Mouse Events
    click: {
      EventType: "MouseEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        button: 0,
        composed: true
      }
    },
    contextMenu: {
      EventType: "MouseEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    dblClick: {
      EventType: "MouseEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    drag: {
      EventType: "DragEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    dragEnd: {
      EventType: "DragEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false,
        composed: true
      }
    },
    dragEnter: {
      EventType: "DragEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    dragExit: {
      EventType: "DragEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false,
        composed: true
      }
    },
    dragLeave: {
      EventType: "DragEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false,
        composed: true
      }
    },
    dragOver: {
      EventType: "DragEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    dragStart: {
      EventType: "DragEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    drop: {
      EventType: "DragEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    mouseDown: {
      EventType: "MouseEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    mouseEnter: {
      EventType: "MouseEvent",
      defaultInit: {
        bubbles: false,
        cancelable: false,
        composed: true
      }
    },
    mouseLeave: {
      EventType: "MouseEvent",
      defaultInit: {
        bubbles: false,
        cancelable: false,
        composed: true
      }
    },
    mouseMove: {
      EventType: "MouseEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    mouseOut: {
      EventType: "MouseEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    mouseOver: {
      EventType: "MouseEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    mouseUp: {
      EventType: "MouseEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    // Selection Events
    select: {
      EventType: "Event",
      defaultInit: {
        bubbles: true,
        cancelable: false
      }
    },
    // Touch Events
    touchCancel: {
      EventType: "TouchEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false,
        composed: true
      }
    },
    touchEnd: {
      EventType: "TouchEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    touchMove: {
      EventType: "TouchEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    touchStart: {
      EventType: "TouchEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    // UI Events
    resize: {
      EventType: "UIEvent",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    scroll: {
      EventType: "UIEvent",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    // Wheel Events
    wheel: {
      EventType: "WheelEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    // Media Events
    abort: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    canPlay: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    canPlayThrough: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    durationChange: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    emptied: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    encrypted: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    ended: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    loadedData: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    loadedMetadata: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    loadStart: {
      EventType: "ProgressEvent",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    pause: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    play: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    playing: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    progress: {
      EventType: "ProgressEvent",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    rateChange: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    seeked: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    seeking: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    stalled: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    suspend: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    timeUpdate: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    volumeChange: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    waiting: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    // Events
    load: {
      // TODO: load events can be UIEvent or Event depending on what generated them
      // This is where this abstraction breaks down.
      // But the common targets are <img />, <script /> and window.
      // Neither of these targets receive a UIEvent
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    error: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    // Animation Events
    animationStart: {
      EventType: "AnimationEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false
      }
    },
    animationEnd: {
      EventType: "AnimationEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false
      }
    },
    animationIteration: {
      EventType: "AnimationEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false
      }
    },
    // Transition Events
    transitionCancel: {
      EventType: "TransitionEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false
      }
    },
    transitionEnd: {
      EventType: "TransitionEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true
      }
    },
    transitionRun: {
      EventType: "TransitionEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false
      }
    },
    transitionStart: {
      EventType: "TransitionEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false
      }
    },
    // pointer events
    pointerOver: {
      EventType: "PointerEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    pointerEnter: {
      EventType: "PointerEvent",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    pointerDown: {
      EventType: "PointerEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    pointerMove: {
      EventType: "PointerEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    pointerUp: {
      EventType: "PointerEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    pointerCancel: {
      EventType: "PointerEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false,
        composed: true
      }
    },
    pointerOut: {
      EventType: "PointerEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true,
        composed: true
      }
    },
    pointerLeave: {
      EventType: "PointerEvent",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    gotPointerCapture: {
      EventType: "PointerEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false,
        composed: true
      }
    },
    lostPointerCapture: {
      EventType: "PointerEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false,
        composed: true
      }
    },
    // history events
    popState: {
      EventType: "PopStateEvent",
      defaultInit: {
        bubbles: true,
        cancelable: false
      }
    },
    // window events
    offline: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    online: {
      EventType: "Event",
      defaultInit: {
        bubbles: false,
        cancelable: false
      }
    },
    pageHide: {
      EventType: "PageTransitionEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true
      }
    },
    pageShow: {
      EventType: "PageTransitionEvent",
      defaultInit: {
        bubbles: true,
        cancelable: true
      }
    }
  };
  var eventAliasMap = {
    doubleClick: "dblClick"
  };
  function fireEvent(element, event) {
    return getConfig().eventWrapper(() => {
      if (!event) {
        throw new Error("Unable to fire an event - please provide an event object.");
      }
      if (!element) {
        throw new Error('Unable to fire a "' + event.type + '" event - please provide a DOM element.');
      }
      return element.dispatchEvent(event);
    });
  }
  function createEvent(eventName, node, init, _temp) {
    let {
      EventType = "Event",
      defaultInit = {}
    } = _temp === void 0 ? {} : _temp;
    if (!node) {
      throw new Error('Unable to fire a "' + eventName + '" event - please provide a DOM element.');
    }
    const eventInit = {
      ...defaultInit,
      ...init
    };
    const {
      target: {
        value,
        files,
        ...targetProperties
      } = {}
    } = eventInit;
    if (value !== void 0) {
      setNativeValue(node, value);
    }
    if (files !== void 0) {
      Object.defineProperty(node, "files", {
        configurable: true,
        enumerable: true,
        writable: true,
        value: files
      });
    }
    Object.assign(node, targetProperties);
    const window2 = getWindowFromNode(node);
    const EventConstructor = window2[EventType] || window2.Event;
    let event;
    if (typeof EventConstructor === "function") {
      event = new EventConstructor(eventName, eventInit);
    } else {
      event = window2.document.createEvent(EventType);
      const {
        bubbles,
        cancelable,
        detail,
        ...otherInit
      } = eventInit;
      event.initEvent(eventName, bubbles, cancelable, detail);
      Object.keys(otherInit).forEach((eventKey) => {
        event[eventKey] = otherInit[eventKey];
      });
    }
    const dataTransferProperties = ["dataTransfer", "clipboardData"];
    dataTransferProperties.forEach((dataTransferKey) => {
      const dataTransferValue = eventInit[dataTransferKey];
      if (typeof dataTransferValue === "object") {
        if (typeof window2.DataTransfer === "function") {
          Object.defineProperty(event, dataTransferKey, {
            value: Object.getOwnPropertyNames(dataTransferValue).reduce((acc, propName) => {
              Object.defineProperty(acc, propName, {
                value: dataTransferValue[propName]
              });
              return acc;
            }, new window2.DataTransfer())
          });
        } else {
          Object.defineProperty(event, dataTransferKey, {
            value: dataTransferValue
          });
        }
      }
    });
    return event;
  }
  Object.keys(eventMap).forEach((key) => {
    const {
      EventType,
      defaultInit
    } = eventMap[key];
    const eventName = key.toLowerCase();
    createEvent[key] = (node, init) => createEvent(eventName, node, init, {
      EventType,
      defaultInit
    });
    fireEvent[key] = (node, init) => fireEvent(node, createEvent[key](node, init));
  });
  function setNativeValue(element, value) {
    const {
      set: valueSetter
    } = Object.getOwnPropertyDescriptor(element, "value") || {};
    const prototype = Object.getPrototypeOf(element);
    const {
      set: prototypeValueSetter
    } = Object.getOwnPropertyDescriptor(prototype, "value") || {};
    if (prototypeValueSetter && valueSetter !== prototypeValueSetter) {
      prototypeValueSetter.call(element, value);
    } else {
      if (valueSetter) {
        valueSetter.call(element, value);
      } else {
        throw new Error("The given element does not have a value setter");
      }
    }
  }
  Object.keys(eventAliasMap).forEach((aliasKey) => {
    const key = eventAliasMap[aliasKey];
    fireEvent[aliasKey] = function() {
      return fireEvent[key](...arguments);
    };
  });
  function unindent(string) {
    return string.replace(/[ \t]*[\n][ \t]*/g, "\n");
  }
  function encode(value) {
    return import_lz_string.default.compressToEncodedURIComponent(unindent(value));
  }
  function getPlaygroundUrl(markup) {
    return "https://testing-playground.com/#markup=" + encode(markup);
  }
  var debug = (element, maxLength, options) => Array.isArray(element) ? element.forEach((el) => logDOM(el, maxLength, options)) : logDOM(element, maxLength, options);
  var logTestingPlaygroundURL = function(element) {
    if (element === void 0) {
      element = getDocument().body;
    }
    if (!element || !("innerHTML" in element)) {
      console.log("The element you're providing isn't a valid DOM element.");
      return;
    }
    if (!element.innerHTML) {
      console.log("The provided element doesn't have any children.");
      return;
    }
    const playgroundUrl = getPlaygroundUrl(element.innerHTML);
    console.log("Open this URL in your browser\n\n" + playgroundUrl);
    return playgroundUrl;
  };
  var initialValue = {
    debug,
    logTestingPlaygroundURL
  };
  var screen = typeof document !== "undefined" && document.body ? getQueriesForElement(document.body, queries, initialValue) : Object.keys(queries).reduce((helpers, key) => {
    helpers[key] = () => {
      throw new TypeError("For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error");
    };
    return helpers;
  }, initialValue);

  // tests/dom.test.ts
  var import_mocha = __toESM(require_mocha());

  // src/dom.ts
  var dynamicImportScripts = async (names) => {
    const result = /* @__PURE__ */ new Map();
    for (let i = 0; i < names.length; ++i) {
      const scripts = Array.from(queryAll("script[src]"));
      const matchingScript = scripts.find((script) => {
        const src = script.getAttribute("src") ?? "";
        const filename = src.split("/").pop() ?? "";
        return filename === `${names[i]}.js`;
      });
      const scriptLocation = matchingScript?.getAttribute("src");
      let f = null;
      if (scriptLocation) {
        try {
          const moduleUrl = new URL(scriptLocation, document.baseURI).href;
          const exports = await import(moduleUrl);
          for (const exported of Object.keys(exports)) {
            f = exports[exported];
            break;
          }
          result.set(names[i], f);
        } catch (e) {
          console.error(`Unable to import "${scriptLocation}"`, e);
        }
      }
    }
    return result;
  };
  var registerTemplates = async (webComponentFactory, options) => {
    const isLLMBuild = typeof __LLM__ !== "undefined" && __LLM__;
    const shouldMirrorAttributes = options?.mirrorAttributes ?? !isLLMBuild;
    const names = [];
    const inlineLogic = /* @__PURE__ */ new Map();
    const templates = Array.from(queryAll("template[data-component]")).filter((elem) => elem instanceof HTMLElement);
    for (const t of templates) {
      let name = "";
      const attributes = [];
      for (const attribute in t.dataset) {
        if (attribute === "component") {
          name = t.dataset[attribute] ?? "";
        } else if (shouldMirrorAttributes) {
          attributes.push([
            decamelize(attribute),
            t.dataset[attribute] ?? ""
          ]);
        }
      }
      if (!name) {
        console.error(`Invalid <template> found: missing data-component`, t);
        continue;
      }
      if (isTemplate(t)) {
        const script = t.content.querySelector("script");
        if (script) {
          const code = script.textContent;
          if (code && code.trim().length > 0) {
            try {
              const blob = new Blob([code], { type: "text/javascript" });
              const url = URL.createObjectURL(blob);
              const module2 = await import(url);
              URL.revokeObjectURL(url);
              script.remove();
              let rawLogic = null;
              if (module2.default) {
                rawLogic = module2.default;
              } else {
                const keys = Object.keys(module2);
                if (keys.length > 0) {
                  rawLogic = module2[keys[0]];
                }
              }
              if (rawLogic) {
                const logic = webComponentFactory ? webComponentFactory(rawLogic) : rawLogic;
                inlineLogic.set(name, logic);
              }
            } catch (e) {
            }
          }
        }
      }
      component(name, { attributes });
      names.push(name);
    }
    return { names, inlineLogic };
  };
  var createComponent = (name, update) => {
    const element = create(name);
    if (!isBored(element)) {
      const error = `The tag name "${name}" is not a BoreDOM  component.
      
"createComponent" only accepts tag-names with matching <template> tags that have a data-component attribute in them.`;
      console.error(error);
      throw new Error(error);
    }
    if (update) {
      element.renderCallback = update;
    }
    return element;
  };
  var query = (query2) => document.querySelector(query2);
  var queryAll = (query2) => document.querySelectorAll(query2);
  var create = (tagName, children) => {
    const e = document.createElement(tagName);
    if (children && Array.isArray(children) && children.length > 0) {
      children.map((c) => e.appendChild(c));
    }
    return e;
  };
  var dispatch = (name, detail) => {
    if (document.readyState === "loading") {
      addEventListener(
        "DOMContentLoaded",
        () => dispatchEvent(new CustomEvent(name, { detail }))
      );
    } else {
      dispatchEvent(new CustomEvent(name, { detail }));
    }
  };
  var isTemplate = (e) => e instanceof HTMLTemplateElement;
  var isObject = (t) => typeof t === "object";
  var isFunction = (t) => typeof t === "function";
  var isBored = (t) => isObject(t) && "isBored" in t && Boolean(t.isBored);
  var decamelize = (str) => {
    if (str === "" || !str.split("").some((char) => char !== char.toLowerCase())) {
      return str;
    }
    let result = "";
    for (let i = 0; i < str.length; i++) {
      const char = str[i];
      if (char === char.toUpperCase() && i !== 0) {
        result += "-";
      }
      result += char.toLowerCase();
    }
    return result;
  };
  var isStartsWithOn = (s) => s.startsWith("on");
  var isStartsWithQueriedOn = (s) => s.startsWith("queriedOn");
  var getEventName = (s) => {
    if (isStartsWithOn(s)) {
      return s.slice(2).toLowerCase();
    }
    return s.slice(9).toLowerCase();
  };
  var Bored = class extends HTMLElement {
  };
  var component = (tag, props = {}) => {
    const isLLMBuild = typeof __LLM__ !== "undefined" && __LLM__;
    if (customElements.get(tag)) return;
    customElements.define(
      tag,
      class extends Bored {
        static get observedAttributes() {
          if (typeof props.attributeChangedCallback === "object") {
            return Object.keys(props.attributeChangedCallback);
          }
          return [];
        }
        constructor() {
          super();
        }
        isBored = true;
        traverse(f, { traverseShadowRoot, query: query2 } = {}) {
          Array.from(
            traverseShadowRoot ? this.shadowRoot?.querySelectorAll(query2 ?? "*") ?? [] : []
          ).concat(Array.from(this.querySelectorAll(query2 ?? "*"))).filter((n) => n instanceof HTMLElement).forEach(f);
        }
        #parseCustomEventNames(str) {
          return str.split("'").filter(
            (s) => s.length > 2 && !(s.includes("(") || s.includes(",") || s.includes(")"))
          );
        }
        #parseDirectEventNames(str) {
          return str.split(/[\s,]+/g).map((s) => s.trim()).filter(Boolean);
        }
        #parseEventNames(str) {
          const trimmed = str.trim();
          if (trimmed.length === 0) return [];
          if (trimmed.includes("dispatch(") || trimmed.includes("'")) {
            return this.#parseCustomEventNames(str);
          }
          return this.#parseDirectEventNames(str);
        }
        #createDispatchers() {
          let host;
          this.traverse((node) => {
            if (node instanceof HTMLElement) {
              const isWebComponent = customElements.get(
                node.tagName.toLowerCase()
              );
              if (isWebComponent) host = node;
              for (let i = 0; i < node.attributes.length; i++) {
                const attribute = node.attributes[i];
                const attributeName = attribute.name;
                const addDispatchers = (eventName, customEventNames) => {
                  if (customEventNames.length === 0) return;
                  customEventNames.forEach((customEventName) => {
                    node.addEventListener(
                      eventName,
                      (e) => dispatch(customEventName, {
                        event: e,
                        dispatcher: node,
                        component: this,
                        index: this.parentElement ? Array.from(this.parentElement.children).indexOf(
                          this
                        ) : -1
                      })
                    );
                  });
                };
                if (attributeName.startsWith("on-")) {
                  const eventName = attributeName.slice(3);
                  const eventNames = this.#parseEventNames(attribute.value);
                  addDispatchers(eventName, eventNames);
                  node.removeAttribute(attributeName);
                  continue;
                }
                if (attributeName === "data-dispatch" || attributeName.startsWith("data-dispatch-")) {
                  const eventName = attributeName === "data-dispatch" ? "click" : attributeName.slice("data-dispatch-".length);
                  const eventNames = this.#parseEventNames(attribute.value);
                  addDispatchers(eventName, eventNames);
                  node.removeAttribute(attributeName);
                  continue;
                }
                if (!isLLMBuild && isStartsWithOn(attribute.name)) {
                  const eventNames = this.#parseCustomEventNames(attribute.value);
                  if (eventNames.length > 0) {
                    addDispatchers(getEventName(attribute.name), eventNames);
                  }
                  node.setAttribute(
                    `data-${attributeName}-dispatches`,
                    eventNames.join()
                  );
                  node.removeAttribute(attributeName);
                }
              }
            }
          }, { traverseShadowRoot: true });
        }
        isInitialized = false;
        #init() {
          let template = query(`[data-component="${tag}"]`) ?? create("template");
          const isTemplateShadowRoot = isLLMBuild ? null : template.getAttribute("shadowrootmode");
          const isShadowRootNeeded = !isLLMBuild && (props.style || props.shadow || isTemplateShadowRoot);
          if (isShadowRootNeeded) {
            const shadowRootMode = props.shadowrootmode ?? isTemplateShadowRoot ?? "open";
            const shadowRoot = this.attachShadow({ mode: shadowRootMode });
            if (props.style) {
              const style = create("style");
              style.textContent = props.style;
              shadowRoot.appendChild(style);
            }
            if (props.shadow) {
              const tmp = create("template");
              tmp.innerHTML = props.shadow;
              shadowRoot.appendChild(tmp.content.cloneNode(true));
            } else if (isTemplateShadowRoot) {
              shadowRoot.appendChild(template.content.cloneNode(true));
            }
          }
          if (template && !isTemplateShadowRoot) {
            this.appendChild(template.content.cloneNode(true));
          }
          if (props.onSlotChange) {
            this.traverse((elem) => {
              if (!(elem instanceof HTMLSlotElement)) return;
              elem.addEventListener("slotchange", (e) => props.onSlotChange?.(e));
            }, { traverseShadowRoot: true });
          }
          if (isFunction(props.onClick)) {
            this.addEventListener("click", props.onClick);
          }
          for (const [key, value] of Object.entries(props)) {
            if (isStartsWithOn(key)) {
              if (!isFunction(value)) continue;
              this.addEventListener(getEventName(key), value);
            } else if (isStartsWithQueriedOn(key)) {
              if (isLLMBuild) continue;
              const queries2 = value;
              if (!isObject(queries2)) continue;
              const eventName = getEventName(key);
              for (const [query2, handler] of Object.entries(queries2)) {
                this.traverse((node) => {
                  node.addEventListener(eventName, handler);
                }, { traverseShadowRoot: true, query: query2 });
              }
            }
          }
          if (props.attributes && Array.isArray(props.attributes)) {
            props.attributes.map(
              ([attr, value]) => this.setAttribute(attr, value)
            );
          }
          this.#createDispatchers();
          this.isInitialized = true;
        }
        renderCallback = (_) => {
        };
        connectedCallback() {
          if (!this.isInitialized) this.#init();
          this.renderCallback(this);
          props.connectedCallback?.(this);
        }
        disconnectedCallback() {
          props.disconnectedCallback?.(this);
        }
        adoptedCallback() {
          props.adoptedCallback?.(this);
        }
        attributeChangedCallback(name, oldValue, newValue) {
          if (!props.attributeChangedCallback) return;
          props.attributeChangedCallback[name]({
            element: this,
            name,
            oldValue,
            newValue
          });
        }
      }
    );
  };
  var registerComponent = (tagName) => {
    component(tagName, {});
  };

  // src/utils/access.ts
  function access(path, obj) {
    let result = obj;
    if (obj === null) return result;
    path.forEach((attribute) => {
      result = result[attribute];
    });
    return result;
  }

  // src/bore.ts
  init_flatten();

  // src/utils/isPojo.ts
  function isPOJO(arg) {
    if (arg == null || typeof arg !== "object") {
      return false;
    }
    const proto = Object.getPrototypeOf(arg);
    if (proto == null) {
      return true;
    }
    return proto === Object.prototype;
  }

  // src/bore.ts
  var extractDetailData = (element) => {
    const data = {};
    for (const [key, value] of Object.entries(element.dataset)) {
      if (key.startsWith("prop")) continue;
      data[key] = value;
    }
    return data;
  };
  function createEventsHandler(c, app, detail) {
    return (eventName, handler) => {
      addEventListener(eventName, (event) => {
        let target = event?.detail?.event.currentTarget;
        let emiterElem = void 0;
        while (target) {
          if (target === c) {
            try {
              const maybePromise = handler({
                state: app,
                e: event.detail,
                detail
              });
              Promise.resolve(maybePromise).catch((error) => {
                console.error(
                  `Error in async handler for "${eventName}" event`,
                  error
                );
              });
            } catch (error) {
              console.error(`Error in handler for "${eventName}" event`, error);
            }
            return;
          }
          if (target instanceof HTMLElement) {
            target = target.parentElement;
          } else {
            target = void 0;
          }
        }
      });
    };
  }
  function createRefsAccessor(c) {
    return new Proxy({}, {
      get(target, prop, receiver) {
        const error = new Error(
          `Ref "${String(prop)}" not found in <${c.tagName}>`
        );
        if (typeof prop === "string") {
          const nodeList = c.querySelectorAll(`[data-ref="${prop}"]`);
          if (!nodeList) throw error;
          const refs = Array.from(nodeList).filter(
            (ref) => ref instanceof HTMLElement
          );
          if (refs.length === 0) throw error;
          if (refs.length === 1) return refs[0];
          return refs;
        }
      }
    });
  }
  function createSlotsAccessor(c) {
    return new Proxy({}, {
      get(target, prop, reciever) {
        const error = new Error(
          `Slot "${String(prop)}" not found in <${c.tagName}>`
        );
        if (typeof prop === "string") {
          const nodeList = c.querySelectorAll(`slot[name="${prop}"]`);
          if (!nodeList) throw error;
          const refs = Array.from(nodeList).filter(
            (ref) => ref instanceof HTMLSlotElement
          );
          if (refs.length === 0) throw error;
          if (refs.length === 1) return refs[0];
          return refs;
        }
      },
      set(target, prop, value) {
        if (typeof prop !== "string") return false;
        let elem = value;
        if (value instanceof HTMLElement) {
          value.setAttribute("data-slot", prop);
        } else if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          elem = create("span");
          elem.setAttribute("data-slot", prop);
          elem.innerText = String(value);
        } else {
          throw new Error(`Invalid value for slot ${prop} in <${c.tagName}>`);
        }
        const existingSlots = Array.from(
          c.querySelectorAll(`[data-slot="${prop}"]`)
        );
        if (existingSlots.length > 0) {
          existingSlots.forEach((s) => s.parentElement?.replaceChild(elem, s));
        } else {
          const slots = Array.from(c.querySelectorAll(`slot[name="${prop}"]`));
          slots.forEach((s) => s.parentElement?.replaceChild(elem, s));
        }
        return true;
      }
    });
  }
  function createStateAccessor(state, log, allowWrites = false, accum) {
    const current = accum || { targets: /* @__PURE__ */ new WeakMap(), path: [] };
    if (state === void 0) return void 0;
    return new Proxy(state, {
      // State accessors are read-only by default:
      set(target, prop, newValue) {
        if (allowWrites) {
          return Reflect.set(target, prop, newValue);
        }
        if (typeof prop === "string") {
          console.error(
            `State is read-only for web components. Unable to set '${prop}'.`
          );
        }
        return false;
      },
      // Recursively build a proxy for each state prop being read:
      get(target, prop, receiver) {
        const value = Reflect.get(target, prop, receiver);
        const isProto = prop === "__proto__";
        if (typeof prop === "string" && !isProto) {
          if (!current.targets.has(target)) {
            current.targets.set(target, current.path.join("."));
          }
          const targetPath = current.targets.get(target);
          current.path.length = 0;
          if (typeof targetPath === "string" && targetPath !== "") {
            current.path.push(...targetPath.split("."));
          }
          current.path.push(prop);
        }
        if (isProto || Array.isArray(value) || isPOJO(value)) {
          if (!current.targets.has(value) && typeof prop === "string") {
            current.targets.set(value, current.path.join("."));
          }
          return createStateAccessor(value, log, allowWrites, current);
        }
        let path = current.targets.get(target) ?? "";
        if (typeof path === "string" && typeof prop === "string") {
          if (Array.isArray(target)) {
            path;
          } else {
            path += path !== "" ? `.${prop}` : prop;
          }
          if (log.indexOf(path) === -1) {
            log.push(path);
          }
        }
        current.path.length = 0;
        current.path.push(path);
        return value;
      }
    });
  }
  function createSubscribersDispatcher(state) {
    return () => {
      const updates = state.internal.updates;
      const notified = /* @__PURE__ */ new Set();
      const notify = (fns) => {
        if (!fns) return;
        for (let j = 0; j < fns.length; j++) {
          const fn = fns[j];
          if (notified.has(fn)) continue;
          notified.add(fn);
          try {
            fn(state.app);
          } catch (error) {
          }
        }
      };
      for (let i = 0; i < updates.path.length; i++) {
        const path = updates.path[i];
        const relativePath = path.slice(path.indexOf(".") + 1);
        notify(updates.subscribers.get(relativePath));
        for (const [subscriberPath, fns] of updates.subscribers.entries()) {
          if (subscriberPath === relativePath) continue;
          const subscriberWithDot = `${subscriberPath}.`;
          const relativeWithDot = `${relativePath}.`;
          if (relativePath.startsWith(subscriberWithDot) || subscriberPath.startsWith(relativeWithDot)) {
            notify(fns);
          }
        }
      }
      updates.path = [];
      updates.value = [];
      updates.raf = void 0;
    };
  }
  function proxify2(boredom) {
    const runtime = boredom.internal;
    const state = boredom;
    if (state === void 0) return boredom;
    const objectsWithProxies = /* @__PURE__ */ new WeakSet();
    const PROXY_MARKER = Symbol("boredom-proxy");
    function createReactiveProxy(value, dottedPath) {
      if (objectsWithProxies.has(value)) return value;
      const proxy = new Proxy(value, {
        get(target, prop, receiver) {
          if (prop === PROXY_MARKER) return true;
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, newValue) {
          const isChanged = target[prop] !== newValue;
          if (!isChanged) return true;
          if (typeof prop === "string") {
            const newPath = Array.isArray(value) ? dottedPath : `${dottedPath}.${prop}`;
            const isAlreadyProxy = newValue && newValue[PROXY_MARKER] === true;
            if (!isAlreadyProxy && (Array.isArray(newValue) || isPOJO(newValue))) {
              newValue = proxifyValue(newValue, newPath);
            }
          }
          Reflect.set(target, prop, newValue);
          if (typeof prop !== "string") return true;
          if (Array.isArray(value)) {
            runtime.updates.path.push(`${dottedPath}`);
          } else {
            runtime.updates.path.push(`${dottedPath}.${prop}`);
          }
          runtime.updates.value.push(target);
          if (!runtime.updates.raf) {
            runtime.updates.raf = requestAnimationFrame(
              createSubscribersDispatcher(boredom)
            );
          }
          return true;
        }
      });
      objectsWithProxies.add(value);
      objectsWithProxies.add(proxy);
      return proxy;
    }
    function proxifyValue(value, basePath) {
      if (!Array.isArray(value) && !isPOJO(value)) return value;
      if (objectsWithProxies.has(value)) return value;
      if (value && value[PROXY_MARKER] === true) return value;
      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          if (Array.isArray(item) || isPOJO(item)) {
            value[i] = proxifyValue(item, basePath);
          }
        }
      } else {
        for (const key of Object.keys(value)) {
          const item = value[key];
          if (Array.isArray(item) || isPOJO(item)) {
            value[key] = proxifyValue(item, `${basePath}.${key}`);
          }
        }
      }
      return createReactiveProxy(value, basePath);
    }
    flatten(boredom, ["internal"]).forEach(({ path, value }) => {
      const needsProxy = Array.isArray(value) || isPOJO(value) && !objectsWithProxies.has(value);
      if (needsProxy) {
        const dottedPath = path.join(".");
        const parent = access(path.slice(0, -1), state);
        const isRoot = parent === value;
        if (isRoot) return;
        parent[path.at(-1)] = createReactiveProxy(value, dottedPath);
      }
    });
    return boredom;
  }
  function runComponentsInitializer(state) {
    const tagsInDom = state.internal.customTags.filter(
      (tag) => (
        // A tag is considered present if at least one instance exists in the DOM
        document.querySelector(tag) !== null
      )
    );
    const components = state.internal.components;
    for (const [tagName, code] of components.entries()) {
      if (code === null || !tagsInDom.includes(tagName)) continue;
      const elements = Array.from(
        document.querySelectorAll(tagName)
      ).filter((el) => isBored(el));
      if (elements.length === 0) {
        continue;
      }
      elements.forEach((componentClass, index) => {
        if (componentClass.isBoredInitialized) return;
        const detail = {
          index,
          name: tagName,
          data: extractDetailData(componentClass)
        };
        code(state, detail)(componentClass);
        componentClass.__boreDOMDetail = detail;
        componentClass.isBoredInitialized = true;
      });
    }
    return;
  }
  function createAndRunCode(name, state, detail) {
    const code = state.internal.components.get(name);
    if (code) {
      const info = { ...detail, tagName: name };
      if (!info.data) info.data = {};
      const element = createComponent(name, code(state, info));
      element.__boreDOMDetail = info;
      return element;
    }
    return createComponent(name);
  }

  // src/index.ts
  init_debug();
  init_console_api();

  // src/inside-out.ts
  init_debug();
  init_console_api();
  var userDefinedHelpers = /* @__PURE__ */ new Map();
  var missingFunctions = /* @__PURE__ */ new Map();
  var lastMissing = null;
  var inferredTemplates = /* @__PURE__ */ new Map();
  var templateObserver = null;
  function createRenderHelpers(componentName, element, rerender) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) {
      return {};
    }
    if (!isDebugEnabled("methodMissing")) {
      return {};
    }
    return new Proxy({}, {
      get(_target, prop) {
        if (typeof prop === "symbol" || prop === "then" || prop === "toJSON") {
          return void 0;
        }
        if (userDefinedHelpers.has(prop)) {
          const helper = userDefinedHelpers.get(prop);
          return (...args) => {
            const result = helper(...args);
            return result;
          };
        }
        return (...args) => {
          const ctx = {
            name: prop,
            args,
            component: componentName,
            element,
            timestamp: Date.now(),
            define: (impl) => {
              defineHelper(prop, impl);
              rerender();
            }
          };
          logMissingFunction(ctx);
          storeMissingFunction(ctx);
          exposeMissingGlobals(ctx);
          return void 0;
        };
      },
      has(_target, prop) {
        return typeof prop === "string" && userDefinedHelpers.has(prop);
      }
    });
  }
  function defineHelper(name, implementation) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) return;
    if (!isDebugEnabled("methodMissing")) return;
    userDefinedHelpers.set(name, implementation);
    if (isDebugEnabled("console")) {
      console.log(
        "%c\u2705 boreDOM: Defined helper %c%s",
        "color: #27ae60; font-weight: bold",
        "color: #9b59b6; font-weight: bold",
        name
      );
    }
  }
  function clearHelper(name) {
    userDefinedHelpers.delete(name);
  }
  function clearMissingFunctions() {
    missingFunctions.clear();
    lastMissing = null;
  }
  function logMissingFunction(ctx) {
    if (!isDebugEnabled("console")) return;
    console.log(
      "%c\u26A0\uFE0F boreDOM: Missing function %c%s%c in <%s>",
      "color: #f39c12; font-weight: bold",
      "color: #9b59b6; font-weight: bold",
      ctx.name,
      "color: #f39c12",
      ctx.component
    );
    if (ctx.args.length > 0) {
      console.log("   Arguments:", ctx.args);
    }
    console.log("%c\u{1F4A1} Define it:", "color: #3498db; font-weight: bold");
    console.log(`   $defineMissing((${generateArgNames(ctx.args)}) => { ... })`);
    console.log(
      `   boreDOM.defineHelper('${ctx.name}', (${generateArgNames(ctx.args)}) => { ... })`
    );
  }
  function generateArgNames(args) {
    if (args.length === 0) return "";
    return args.map((arg, i) => {
      if (arg === null || arg === void 0) return `arg${i}`;
      if (Array.isArray(arg)) return "items";
      if (typeof arg === "object") {
        if ("name" in arg && "email" in arg) return "user";
        if ("id" in arg && "title" in arg) return "item";
        if ("id" in arg) return "record";
        return "data";
      }
      if (typeof arg === "string") return "text";
      if (typeof arg === "number") return "count";
      if (typeof arg === "boolean") return "flag";
      return `arg${i}`;
    }).join(", ");
  }
  function storeMissingFunction(ctx) {
    if (!isDebugEnabled("errorHistory")) return;
    const existing = missingFunctions.get(ctx.name) || [];
    if (existing.length >= 10) {
      existing.shift();
    }
    existing.push(ctx);
    missingFunctions.set(ctx.name, existing);
    lastMissing = ctx;
  }
  function exposeMissingGlobals(ctx) {
    if (!isDebugEnabled("globals")) return;
    if (typeof window === "undefined") return;
    const w = window;
    w.$missingName = ctx.name;
    w.$missingArgs = ctx.args;
    w.$missingComponent = ctx.component;
    w.$defineMissing = ctx.define;
  }
  function clearMissingGlobals() {
    if (typeof window === "undefined") return;
    const w = window;
    delete w.$missingName;
    delete w.$missingArgs;
    delete w.$missingComponent;
    delete w.$defineMissing;
  }
  function inferTemplate(tagName, element) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) return null;
    if (!isDebugEnabled("templateInference")) return null;
    if (isDebugEnabled("strict")) return null;
    const props = {};
    const slots = [];
    if (element) {
      for (const attr of Array.from(element.attributes)) {
        if (attr.name.startsWith("data-")) continue;
        if (["class", "id", "style"].includes(attr.name)) continue;
        const camelName = kebabToCamel(attr.name);
        props[camelName] = parseAttributeValue(attr.value);
      }
      for (const child of Array.from(element.children)) {
        const slotName = child.getAttribute("slot");
        if (slotName && !slots.includes(slotName)) {
          slots.push(slotName);
        }
      }
    }
    const propsSlots = Object.keys(props).map((p) => `    <slot name="${camelToKebab(p)}">${formatValue(props[p])}</slot>`).join("\n");
    const defaultSlot = slots.length === 0 && Object.keys(props).length === 0 ? '    <slot name="content">Loading...</slot>' : "";
    const template = `<div class="${tagName}-skeleton" data-inferred>
${propsSlots || defaultSlot}
  </div>`;
    return { tagName, template, props, slots };
  }
  function registerInferredComponent(tagName, element) {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) return false;
    if (!isDebugEnabled("templateInference")) return false;
    if (customElements.get(tagName)) return false;
    if (!getCurrentAppState()) return false;
    const inference = inferTemplate(tagName, element);
    if (!inference) return false;
    const { template, props } = inference;
    inferredTemplates.set(tagName, inference);
    logInferredComponent(tagName, props);
    try {
      define2(
        tagName,
        template,
        // Stub render that logs what it receives
        ({ state }) => ({ slots }) => {
          if (isDebugEnabled("console")) {
            console.log(
              "%c\u{1F52E} boreDOM: Inferred <%s> rendering",
              "color: #9b59b6; font-weight: bold",
              tagName
            );
            console.log("   Inferred props:", props);
            console.log("   App state:", state);
          }
          for (const [key, value] of Object.entries(props)) {
            const slotKey = camelToKebab(key);
            if (slots[slotKey]) {
              slots[slotKey] = String(value);
            }
          }
        }
      );
      return true;
    } catch (e) {
      if (isDebugEnabled("console")) {
        console.warn(`[boreDOM] Failed to register inferred <${tagName}>:`, e);
      }
      return false;
    }
  }
  function logInferredComponent(tagName, props) {
    if (!isDebugEnabled("console")) return;
    console.log(
      "%c\u{1F52E} boreDOM: Inferring template for %c<%s>",
      "color: #9b59b6; font-weight: bold",
      "color: #4ecdc4; font-weight: bold",
      tagName
    );
    if (Object.keys(props).length > 0) {
      console.log("%c\u{1F4CB} Inferred props from attributes:", "color: #95a5a6");
      for (const [key, value] of Object.entries(props)) {
        console.log(`   ${key}: ${JSON.stringify(value)}`);
      }
    }
    console.log("%c\u{1F4A1} Define properly with:", "color: #3498db; font-weight: bold");
    console.log(
      `   boreDOM.define('${tagName}', '<your template>', ({ state }) => ({ slots }) => { ... })`
    );
  }
  function observeUndefinedElements() {
    if (typeof __DEBUG__ !== "undefined" && !__DEBUG__) return;
    if (!isDebugEnabled("templateInference")) return;
    if (typeof window === "undefined") return;
    if (templateObserver) return;
    templateObserver = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        for (const node of Array.from(mutation.addedNodes)) {
          if (node instanceof HTMLElement && node.tagName.includes("-")) {
            const tagName = node.tagName.toLowerCase();
            if (!customElements.get(tagName)) {
              const template = document.querySelector(
                `template[data-component="${tagName}"]`
              );
              if (!template) {
                queueMicrotask(() => {
                  if (!customElements.get(tagName)) {
                    registerInferredComponent(tagName, node);
                  }
                });
              }
            }
          }
        }
      }
    });
    templateObserver.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  function stopObservingUndefinedElements() {
    if (templateObserver) {
      templateObserver.disconnect();
      templateObserver = null;
    }
  }
  function kebabToCamel(str) {
    return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
  }
  function camelToKebab(str) {
    return str.replace(/([A-Z])/g, "-$1").toLowerCase();
  }
  function parseAttributeValue(value) {
    if (value === "true") return true;
    if (value === "false") return false;
    const num = Number(value);
    if (!isNaN(num) && value !== "") return num;
    if (value.startsWith("{") || value.startsWith("[")) {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
  function formatValue(value) {
    if (value === null || value === void 0) return "";
    if (typeof value === "object") return JSON.stringify(value);
    return String(value);
  }
  var insideOutAPI = {
    /** Map of missing function calls by function name */
    get missingFunctions() {
      return missingFunctions;
    },
    /** Most recent missing function context */
    get lastMissing() {
      return lastMissing;
    },
    /** Define a helper function available to all render functions */
    defineHelper,
    /** Get all defined helpers */
    get helpers() {
      return new Map(userDefinedHelpers);
    },
    /** Clear a helper definition */
    clearHelper,
    /** Clear all missing function records */
    clearMissingFunctions,
    /** Map of inferred templates by tag name */
    get inferredTemplates() {
      return inferredTemplates;
    },
    /** Manually infer template for a tag (useful for testing) */
    inferTemplate
  };

  // src/index.ts
  init_llm();

  // src/bindings.ts
  var toCamelCase = (value) => value.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
  var parsePath3 = (raw) => {
    const normalized = raw.replace(/\[(\d+)\]/g, ".$1").replace(/^\./, "");
    return normalized.split(".").filter(Boolean);
  };
  var resolvePath = (target, raw) => {
    if (target === void 0 || target === null) return void 0;
    const path = parsePath3(raw);
    if (path.length === 0) return target;
    return access(path, target);
  };
  var resolveValue = (expr, scope) => {
    const raw = expr.trim();
    if (!raw) return void 0;
    if (raw === "index" || raw === "i") return scope.index;
    if (raw === "item") return scope.item;
    if (raw === "detail") return scope.detail;
    if (raw === "self") return scope.self;
    if (raw.startsWith("state.")) return resolvePath(scope.state, raw.slice(6));
    if (raw.startsWith("item.")) return resolvePath(scope.item, raw.slice(5));
    if (raw.startsWith("detail.")) return resolvePath(scope.detail, raw.slice(7));
    if (raw.startsWith("self.")) return resolvePath(scope.self, raw.slice(5));
    return resolvePath(scope.state, raw);
  };
  var collectElements = (root) => {
    const elements = [];
    if (root instanceof DocumentFragment) {
      const walker = document.createTreeWalker(
        root,
        NodeFilter.SHOW_ELEMENT
      );
      while (walker.nextNode()) {
        elements.push(walker.currentNode);
      }
      return elements;
    }
    elements.push(root);
    root.traverse((elem) => {
      elements.push(elem);
    }, { traverseShadowRoot: true });
    return elements;
  };
  var getClassBase = (element) => {
    const stored = element.getAttribute("data-class-base");
    if (stored !== null) return stored;
    const base = element.className;
    element.setAttribute("data-class-base", base);
    return base;
  };
  var applyClassBinding = (element, expr, scope) => {
    const base = getClassBase(element);
    if (expr.includes(":")) {
      const toggled = [];
      expr.split(",").forEach((part) => {
        const [name, valueExpr] = part.split(":").map((s) => s.trim());
        if (!name || !valueExpr) return;
        if (resolveValue(valueExpr, scope)) {
          toggled.push(name);
        }
      });
      const combined = [base, ...toggled].filter(Boolean).join(" ").trim();
      element.className = combined;
      return;
    }
    const resolved = resolveValue(expr, scope);
    if (typeof resolved === "string") {
      element.className = [base, resolved].filter(Boolean).join(" ").trim();
    } else if (Array.isArray(resolved)) {
      element.className = [base, resolved.join(" ")].filter(Boolean).join(" ").trim();
    } else if (resolved && typeof resolved === "object") {
      const toggled = Object.entries(resolved).filter(([, value]) => Boolean(value)).map(([name]) => name);
      element.className = [base, ...toggled].filter(Boolean).join(" ").trim();
    } else {
      element.className = base.trim();
    }
  };
  var applyAttributeBindings = (elements, scope) => {
    const skipListItems = scope.item === void 0;
    elements.forEach((element) => {
      if (element instanceof HTMLTemplateElement) return;
      if (skipListItems && element.closest("[data-list-item]")) return;
      const textBinding = element.getAttribute("data-text");
      if (textBinding) {
        const value = resolveValue(textBinding, scope);
        element.textContent = value === void 0 || value === null ? "" : String(value);
      }
      const showBinding = element.getAttribute("data-show");
      if (showBinding) {
        element.hidden = !Boolean(resolveValue(showBinding, scope));
      }
      const classBinding = element.getAttribute("data-class");
      if (classBinding) {
        applyClassBinding(element, classBinding, scope);
      }
      const valueBinding = element.getAttribute("data-value");
      if (valueBinding && "value" in element) {
        const value = resolveValue(valueBinding, scope);
        element.value = value === void 0 || value === null ? "" : String(value);
      }
      const checkedBinding = element.getAttribute("data-checked");
      if (checkedBinding && "checked" in element) {
        const value = resolveValue(checkedBinding, scope);
        element.checked = Boolean(value);
      }
      const propAttributes = Array.from(element.attributes).filter((attr) => attr.name.startsWith("data-prop-"));
      if (propAttributes.length > 0) {
        let detailChanged = false;
        propAttributes.forEach((attr) => {
          const propName = attr.name.slice("data-prop-".length);
          if (!propName) return;
          const resolved = resolveValue(attr.value, scope);
          const dataAttribute = `data-${propName}`;
          const current = element.getAttribute(dataAttribute);
          const isAttributeValue = resolved === void 0 || resolved === null || typeof resolved === "string" || typeof resolved === "number" || typeof resolved === "boolean";
          const next = isAttributeValue && resolved !== void 0 && resolved !== null ? String(resolved) : null;
          if (next === null) {
            if (current !== null) {
              element.removeAttribute(dataAttribute);
              detailChanged = true;
            }
          } else if (current !== next) {
            element.setAttribute(dataAttribute, next);
            detailChanged = true;
          }
          const detailKey = toCamelCase(propName);
          const detail = element.__boreDOMDetail;
          if (detail) {
            if (!detail.data) detail.data = {};
            if (detail.data[detailKey] !== resolved) {
              detail.data[detailKey] = resolved;
              detailChanged = true;
            }
          }
        });
        if (detailChanged) {
          const rerender = element.__boreDOMRerender;
          if (typeof rerender === "function") {
            rerender();
          }
        }
      }
    });
  };
  var applyListBinding = (element, scope) => {
    const listExpr = element.getAttribute("data-list");
    if (!listExpr) return;
    const template = element.querySelector("template[data-item]");
    if (!(template instanceof HTMLTemplateElement)) return;
    const resolved = resolveValue(listExpr, scope);
    const items = Array.isArray(resolved) ? resolved : [];
    Array.from(element.children).forEach((child) => {
      if (child.hasAttribute("data-list-item")) {
        child.remove();
      }
    });
    const fragment = document.createDocumentFragment();
    items.forEach((item, index) => {
      const clone = template.content.cloneNode(true);
      Array.from(clone.childNodes).forEach((node) => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          node.setAttribute("data-list-item", "");
        }
      });
      applyBindingsToFragment(clone, { ...scope, item, index });
      fragment.appendChild(clone);
    });
    element.appendChild(fragment);
  };
  var applyBindingsToFragment = (fragment, scope) => {
    let elements = collectElements(fragment);
    elements.forEach((element) => applyListBinding(element, scope));
    elements = collectElements(fragment);
    applyAttributeBindings(elements, scope);
  };
  var applyBindings = (root, scope) => {
    let elements = collectElements(root);
    elements.forEach((element) => applyListBinding(element, scope));
    elements = collectElements(root);
    applyAttributeBindings(elements, scope);
  };

  // src/index.ts
  init_debug();
  init_version();
  init_version();
  var hasLoggedVersion = false;
  var debugApiEnabled = typeof __DEBUG__ === "undefined" || __DEBUG__;
  var html = (strings, ...values) => {
    let result = "";
    for (let i = 0; i < strings.length; i++) {
      result += strings[i];
      if (i < values.length) result += String(values[i]);
    }
    return result;
  };
  function component2(tagName, template, initFunction) {
    if (typeof document !== "undefined") {
      const existing = document.querySelector(
        `template[data-component="${tagName}"]`
      );
      if (existing) {
        existing.innerHTML = template;
      } else {
        const templateEl = document.createElement("template");
        templateEl.setAttribute("data-component", tagName);
        templateEl.innerHTML = template;
        document.body.appendChild(templateEl);
      }
    }
    return webComponent(initFunction);
  }
  var boreDOM = {
    /** Map of all current errors by component name */
    get errors() {
      return debugAPI.errors;
    },
    /** Most recent error context */
    get lastError() {
      return debugAPI.lastError;
    },
    /** Re-render a specific component or the last errored one */
    rerender: debugAPI.rerender,
    /** Clear error state for a component */
    clearError: debugAPI.clearError,
    /** Export state snapshot */
    export: debugAPI.export,
    /** Current debug configuration (read-only) */
    get config() {
      return debugAPI.config;
    },
    /** @internal Set debug configuration (used by tests with multiple bundles) */
    _setDebugConfig: setDebugConfig,
    /** Framework version */
    version: VERSION,
    // LLM Integration API (Phase 4)
    /** LLM context and output utilities */
    llm: llmAPI,
    /** Create a template-backed component in single-file mode */
    component: component2,
    /** Template literal helper for HTML strings */
    html
  };
  if (debugApiEnabled) {
    Object.assign(boreDOM, {
      /** Define a new component at runtime */
      define: consoleAPI.define,
      /** Get live access to a component's internals */
      operate: consoleAPI.operate,
      /** Export component state and template */
      exportComponent: consoleAPI.exportComponent,
      /** Define a helper function available to all render functions */
      defineHelper: insideOutAPI.defineHelper,
      /** Clear a helper definition */
      clearHelper: insideOutAPI.clearHelper,
      /** Clear all missing function records */
      clearMissingFunctions: insideOutAPI.clearMissingFunctions,
      /** Manually infer template for a tag */
      inferTemplate: insideOutAPI.inferTemplate
    });
    Object.defineProperties(boreDOM, {
      /** Map of missing function calls by function name */
      missingFunctions: {
        get: () => insideOutAPI.missingFunctions
      },
      /** Most recent missing function context */
      lastMissing: {
        get: () => insideOutAPI.lastMissing
      },
      /** Get all defined helpers */
      helpers: {
        get: () => insideOutAPI.helpers
      },
      /** Map of inferred templates by tag name */
      inferredTemplates: {
        get: () => insideOutAPI.inferredTemplates
      }
    });
  }
  if (typeof window !== "undefined") {
    window.boreDOM = boreDOM;
    window.dispatch = dispatch;
  }
  async function inflictBoreDOM(state, componentsLogic, config3) {
    if (config3?.debug !== void 0) {
      setDebugConfig(config3.debug);
    }
    if (!hasLoggedVersion && isDebugEnabled("versionLog")) {
      hasLoggedVersion = true;
      if (typeof console !== "undefined" && typeof console.info === "function") {
      }
    }
    const wrapper = (fn) => {
      if (fn && fn[WEB_COMPONENT_MARKER]) {
        return fn;
      }
      if (typeof fn === "function") {
        return webComponent(fn);
      }
      return fn;
    };
    const isSingleFileBuild = typeof __SINGLE_FILE__ !== "undefined" && __SINGLE_FILE__;
    const singleFile = config3?.singleFile ?? isSingleFileBuild;
    const { names: registeredNames, inlineLogic } = await registerTemplates(
      wrapper,
      {
        mirrorAttributes: config3?.mirrorAttributes
      }
    );
    const componentsCode = singleFile ? /* @__PURE__ */ new Map() : await dynamicImportScripts(registeredNames);
    if (inlineLogic) {
      for (const [tagName, logic] of inlineLogic) {
        if (!componentsCode.has(tagName) || componentsCode.get(tagName) === null) {
          componentsCode.set(tagName, logic);
        }
      }
    }
    if (componentsLogic) {
      for (const tagName of Object.keys(componentsLogic)) {
        componentsCode.set(tagName, componentsLogic[tagName]);
      }
    }
    for (const name of registeredNames) {
      if (!componentsCode.has(name) || componentsCode.get(name) === null) {
        componentsCode.set(name, webComponent(() => () => {
        }));
      }
    }
    const initialState = {
      app: state,
      internal: {
        customTags: registeredNames,
        components: componentsCode,
        updates: {
          path: [],
          value: [],
          raf: void 0,
          subscribers: /* @__PURE__ */ new Map()
        }
      }
    };
    const proxifiedState = proxify2(initialState);
    proxifiedState.internal.updates.path = [];
    proxifiedState.internal.updates.value = [];
    if (proxifiedState.internal.updates.raf) {
      cancelAnimationFrame(proxifiedState.internal.updates.raf);
      proxifiedState.internal.updates.raf = void 0;
    }
    setCurrentAppState(proxifiedState, webComponent, registerComponent);
    runComponentsInitializer(proxifiedState);
    observeUndefinedElements();
    return proxifiedState.app;
  }
  function webComponent(initFunction) {
    const result = (appState, detail) => (c) => {
      const { internal, app } = appState;
      let log = [];
      const state = createStateAccessor(app, log, true);
      const refs = createRefsAccessor(c);
      const slots = createSlotsAccessor(c);
      const on = createEventsHandler(c, app, detail);
      let renderFunction;
      c.state = state;
      c.refs = refs;
      c.slots = slots;
      const updateSubscribers = async () => {
        const subscribers = internal.updates.subscribers;
        for (let path of log) {
          const functions = subscribers.get(path);
          if (functions) {
            if (!functions.includes(renderFunction)) {
              functions.push(renderFunction);
            }
          } else {
            subscribers.set(path, [renderFunction]);
          }
        }
      };
      let userDefinedRenderer;
      try {
        userDefinedRenderer = initFunction({
          detail,
          state,
          refs,
          on,
          self: c,
          makeComponent: (tag, opts) => {
            return createAndRunCode(tag, appState, opts?.detail);
          }
        });
      } catch (error) {
        const err = error;
        if (isDebugEnabled("console")) {
          logInitError(detail?.name ?? c.tagName.toLowerCase(), err);
        }
        userDefinedRenderer = () => {
        };
      }
      renderFunction = (renderState) => {
        const componentName = detail?.name ?? c.tagName.toLowerCase();
        const helpers = createRenderHelpers(
          componentName,
          c,
          () => renderFunction(renderState)
        );
        const renderAccessor = createStateAccessor(renderState, log, false);
        if (isDebugEnabled("errorBoundary")) {
          try {
            userDefinedRenderer({
              state: renderAccessor,
              refs,
              slots,
              self: c,
              detail,
              makeComponent: (tag, opts) => {
                return createAndRunCode(tag, appState, opts?.detail);
              },
              helpers
            });
            applyBindings(c, { state: renderAccessor, detail, self: c });
            updateSubscribers();
            clearComponentErrorMark(c);
            clearError(componentName);
          } catch (error) {
            const err = error;
            const ctx = {
              component: componentName,
              element: c,
              error: err,
              state: app,
              // Write proxy - MUTABLE
              refs,
              slots,
              timestamp: Date.now(),
              rerender: () => renderFunction(renderState),
              stack: err.stack ?? ""
            };
            if (isDebugEnabled("console")) {
              logError(ctx);
            } else {
              logErrorMinimal(componentName, err);
            }
            exposeGlobals(ctx);
            storeError(ctx);
            markComponentError(c);
          }
        } else {
          userDefinedRenderer({
            state: renderAccessor,
            refs,
            slots,
            self: c,
            detail,
            makeComponent: (tag, opts) => {
              return createAndRunCode(tag, appState, opts?.detail);
            },
            helpers
          });
          applyBindings(c, { state: renderAccessor, detail, self: c });
          updateSubscribers();
        }
      };
      storeComponentContext(c, {
        state: app,
        refs,
        slots,
        self: c,
        detail,
        rerender: () => renderFunction(app)
      });
      c.__boreDOMDetail = detail;
      c.__boreDOMRerender = () => renderFunction(app);
      renderFunction(state);
    };
    result[WEB_COMPONENT_MARKER] = true;
    return result;
  }

  // tests/dom.test.ts
  init_flatten();
  function renderHTML(html2) {
    const main = document.querySelector("main");
    if (!main) throw new Error("No <main> found!");
    main.innerHTML = html2;
    return main;
  }
  async function frame() {
    return new Promise((resolve) => {
      requestAnimationFrame((t) => resolve(t));
    });
  }
  async function renderHTMLFrame(html2) {
    const main = document.querySelector("main");
    if (!main) throw new Error("No <main> found!");
    main.innerHTML = html2;
    return new Promise((resolve) => {
      requestAnimationFrame(() => {
        resolve(main);
      });
    });
  }
  function dom_test_default() {
    describe("DOM", () => {
      beforeEach(function() {
        const main = document.querySelector("main");
        if (!main) return;
        main.innerHTML = "";
        setDebugConfig(true);
      });
      describe("Simple component", () => {
        it("should register the <template> data-component tag", async () => {
          const container = renderHTML(
            `<template data-component="simple-component"></template>`
          );
          inflictBoreDOM();
          const ctor = customElements.get("simple-component");
          expect(ctor).not.to.be.undefined;
          if (!ctor) throw new Error("Undefined tag");
          expect(new ctor()).to.be.an.instanceof(HTMLElement);
        });
        it("should not register the <template> data-component tag if it is invalid", async () => {
          const container = renderHTML(
            `<template data-component="nonvalid"></template>`
          );
          inflictBoreDOM();
          const ctor = customElements.get("nonvalid");
          expect(ctor).to.be.undefined;
        });
        it("should render the html of the custom element", async () => {
          const container = renderHTML(`
          <simple-component2></simple-component2>
          <template data-component="simple-component2"><p>This is some random HTML</p></template>
        `);
          inflictBoreDOM();
          const elem = getByText(container, "This is some random HTML");
          expect(elem).to.be.an.instanceof(HTMLParagraphElement);
        });
        it("should render in shadow root the html of the corresponding <template> tag when it has shadowmode set", async () => {
          const container = renderHTML(`
          <simple-component3></simple-component3>
          <template data-component="simple-component3" shadowrootmode="open"><p>Test</p></template>
        `);
          inflictBoreDOM();
          const elem = getByText(
            container.firstElementChild.shadowRoot,
            "Test"
          );
          expect(elem).to.be.an.instanceof(HTMLParagraphElement);
        });
        it("should apply the aria attributes from the <template> to the tag of the custom element", async () => {
          const container = renderHTML(`
          <simple-component4></simple-component4>
          <template data-component="simple-component4" data-aria-label="Some Label"><p>Something</p></template>
        `);
          inflictBoreDOM();
          const elem = getByLabelTextWithSuggestions(container, "Some Label");
          expect(elem).to.be.an.instanceof(HTMLElement);
          expect(elem.tagName).to.equal("SIMPLE-COMPONENT4");
          expect(elem.firstChild).to.be.an.instanceof(HTMLParagraphElement);
        });
        it("should apply the role attribute from the <template> to the tag of the custom element", async () => {
          const container = renderHTML(`
          <simple-component5></simple-component5>
          <template data-component="simple-component5" data-role="banner"><p>Something</p></template>
        `);
          inflictBoreDOM();
          const elem = getByRole(container, "banner");
          expect(elem).to.be.an.instanceof(HTMLElement);
          expect(elem.tagName).to.equal("SIMPLE-COMPONENT5");
          expect(elem.firstChild).to.be.an.instanceof(HTMLParagraphElement);
        });
        it("should allow the slots default behaviour", async () => {
          const container = await renderHTMLFrame(`
          <slotted-component1>
            <span slot="my-text">Let's have some different text!</span>
          </slotted-component1>

          <template data-component="slotted-component1" shadowrootmode="open">
            <p><slot name="my-text">My default text</slot></p>
          </template>
        `);
          await inflictBoreDOM();
          const elem = getByText(
            container,
            "Let's have some different text!"
          );
          expect(elem).to.be.an.instanceof(HTMLElement);
          const shouldNotExist = queryByText(
            container,
            "My default text"
          );
          expect(shouldNotExist).to.be.null;
        });
      });
      describe("Simple component events", () => {
        it("should set a data-event-dispatches on the web component once the custom event is registered", () => {
          const container = renderHTML(`
          <eventful-component1></eventful-component1>
          <template data-component="eventful-component1"><button onclick="dispatch('clickme')">Click me</button></template>
        `);
          inflictBoreDOM();
          const elem = container.querySelector(
            "[data-onclick-dispatches]"
          );
          expect(elem).to.be.an.instanceof(HTMLElement);
          expect(elem.dataset.onclickDispatches).to.eql("clickme");
        });
        it("should dispatch a custom event with the provided name in the dispatch function", async (done) => {
          const container = renderHTML(`
          <eventful-component2></eventful-component2>
          <template data-component="eventful-component2"><button onclick="dispatch('clickme')">Click me</button></template>
        `);
          inflictBoreDOM();
          addEventListener("clickme", (e) => {
            expect(e.detail.event).not.to.be.undefined;
            expect(e.detail.event.target).to.be.an.instanceof(HTMLElement);
            if (!(e.detail.event.target instanceof HTMLElement)) {
              throw new Error("Event target not an html element");
            }
            expect(e.detail.event.target.tagName.toLowerCase()).to.equal(
              "button"
            );
            done();
          });
          const elem = getByText(
            container,
            "Click me"
          );
          fireEvent.click(elem);
        });
        it("should dispatch more than one custom event when more than one string is in the dispatch function", async (done) => {
          const container = renderHTML(`
          <eventful-component3></eventful-component3>
          <template data-component="eventful-component3"><button onclick="dispatch('clickyou', 'clickthem')">Click me</button></template>
        `);
          inflictBoreDOM();
          let triggeredEvents = [];
          addEventListener("clickthem", (e) => {
            expect(e.detail.event).not.to.be.undefined;
            expect(e.detail.event.target).to.be.an.instanceof(HTMLElement);
            if (!(e.detail.event.target instanceof HTMLElement)) {
              throw new Error("Event target not an html element");
            }
            expect(e.detail.event.target.tagName.toLowerCase()).to.equal(
              "button"
            );
            triggeredEvents.push("clickthem");
            if (triggeredEvents.includes("clickyou")) {
              done();
            }
          });
          addEventListener("clickyou", (e) => {
            expect(e.detail.event).not.to.be.undefined;
            expect(e.detail.event.target).to.be.an.instanceof(HTMLElement);
            if (!(e.detail.event.target instanceof HTMLElement)) {
              throw new Error("Event target not an html element");
            }
            expect(e.detail.event.target.tagName.toLowerCase()).to.equal(
              "button"
            );
            triggeredEvents.push("clickyou");
            if (triggeredEvents.includes("clickthem")) {
              done();
            }
          });
          const elem = getByText(
            container,
            "Click me"
          );
          fireEvent.click(elem);
        });
      });
      describe("Component with <script> code", () => {
        it("should load the associated JS and run the render function", async () => {
          const container = renderHTML(`
          <stateful-component1></stateful-component1>

          <template data-component="stateful-component1">
            <p>Stateful component 1</p>
          </template>

          <script src="/stateful-component1.js"><\/script>
        `);
          await inflictBoreDOM();
          const elem = getByText(
            container,
            "Render"
          );
          expect(elem).to.be.an.instanceof(HTMLParagraphElement);
        });
        it("should pass refs through an object in init", async () => {
          const container = await renderHTMLFrame(`
          <stateful-component2></stateful-component2>

          <template data-component="stateful-component2">
            <p>Some ref:
              <span data-ref="something"> </span> </p>
            <!-- ^ should be available as options.refs.something in the init function -->
          </template>

          <script src="/stateful-component2.js"><\/script>
        `);
          await inflictBoreDOM();
          const elem = getByText(
            container,
            "Something ref innerText updated"
          );
          expect(elem).to.be.an.instanceof(HTMLSpanElement);
        });
        it("should throw an error when an undefined ref is being accessed", async () => {
          const container = await renderHTMLFrame(`
          <stateful-component3></stateful-component3>

          <template data-component="stateful-component3"></template>

          <script src="/stateful-component3.js"><\/script>
        `);
          try {
            await inflictBoreDOM();
          } catch (e) {
            expect(e.message).to.be.a.string(
              'Ref "somethingThatDoesNotExist" not found in <STATEFUL-COMPONENT3>'
            );
          }
        });
        it("should be able to get slots through the `slots` object property in the render function", async () => {
          const container = await renderHTMLFrame(`
          <stateful-component4></stateful-component4>

          <template data-component="stateful-component4">
            <p>Something can be placed below:</p>
            <slot name="some-slot"></slot>
            <!-- ^ should be available as options.slots["some-slot"] in the render function -->
          </template>

          <script src="/stateful-component4.js"><\/script>

          <template data-component="stateful-component4b">
            <p>This component will be placed in the slot by the .js code</p>
          </template>
        `);
          await inflictBoreDOM();
          const elem = getByText(
            container,
            "This component will be placed in the slot by the .js code"
          );
          expect(elem).to.be.an.instanceof(HTMLParagraphElement);
        });
        it("should be able to set slots through the `slots` object property and replace the slot element", async () => {
          const container = await renderHTMLFrame(`
          <stateful-component5></stateful-component5>

          <template data-component="stateful-component5">
            <p>Something can be placed below:</p>
            <slot name="some-slot">This will be replaced</slot>
            <!-- ^ should be available to be replaced by setting options.slots["some-slot"] in the render function -->
          </template>

          <script src="/stateful-component5.js"><\/script>
        `);
          await inflictBoreDOM();
          const replaced = queryByText(
            container,
            "This will be replaced"
          );
          expect(replaced).to.be.null;
          const elem = getByText(
            container,
            "Text in a paragraph that replaced the slot"
          );
          expect(elem).to.be.an.instanceof(HTMLParagraphElement);
        });
        it("should place the slot name in a data attribute of the element that replaces it", async () => {
          const container = await renderHTMLFrame(`
          <stateful-component5></stateful-component5>

          <template data-component="stateful-component5">
            <p>Something can be placed below:</p>
            <slot name="some-slot">This will be replaced</slot>
            <!-- ^ should be available to be replaced by setting options.slots["some-slot"] in the render function -->
          </template>

          <script src="/stateful-component5.js"><\/script>
        `);
          await inflictBoreDOM();
          const elem = getByText(
            container,
            "Text in a paragraph that replaced the slot"
          );
          expect(elem.dataset.slot).to.be.string(
            "some-slot",
            "Should have a `data-slot='slot-name' attribute`"
          );
        });
        it("should allow script code to be defined in the `inflictBoreDOM()` function", async () => {
          const container = renderHTML(`
          <inline-component1></inline-component1>

          <template data-component="inline-component1">
            <p>Stateful inline component 1</p>
          </template>

          <!-- code will be set in inflictBoreDOM -->
        `);
          await inflictBoreDOM(void 0, {
            "inline-component1": webComponent(() => ({ self: self2 }) => {
              self2.innerHTML = "Inline code run";
            })
          });
          const elem = getByText(
            container,
            "Inline code run"
          );
          expect(elem).to.be.an.instanceof(HTMLElement);
          expect(elem.tagName).to.be.equals("INLINE-COMPONENT1");
        });
        it("should initialize all instances of the same component", async () => {
          const container = await renderHTMLFrame(`
          <multi-instance-component></multi-instance-component>
          <multi-instance-component></multi-instance-component>

          <template data-component="multi-instance-component">
            <p>Multi instance component</p>
          </template>

          <script src="/multi-instance-component.js"><\/script>
        `);
          await inflictBoreDOM();
          const instances = Array.from(
            container.querySelectorAll("multi-instance-component")
          );
          expect(instances.length).to.equal(2);
          expect(instances[0]).to.be.an.instanceof(HTMLElement);
          expect(instances[1]).to.be.an.instanceof(HTMLElement);
          expect(instances[0].getAttribute("data-index")).to.equal("0");
          expect(instances[1].getAttribute("data-index")).to.equal("1");
        });
      });
      describe("Event handlers in scripts", () => {
        it(
          "should handle custom events with the provided 'on' function",
          function(done) {
            (async () => {
              const container = await renderHTMLFrame(`
          <on-event-component1></on-event-component1>

          <template data-component="on-event-component1">
            <button onclick="dispatch('someCustomEventOnClick')">Click here to dispatch</butbbon>
          </template>
          <script src="/on-event-component1.js"><\/script>
        `);
              const state = { onDone: done };
              await inflictBoreDOM(state);
              const elem = getByText(
                container,
                "Click here to dispatch"
              );
              fireEvent.click(elem);
            })();
          }
        );
        it(
          "should be able to update the state and automatically render in the provided 'on' function",
          async () => {
            const container = await renderHTMLFrame(`
          <on-event-component2></on-event-component2>

          <template data-component="on-event-component2">
            <p data-ref="label">Value</p>
            <button onclick="dispatch('incrementClick')">Increment</button>
          </template>
          <script src="/on-event-component2.js"><\/script>
        `);
            const state = { value: 0 };
            await inflictBoreDOM(state);
            const labelElem = getByText(
              container,
              "0"
            );
            const btn = getByText(
              container,
              "Increment"
            );
            fireEvent.click(btn);
            await frame();
            const newLabelElem = getByText(
              container,
              "1"
            );
            expect(newLabelElem.innerText).to.be.string("1");
          }
        );
      });
      describe("State in component <script> code", () => {
        it("should pass the provided state ", async () => {
          const container = await renderHTMLFrame(`
          <stateful-component6></stateful-component6>

          <template data-component="stateful-component6">
            <p>Initial state is: <span data-ref="container"></span></p>
          </template>

          <script src="/stateful-component6.js"><\/script>
        `);
          await inflictBoreDOM({ content: { value: "Initial state" } });
          const elem = getByText(
            container,
            "Initial state"
          );
          expect(elem).to.be.an.instanceof(HTMLSpanElement);
        });
        it("should re-render when the provided state has changed", async () => {
          const container = await renderHTMLFrame(`
          <stateful-component6></stateful-component6>

          <template data-component="stateful-component6">
            <p>Initial state is: <span data-ref="container"></span></p>
          </template>

          <script src="/stateful-component6.js"><\/script>
        `);
          const state = { content: { value: "Initial state" } };
          await inflictBoreDOM(state);
          state.content.value = "This is new content";
          await frame();
          const elem = getByText(
            container,
            "This is new content"
          );
          expect(elem).to.be.an.instanceof(HTMLSpanElement);
        });
        it("should re-render when an array changed in the provided state", async () => {
          const container = await renderHTMLFrame(`
          <stateful-component7></stateful-component7>

          <template data-component="stateful-component7">
            <p>Initial state is: <span data-ref="container"></span></p>
          </template>

          <script src="/stateful-component7.js"><\/script>
        `);
          const state = { content: { value: ["Initial state"] } };
          await inflictBoreDOM(state);
          state.content.value[0] = "This is new content";
          await frame();
          const elem = getByText(
            container,
            "This is new content"
          );
          expect(elem).to.be.an.instanceof(HTMLSpanElement);
        });
        it("should re-render when an array changed in an event handler", async () => {
          const container = await renderHTMLFrame(`
          <stateful-component8></stateful-component8>

          <template data-component="stateful-component8">
            <button onclick="dispatch('update')">Click to update</button>
            <p>Initial state is: <span data-ref="container"></span></p>
          </template>

          <script src="/stateful-component8.js"><\/script>
        `);
          const state = { content: { value: ["Initial state"] } };
          await inflictBoreDOM(state);
          const btn = getByText(
            container,
            "Click to update"
          );
          fireEvent.click(btn);
          await frame();
          const elem = getByText(
            container,
            "This is new content"
          );
          expect(elem).to.be.an.instanceof(HTMLSpanElement);
        });
        it("should re-render when state changes in an async event handler", async () => {
          const container = await renderHTMLFrame(`
          <stateful-component9></stateful-component9>

          <template data-component="stateful-component9">
            <button onclick="dispatch('update')">Click to update</button>
            <p>Initial state is: <span data-ref="container"></span></p>
          </template>

          <script src="/stateful-component9.js"><\/script>
        `);
          const state = { content: { value: "Initial state" } };
          await inflictBoreDOM(state);
          const btn = getByText(
            container,
            "Click to update"
          );
          fireEvent.click(btn);
          await frame();
          await frame();
          const elem = getByText(
            container,
            "This is async content"
          );
          expect(elem).to.be.an.instanceof(HTMLSpanElement);
        });
        it("should re-render when nested objects are replaced in the state", async () => {
          const container = await renderHTMLFrame(`
          <stateful-component10></stateful-component10>

          <template data-component="stateful-component10">
            <span data-ref="value"></span>
          </template>

          <script src="/stateful-component10.js"><\/script>
        `);
          const state = { content: { nested: { value: "initial" } } };
          await inflictBoreDOM(state);
          state.content.nested = { value: "updated" };
          await frame();
          const elem = getByText(
            container,
            "updated"
          );
          expect(elem).to.be.an.instanceof(HTMLSpanElement);
        });
        it("should re-render nested updates gated behind an unrelated flag", async () => {
          const container = await renderHTMLFrame(`
          <stateful-component11></stateful-component11>

          <template data-component="stateful-component11">
            <p data-ref="info"></p>
          </template>

          <script src="/stateful-component11.js"><\/script>
        `);
          const state = {
            gpu: {
              isReady: false,
              info: { adapter: "none", device: "none" }
            }
          };
          await inflictBoreDOM(state);
          state.gpu.info = { adapter: "Ada", device: "RTX" };
          await frame();
          let elem = queryByText(container, "Adapter: Ada | Device: RTX");
          expect(elem).to.be.null;
          state.gpu.isReady = true;
          await frame();
          elem = getByText(container, "Adapter: Ada | Device: RTX");
          expect(elem).to.be.an.instanceof(HTMLParagraphElement);
        });
      });
      describe("Multi-hyphen component names", () => {
        it("should correctly match scripts when component names share prefixes", async () => {
          const container = await renderHTMLFrame(`
          <multi-hyphen-component></multi-hyphen-component>
          <multi-hyphen-component-extra></multi-hyphen-component-extra>

          <template data-component="multi-hyphen-component">
            <p>Short name component</p>
          </template>

          <template data-component="multi-hyphen-component-extra">
            <p>Long name component</p>
          </template>

          <!-- Order matters for reproducing the bug - longer name first -->
          <script src="/multi-hyphen-component-extra.js"><\/script>
          <script src="/multi-hyphen-component.js"><\/script>
        `);
          await inflictBoreDOM();
          const shortComponent = container.querySelector("multi-hyphen-component");
          const longComponent = container.querySelector("multi-hyphen-component-extra");
          expect(shortComponent?.getAttribute("data-loaded")).to.equal(
            "multi-hyphen-component",
            "multi-hyphen-component should load multi-hyphen-component.js, not the -extra version"
          );
          expect(longComponent?.getAttribute("data-loaded")).to.equal(
            "multi-hyphen-component-extra",
            "multi-hyphen-component-extra should load multi-hyphen-component-extra.js"
          );
        });
        it("should handle three-hyphen component names", async () => {
          const container = await renderHTMLFrame(`
          <my-super-cool-component></my-super-cool-component>

          <template data-component="my-super-cool-component">
            <p>Three hyphen component</p>
          </template>
        `);
          await inflictBoreDOM();
          const elem = container.querySelector("my-super-cool-component");
          expect(elem).to.be.an.instanceof(HTMLElement);
          expect(elem?.querySelector("p")?.textContent).to.equal("Three hyphen component");
        });
      });
      describe("Lists of components in <script> code", () => {
        it("should be able to dynamically create a component with a detail object", async () => {
          const container = await renderHTMLFrame(`
          <list-component1></list-component1>

          <template data-component="list-component1">
            <p>Below will be added a dynamic component</p>
            <ol>
            </ol>
          </template>
          <script src="/list-component1.js"><\/script>

          <template data-component="list-item1">
            <li></li>
          </template>
          <script src="/list-item1.js"><\/script>
        `);
          await frame();
          await inflictBoreDOM({ content: { items: ["some item"] } });
          const elem = getByText(
            container,
            "some item"
          );
          expect(elem).to.be.an.instanceof(HTMLElement);
        });
        it("should dynamically create multiple components", async () => {
          const container = await renderHTMLFrame(`
          <list-component1></list-component1>

          <template data-component="list-component1">
            <p>Below will be added a dynamic component</p>
            <ol>
            </ol>
          </template>
          <script src="/list-component1.js"><\/script>

          <template data-component="list-item1">
            <li></li>
          </template>
          <script src="/list-item1.js"><\/script>
        `);
          await frame();
          await inflictBoreDOM({
            content: { items: ["item A", "item B", "item C"] }
          });
          const elem1 = getByText(
            container,
            "item A"
          );
          const elem2 = getByText(
            container,
            "item B"
          );
          const elem3 = getByText(
            container,
            "item C"
          );
          expect(elem1).to.be.an.instanceof(HTMLElement);
          expect(elem2).to.be.an.instanceof(HTMLElement);
          expect(elem3).to.be.an.instanceof(HTMLElement);
        });
      });
      describe("Proxy internals", () => {
        describe("Mutation batching", () => {
          it("should batch multiple synchronous mutations into a single render", async () => {
            const container = await renderHTMLFrame(`
            <batching-component></batching-component>

            <template data-component="batching-component">
              <p>Batching test</p>
            </template>

            <script src="/batching-component.js"><\/script>
          `);
            const state = await inflictBoreDOM({ a: 0, b: 0, c: 0 });
            const elem = container.querySelector("batching-component");
            const initialRenderCount = elem.getAttribute("data-render-count");
            expect(initialRenderCount).to.equal("1");
            state.a = 1;
            state.b = 2;
            state.c = 3;
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("2");
            expect(elem.getAttribute("data-values")).to.equal("1,2,3");
          });
          it("should batch mutations across different paths into single render", async () => {
            const container = await renderHTMLFrame(`
            <batching-component></batching-component>

            <template data-component="batching-component">
              <p>Batching test</p>
            </template>

            <script src="/batching-component.js"><\/script>
          `);
            const state = await inflictBoreDOM({ a: 0, b: 0, c: 0 });
            const elem = container.querySelector("batching-component");
            for (let i = 0; i < 10; i++) {
              state.a = i;
            }
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("2");
            expect(elem.getAttribute("data-values")).to.equal("9,0,0");
          });
        });
        describe("Read-only state in render", () => {
          it("should block mutations to state within render function", async () => {
            const errors2 = [];
            const originalError = console.error;
            console.error = (...args) => {
              errors2.push(args);
              originalError.apply(console, args);
            };
            const container = await renderHTMLFrame(`
            <readonly-state-component></readonly-state-component>

            <template data-component="readonly-state-component">
              <p>Read-only test</p>
            </template>

            <script src="/readonly-state-component.js"><\/script>
          `);
            const state = { value: "original" };
            await inflictBoreDOM(state);
            console.error = originalError;
            const readOnlyErrors = errors2.filter(
              (e) => e[0] && typeof e[0] === "string" && e[0].includes("read-only")
            );
            expect(readOnlyErrors.length).to.be.greaterThan(0);
            expect(state.value).to.equal("original");
            const elem = container.querySelector("readonly-state-component");
            expect(elem.getAttribute("data-value")).to.equal("original");
          });
        });
        describe("Symbol key bypass", () => {
          it("should not trigger re-render when Symbol key is mutated", async () => {
            const container = await renderHTMLFrame(`
            <symbol-key-component></symbol-key-component>

            <template data-component="symbol-key-component">
              <p>Symbol key test</p>
            </template>

            <script src="/symbol-key-component.js"><\/script>
          `);
            const RUNTIME = Symbol("runtime");
            const state = await inflictBoreDOM({ count: 0, [RUNTIME]: { hidden: "initial" } });
            const elem = container.querySelector("symbol-key-component");
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            state[RUNTIME].hidden = "changed";
            state[RUNTIME] = { hidden: "replaced" };
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            state.count = 1;
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("2");
            expect(elem.getAttribute("data-count")).to.equal("1");
          });
        });
        describe("Multiple access chain path tracking", () => {
          it("should correctly track paths when accessing multiple state properties", async () => {
            const container = await renderHTMLFrame(`
            <multi-access-component></multi-access-component>

            <template data-component="multi-access-component">
              <p>Multi-access test</p>
            </template>
          `);
            let renderCount = 0;
            const state = await inflictBoreDOM({
              currentView: "clients",
              clients: [{ id: 1, name: "Alice", rate: 100 }]
            }, {
              "multi-access-component": webComponent(() => {
                return ({ self: self2, state: state2 }) => {
                  renderCount++;
                  const view = state2.currentView;
                  const names = state2.clients.map((c) => c.name);
                  self2.setAttribute("data-render-count", String(renderCount));
                  self2.setAttribute("data-view", view);
                  self2.setAttribute("data-names", names.join(","));
                };
              })
            });
            const elem = container.querySelector("multi-access-component");
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            expect(elem.getAttribute("data-view")).to.equal("clients");
            expect(elem.getAttribute("data-names")).to.equal("Alice");
            state.clients[0].name = "Bob";
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("2");
            expect(elem.getAttribute("data-names")).to.equal("Bob");
          });
          it("should re-render when array is mutated after accessing other properties", async () => {
            const container = await renderHTMLFrame(`
            <array-after-prop-component></array-after-prop-component>

            <template data-component="array-after-prop-component">
              <p>Array after prop test</p>
            </template>
          `);
            let renderCount = 0;
            const state = await inflictBoreDOM({
              title: "My App",
              items: ["a", "b", "c"]
            }, {
              "array-after-prop-component": webComponent(() => {
                return ({ self: self2, state: state2 }) => {
                  renderCount++;
                  const title = state2.title;
                  const items = state2.items;
                  self2.setAttribute("data-render-count", String(renderCount));
                  self2.setAttribute("data-title", title);
                  self2.setAttribute("data-items", items.join(","));
                };
              })
            });
            const elem = container.querySelector("array-after-prop-component");
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            state.items.push("d");
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("2");
            expect(elem.getAttribute("data-items")).to.equal("a,b,c,d");
          });
          it("should handle nested array iteration correctly", async () => {
            const container = await renderHTMLFrame(`
            <nested-array-iter-component></nested-array-iter-component>

            <template data-component="nested-array-iter-component">
              <p>Nested array iteration test</p>
            </template>
          `);
            let renderCount = 0;
            const state = await inflictBoreDOM({
              config: { enabled: true },
              users: [
                { id: 1, profile: { name: "Alice", email: "alice@test.com" } },
                { id: 2, profile: { name: "Bob", email: "bob@test.com" } }
              ]
            }, {
              "nested-array-iter-component": webComponent(() => {
                return ({ self: self2, state: state2 }) => {
                  renderCount++;
                  const enabled = state2.config.enabled;
                  const emails = state2.users.map((u) => u.profile.email);
                  self2.setAttribute("data-render-count", String(renderCount));
                  self2.setAttribute("data-enabled", String(enabled));
                  self2.setAttribute("data-emails", emails.join(","));
                };
              })
            });
            const elem = container.querySelector("nested-array-iter-component");
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            expect(elem.getAttribute("data-emails")).to.equal("alice@test.com,bob@test.com");
            state.users[0].profile.email = "alice.updated@test.com";
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("2");
            expect(elem.getAttribute("data-emails")).to.equal("alice.updated@test.com,bob@test.com");
          });
          it("should handle multiple array iterations in same render", async () => {
            const container = await renderHTMLFrame(`
            <multi-array-iter-component></multi-array-iter-component>

            <template data-component="multi-array-iter-component">
              <p>Multi array iteration test</p>
            </template>
          `);
            let renderCount = 0;
            const state = await inflictBoreDOM({
              clients: [{ name: "Client A" }, { name: "Client B" }],
              projects: [{ title: "Project 1" }, { title: "Project 2" }]
            }, {
              "multi-array-iter-component": webComponent(() => {
                return ({ self: self2, state: state2 }) => {
                  renderCount++;
                  const clientNames = state2.clients.map((c) => c.name);
                  const projectTitles = state2.projects.map((p) => p.title);
                  self2.setAttribute("data-render-count", String(renderCount));
                  self2.setAttribute("data-clients", clientNames.join(","));
                  self2.setAttribute("data-projects", projectTitles.join(","));
                };
              })
            });
            const elem = container.querySelector("multi-array-iter-component");
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            expect(elem.getAttribute("data-clients")).to.equal("Client A,Client B");
            expect(elem.getAttribute("data-projects")).to.equal("Project 1,Project 2");
            state.clients.push({ name: "Client C" });
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("2");
            expect(elem.getAttribute("data-clients")).to.equal("Client A,Client B,Client C");
            state.projects[0].title = "Updated Project 1";
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("3");
            expect(elem.getAttribute("data-projects")).to.equal("Updated Project 1,Project 2");
          });
          it("should work with complex time-tracker-like state", async () => {
            const container = await renderHTMLFrame(`
            <time-tracker-like-component></time-tracker-like-component>

            <template data-component="time-tracker-like-component">
              <p>Time tracker like test</p>
            </template>
          `);
            let renderCount = 0;
            const state = await inflictBoreDOM({
              currentView: "clients",
              clients: [
                { id: 1, name: "Acme Corp", rate: 150 },
                { id: 2, name: "Tech Inc", rate: 200 }
              ],
              entries: [
                { id: 1, clientId: 1, hours: 8, note: "Development" },
                { id: 2, clientId: 2, hours: 4, note: "Meeting" }
              ]
            }, {
              "time-tracker-like-component": webComponent(() => {
                return ({ self: self2, state: state2 }) => {
                  renderCount++;
                  const view = state2.currentView;
                  const clients = state2.clients;
                  const entries = state2.entries;
                  const clientSummary = clients.map((client) => {
                    const clientEntries = entries.filter((e) => e.clientId === client.id);
                    const totalHours = clientEntries.reduce((sum, e) => sum + e.hours, 0);
                    return `${client.name}:${totalHours}h`;
                  });
                  self2.setAttribute("data-render-count", String(renderCount));
                  self2.setAttribute("data-view", view);
                  self2.setAttribute("data-summary", clientSummary.join(";"));
                };
              })
            });
            const elem = container.querySelector("time-tracker-like-component");
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            expect(elem.getAttribute("data-view")).to.equal("clients");
            expect(elem.getAttribute("data-summary")).to.equal("Acme Corp:8h;Tech Inc:4h");
            state.clients.push({ id: 3, name: "New Co", rate: 175 });
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("2");
            expect(elem.getAttribute("data-summary")).to.equal("Acme Corp:8h;Tech Inc:4h;New Co:0h");
            state.entries.push({ id: 3, clientId: 3, hours: 2, note: "Onboarding" });
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("3");
            expect(elem.getAttribute("data-summary")).to.equal("Acme Corp:8h;Tech Inc:4h;New Co:2h");
            state.entries[0].hours = 10;
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("4");
            expect(elem.getAttribute("data-summary")).to.equal("Acme Corp:10h;Tech Inc:4h;New Co:2h");
          });
        });
        describe("Hierarchical subscription matching", () => {
          it("should re-render parent subscriber when child path changes", async () => {
            const container = await renderHTMLFrame(`
            <hierarchical-parent-component></hierarchical-parent-component>

            <template data-component="hierarchical-parent-component">
              <p>Parent subscriber</p>
            </template>

            <script src="/hierarchical-parent-component.js"><\/script>
          `);
            const state = { user: { name: "Alice", email: "alice@test.com" } };
            await inflictBoreDOM(state);
            const elem = container.querySelector("hierarchical-parent-component");
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            expect(elem.getAttribute("data-user-name")).to.equal("Alice");
            state.user.name = "Bob";
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("2");
            expect(elem.getAttribute("data-user-name")).to.equal("Bob");
          });
          it("should re-render child subscriber when parent object property changes", async () => {
            const container = await renderHTMLFrame(`
            <hierarchical-child-component></hierarchical-child-component>

            <template data-component="hierarchical-child-component">
              <p>Child subscriber</p>
            </template>

            <script src="/hierarchical-child-component.js"><\/script>
          `);
            const state = { user: { name: "Alice", email: "alice@test.com" } };
            await inflictBoreDOM(state);
            const elem = container.querySelector("hierarchical-child-component");
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            state.user.email = "alice2@test.com";
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            state.user.name = "Carol";
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("2");
            expect(elem.getAttribute("data-name")).to.equal("Carol");
          });
        });
        describe("Object replacement", () => {
          it("should re-render when a nested object is replaced", async () => {
            const container = await renderHTMLFrame(`
            <object-replacement-component></object-replacement-component>

            <template data-component="object-replacement-component">
              <p>Object replacement test</p>
            </template>

            <script src="/object-replacement-component.js"><\/script>
          `);
            const state = await inflictBoreDOM({ user: { name: "Alice", email: "alice@test.com" } });
            const elem = container.querySelector("object-replacement-component");
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            expect(elem.getAttribute("data-name")).to.equal("Alice");
            state.user = { name: "Bob", email: "bob@test.com" };
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("2");
            expect(elem.getAttribute("data-name")).to.equal("Bob");
            expect(elem.getAttribute("data-email")).to.equal("bob@test.com");
          });
          it("should continue to be reactive after object replacement", async () => {
            const container = await renderHTMLFrame(`
            <new-object-reactivity-component></new-object-reactivity-component>

            <template data-component="new-object-reactivity-component">
              <p>New object reactivity test</p>
            </template>

            <script src="/new-object-reactivity-component.js"><\/script>
          `);
            const state = await inflictBoreDOM({
              user: { name: "Alice", email: "alice@test.com" },
              data: { level1: { level2: { level3: { value: "initial" } } } },
              items: ["a", "b"]
            });
            const elem = container.querySelector("new-object-reactivity-component");
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            state.user = { name: "Bob", email: "bob@test.com" };
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("2");
            expect(elem.getAttribute("data-user-name")).to.equal("Bob");
            state.user.name = "Carol";
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("3");
            expect(elem.getAttribute("data-user-name")).to.equal("Carol");
          });
          it("should proxify deeply nested new objects", async () => {
            const container = await renderHTMLFrame(`
            <deep-object-test></deep-object-test>

            <template data-component="deep-object-test">
              <p>Deep object test</p>
            </template>
          `);
            let deepRenderCount = 0;
            const deepObjectComponent = webComponent(() => {
              return ({ self: self2, state: state2 }) => {
                deepRenderCount++;
                self2.setAttribute("data-render-count", String(deepRenderCount));
                self2.setAttribute("data-deep-value", state2.data?.level1?.level2?.level3?.value ?? "none");
              };
            });
            const state = await inflictBoreDOM({
              user: { name: "Alice" },
              data: {},
              items: []
            }, {
              "deep-object-test": deepObjectComponent
            });
            const elem = container.querySelector("deep-object-test");
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            state.data = {
              level1: {
                level2: {
                  level3: { value: "deep" }
                }
              }
            };
            await frame();
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("2");
            expect(elem.getAttribute("data-deep-value")).to.equal("deep");
            state.data.level1.level2.level3.value = "mutated deep";
            await frame();
            await frame();
            expect(elem.getAttribute("data-render-count")).to.equal("3");
            expect(elem.getAttribute("data-deep-value")).to.equal("mutated deep");
          });
          it("should proxify new arrays on replacement", async () => {
            const container = await renderHTMLFrame(`
            <array-replace-test></array-replace-test>

            <template data-component="array-replace-test">
              <p>Array replacement test</p>
            </template>
          `);
            let arrayRenderCount = 0;
            const arrayReplaceComponent = webComponent(() => {
              return ({ self: self2, state: state2 }) => {
                arrayRenderCount++;
                self2.setAttribute("data-render-count", String(arrayRenderCount));
                self2.setAttribute("data-items", state2.items?.join(",") ?? "none");
              };
            });
            const state = await inflictBoreDOM({
              user: { name: "Alice" },
              data: {},
              items: ["old1", "old2"]
            }, {
              "array-replace-test": arrayReplaceComponent
            });
            const elem = container.querySelector("array-replace-test");
            await frame();
            expect(elem.getAttribute("data-items")).to.equal("old1,old2");
            state.items = ["new1", "new2", "new3"];
            await frame();
            await frame();
            expect(elem.getAttribute("data-items")).to.equal("new1,new2,new3");
            state.items[0] = "mutated";
            await frame();
            await frame();
            expect(elem.getAttribute("data-items")).to.equal("mutated,new2,new3");
            state.items.push("pushed");
            await frame();
            await frame();
            expect(elem.getAttribute("data-items")).to.equal("mutated,new2,new3,pushed");
          });
          it("should proxify dynamically added nested objects", async () => {
            const container = await renderHTMLFrame(`
            <dynamic-nested-test></dynamic-nested-test>

            <template data-component="dynamic-nested-test">
              <p>Dynamic nested test</p>
            </template>
          `);
            let dynamicRenderCount = 0;
            const dynamicNestedComponent = webComponent(() => {
              return ({ self: self2, state: state2 }) => {
                dynamicRenderCount++;
                self2.setAttribute("data-render-count", String(dynamicRenderCount));
                self2.setAttribute("data-profile-bio", state2.user?.profile?.bio ?? "none");
              };
            });
            const state = await inflictBoreDOM({
              user: { name: "Alice" },
              data: {},
              items: []
            }, {
              "dynamic-nested-test": dynamicNestedComponent
            });
            const elem = container.querySelector("dynamic-nested-test");
            expect(elem.getAttribute("data-profile-bio")).to.equal("none");
            state.user.profile = { bio: "Hello", age: 25 };
            await frame();
            await frame();
            expect(elem.getAttribute("data-profile-bio")).to.equal("Hello");
            state.user.profile.bio = "Updated bio";
            await frame();
            await frame();
            expect(elem.getAttribute("data-profile-bio")).to.equal("Updated bio");
          });
        });
        describe("Array methods reactivity", () => {
          it("should re-render when array.push() is called", async () => {
            const container = await renderHTMLFrame(`
            <array-methods-component></array-methods-component>

            <template data-component="array-methods-component">
              <button onclick="dispatch('push')">Push</button>
            </template>

            <script src="/array-methods-component.js"><\/script>
          `);
            const state = { items: ["a", "b"] };
            await inflictBoreDOM(state);
            const elem = container.querySelector("array-methods-component");
            expect(elem.getAttribute("data-items")).to.equal("a,b");
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            const btn = container.querySelector("button");
            fireEvent.click(btn);
            await frame();
            expect(elem.getAttribute("data-items")).to.equal("a,b,new item");
            expect(elem.getAttribute("data-render-count")).to.equal("2");
          });
          it("should re-render when array.pop() is called", async () => {
            const container = await renderHTMLFrame(`
            <array-methods-component></array-methods-component>

            <template data-component="array-methods-component">
              <button onclick="dispatch('pop')">Pop</button>
            </template>

            <script src="/array-methods-component.js"><\/script>
          `);
            const state = { items: ["a", "b", "c"] };
            await inflictBoreDOM(state);
            const elem = container.querySelector("array-methods-component");
            expect(elem.getAttribute("data-items")).to.equal("a,b,c");
            const btn = container.querySelector("button");
            fireEvent.click(btn);
            await frame();
            expect(elem.getAttribute("data-items")).to.equal("a,b");
          });
          it("should re-render when array.splice() is called", async () => {
            const container = await renderHTMLFrame(`
            <array-methods-component></array-methods-component>

            <template data-component="array-methods-component">
              <button onclick="dispatch('splice')">Splice</button>
            </template>

            <script src="/array-methods-component.js"><\/script>
          `);
            const state = { items: ["a", "b", "c"] };
            await inflictBoreDOM(state);
            const elem = container.querySelector("array-methods-component");
            expect(elem.getAttribute("data-items")).to.equal("a,b,c");
            const btn = container.querySelector("button");
            fireEvent.click(btn);
            await frame();
            expect(elem.getAttribute("data-items")).to.equal("a,spliced,c");
          });
          it("should re-render when array index is directly set", async () => {
            const container = await renderHTMLFrame(`
            <array-methods-component></array-methods-component>

            <template data-component="array-methods-component">
              <p>Array test</p>
            </template>

            <script src="/array-methods-component.js"><\/script>
          `);
            const state = { items: ["a", "b", "c"] };
            await inflictBoreDOM(state);
            const elem = container.querySelector("array-methods-component");
            expect(elem.getAttribute("data-items")).to.equal("a,b,c");
            expect(elem.getAttribute("data-render-count")).to.equal("1");
            state.items[1] = "modified";
            await frame();
            expect(elem.getAttribute("data-items")).to.equal("a,modified,c");
            expect(elem.getAttribute("data-render-count")).to.equal("2");
          });
        });
      });
      describe("Refs edge cases", () => {
        it("should return an array when multiple elements share the same data-ref", async () => {
          const container = await renderHTMLFrame(`
          <multi-ref-component></multi-ref-component>

          <template data-component="multi-ref-component">
            <ul>
              <li data-ref="item">First</li>
              <li data-ref="item">Second</li>
              <li data-ref="item">Third</li>
            </ul>
          </template>

          <script src="/multi-ref-component.js"><\/script>
        `);
          await inflictBoreDOM();
          const elem = container.querySelector("multi-ref-component");
          expect(elem.getAttribute("data-ref-count")).to.equal("3");
          const items = elem.querySelectorAll("li");
          expect(items[0].textContent).to.equal("Item 0");
          expect(items[1].textContent).to.equal("Item 1");
          expect(items[2].textContent).to.equal("Item 2");
        });
        it("should return a single element when only one element has the data-ref", async () => {
          const container = await renderHTMLFrame(`
          <multi-ref-component></multi-ref-component>

          <template data-component="multi-ref-component">
            <ul>
              <li data-ref="item">Only one</li>
            </ul>
          </template>

          <script src="/multi-ref-component.js"><\/script>
        `);
          await inflictBoreDOM();
          const elem = container.querySelector("multi-ref-component");
          expect(elem.getAttribute("data-ref-count")).to.equal("1");
          const item = elem.querySelector("li");
          expect(item?.textContent).to.equal("Single item");
        });
      });
      describe("Slots edge cases", () => {
        it("should update slot content idempotently on multiple renders", async () => {
          const container = await renderHTMLFrame(`
          <slot-idempotent-component></slot-idempotent-component>

          <template data-component="slot-idempotent-component">
            <p><slot name="content">Default</slot></p>
          </template>
        `);
          await inflictBoreDOM(void 0, {
            "slot-idempotent-component": webComponent(() => {
              let renderCount = 0;
              return ({ slots, self: self2 }) => {
                renderCount++;
                slots.content = `Render ${renderCount}`;
                self2.setAttribute("data-render-count", String(renderCount));
              };
            })
          });
          const elem = container.querySelector("slot-idempotent-component");
          expect(elem.getAttribute("data-render-count")).to.equal("1");
          let slotContent = elem.querySelector("[data-slot='content']");
          expect(slotContent?.textContent).to.equal("Render 1");
          const state = { trigger: 0 };
          await inflictBoreDOM(state, {
            "slot-idempotent-component": webComponent(() => {
              let renderCount = 0;
              return ({ slots, self: self2, state: state2 }) => {
                renderCount++;
                slots.content = `Render ${renderCount} trigger ${state2?.trigger}`;
                self2.setAttribute("data-render-count", String(renderCount));
              };
            })
          });
          const slotElements = elem.querySelectorAll("[data-slot='content']");
          expect(slotElements.length).to.equal(1);
        });
        it("should handle slot replacement with HTMLElement", async () => {
          const container = await renderHTMLFrame(`
          <slot-element-component></slot-element-component>

          <template data-component="slot-element-component">
            <div><slot name="custom">Placeholder</slot></div>
          </template>
        `);
          await inflictBoreDOM(void 0, {
            "slot-element-component": webComponent(() => {
              return ({ slots }) => {
                const customElem = document.createElement("strong");
                customElem.textContent = "Bold content";
                customElem.classList.add("custom-class");
                slots.custom = customElem;
              };
            })
          });
          const elem = container.querySelector("slot-element-component");
          const strongElem = elem.querySelector("strong.custom-class");
          expect(strongElem).to.not.be.null;
          expect(strongElem?.textContent).to.equal("Bold content");
          expect(strongElem?.getAttribute("data-slot")).to.equal("custom");
        });
      });
      describe("Component detail object", () => {
        it("should pass correct index to each component instance", async () => {
          const container = await renderHTMLFrame(`
          <index-component></index-component>
          <index-component></index-component>
          <index-component></index-component>

          <template data-component="index-component">
            <span></span>
          </template>
        `);
          await inflictBoreDOM(void 0, {
            "index-component": webComponent(({ detail }) => {
              return ({ self: self2 }) => {
                self2.setAttribute("data-index", String(detail.index));
                self2.setAttribute("data-name", detail.name);
              };
            })
          });
          const components = container.querySelectorAll("index-component");
          expect(components[0].getAttribute("data-index")).to.equal("0");
          expect(components[1].getAttribute("data-index")).to.equal("1");
          expect(components[2].getAttribute("data-index")).to.equal("2");
          expect(components[0].getAttribute("data-name")).to.equal("index-component");
        });
        it("should pass custom data through detail when using makeComponent", async () => {
          const container = await renderHTMLFrame(`
          <parent-detail-component></parent-detail-component>

          <template data-component="parent-detail-component">
            <div data-ref="container"></div>
          </template>

          <template data-component="child-detail-component">
            <span></span>
          </template>
        `);
          await inflictBoreDOM(void 0, {
            "parent-detail-component": webComponent(() => {
              return ({ refs, makeComponent }) => {
                const child2 = makeComponent("child-detail-component", {
                  detail: { index: 42, name: "child-detail-component", data: { custom: "value" } }
                });
                refs.container.appendChild(child2);
              };
            }),
            "child-detail-component": webComponent(({ detail }) => {
              return ({ self: self2 }) => {
                self2.setAttribute("data-custom", detail.data?.custom ?? "none");
              };
            })
          });
          const child = container.querySelector("child-detail-component");
          expect(child.getAttribute("data-custom")).to.equal("value");
        });
      });
      describe("Edge cases and error handling", () => {
        it("should handle undefined state gracefully in render", async () => {
          const container = await renderHTMLFrame(`
          <undefined-state-component></undefined-state-component>

          <template data-component="undefined-state-component">
            <p data-ref="output">Waiting</p>
          </template>
        `);
          await inflictBoreDOM(void 0, {
            "undefined-state-component": webComponent(() => {
              return ({ state, refs }) => {
                if (!state) {
                  refs.output.textContent = "No state";
                  return;
                }
                refs.output.textContent = "Has state";
              };
            })
          });
          const output = container.querySelector("[data-ref='output']");
          expect(output.textContent).to.equal("No state");
        });
        it("should handle errors in event handlers gracefully", async () => {
          const errors2 = [];
          const originalError = console.error;
          console.error = (...args) => {
            errors2.push(args);
          };
          const container = await renderHTMLFrame(`
          <error-handler-component></error-handler-component>

          <template data-component="error-handler-component">
            <button onclick="dispatch('throwError')">Throw</button>
            <p data-ref="status">OK</p>
          </template>
        `);
          await inflictBoreDOM(void 0, {
            "error-handler-component": webComponent(({ on }) => {
              on("throwError", () => {
                throw new Error("Test error");
              });
              return ({ refs }) => {
                refs.status.textContent = "Rendered";
              };
            })
          });
          const btn = container.querySelector("button");
          fireEvent.click(btn);
          console.error = originalError;
          const errorLogs = errors2.filter(
            (e) => e[0] && typeof e[0] === "string" && e[0].includes("Error")
          );
          expect(errorLogs.length).to.be.greaterThan(0);
          const status = container.querySelector("[data-ref='status']");
          expect(status.textContent).to.equal("Rendered");
        });
        it("should not re-render when setting same value", async () => {
          const container = await renderHTMLFrame(`
          <same-value-component></same-value-component>

          <template data-component="same-value-component">
            <p>Same value test</p>
          </template>
        `);
          let renderCount = 0;
          const state = await inflictBoreDOM({ value: "test" }, {
            "same-value-component": webComponent(() => {
              return ({ self: self2, state: state2 }) => {
                renderCount++;
                self2.setAttribute("data-value", state2.value ?? "none");
                self2.setAttribute("data-render-count", String(renderCount));
              };
            })
          });
          expect(renderCount).to.equal(1);
          state.value = "test";
          await frame();
          expect(renderCount).to.equal(1);
          state.value = "different";
          await frame();
          expect(renderCount).to.equal(2);
        });
      });
    });
    describe("Utility functions", () => {
      describe("flatten()", () => {
        it("should flatten a simple object into path-value pairs", () => {
          const obj = { a: 1, b: 2 };
          const result = flatten(obj);
          expect(result).to.deep.include({ path: ["a"], value: 1 });
          expect(result).to.deep.include({ path: ["b"], value: 2 });
        });
        it("should flatten nested objects recursively", () => {
          const obj = { a: { b: { c: 1 } } };
          const result = flatten(obj);
          expect(result).to.deep.include({ path: ["a"], value: { b: { c: 1 } } });
          expect(result).to.deep.include({ path: ["a", "b"], value: { c: 1 } });
          expect(result).to.deep.include({ path: ["a", "b", "c"], value: 1 });
        });
        it("should ignore keys specified in the ignore array", () => {
          const obj = { a: 1, internal: { secret: "hidden" }, b: 2 };
          const result = flatten(obj, ["internal"]);
          expect(result).to.deep.include({ path: ["a"], value: 1 });
          expect(result).to.deep.include({ path: ["b"], value: 2 });
          const internalPaths = result.filter((r) => r.path.includes("internal"));
          expect(internalPaths.length).to.equal(0);
        });
        it("should handle arrays within objects", () => {
          const obj = { items: [1, 2, 3] };
          const result = flatten(obj);
          expect(result).to.deep.include({ path: ["items"], value: [1, 2, 3] });
          expect(result).to.deep.include({ path: ["items", "0"], value: 1 });
          expect(result).to.deep.include({ path: ["items", "1"], value: 2 });
          expect(result).to.deep.include({ path: ["items", "2"], value: 3 });
        });
        it("should handle empty objects", () => {
          const obj = {};
          const result = flatten(obj);
          expect(result).to.deep.equal([]);
        });
        it("should handle objects with null values", () => {
          const obj = { a: null, b: 1 };
          const result = flatten(obj);
          expect(result).to.deep.include({ path: ["a"], value: null });
          expect(result).to.deep.include({ path: ["b"], value: 1 });
        });
      });
      describe("access()", () => {
        it("should access top-level properties", () => {
          const obj = { a: 1, b: 2 };
          expect(access(["a"], obj)).to.equal(1);
          expect(access(["b"], obj)).to.equal(2);
        });
        it("should access nested properties", () => {
          const obj = { foo: { bar: { baz: "deep" } } };
          expect(access(["foo", "bar", "baz"], obj)).to.equal("deep");
          expect(access(["foo", "bar"], obj)).to.deep.equal({ baz: "deep" });
        });
        it("should return undefined for non-existent paths", () => {
          const obj = { a: 1 };
          expect(access(["b"], obj)).to.be.undefined;
          expect(access(["a", "b"], obj)).to.be.undefined;
        });
        it("should return the object itself for empty path", () => {
          const obj = { a: 1 };
          expect(access([], obj)).to.deep.equal(obj);
        });
        it("should handle array indices in path", () => {
          const obj = { items: ["a", "b", "c"] };
          expect(access(["items", "0"], obj)).to.equal("a");
          expect(access(["items", "2"], obj)).to.equal("c");
        });
        it("should handle null gracefully", () => {
          expect(access(["a"], null)).to.be.null;
        });
      });
      describe("isPOJO()", () => {
        it("should return true for plain objects", () => {
          expect(isPOJO({})).to.be.true;
          expect(isPOJO({ a: 1 })).to.be.true;
          expect(isPOJO({ nested: { object: true } })).to.be.true;
        });
        it("should return false for arrays", () => {
          expect(isPOJO([])).to.be.false;
          expect(isPOJO([1, 2, 3])).to.be.false;
        });
        it("should return false for null", () => {
          expect(isPOJO(null)).to.be.false;
        });
        it("should return false for undefined", () => {
          expect(isPOJO(void 0)).to.be.false;
        });
        it("should return false for primitives", () => {
          expect(isPOJO(42)).to.be.false;
          expect(isPOJO("string")).to.be.false;
          expect(isPOJO(true)).to.be.false;
          expect(isPOJO(Symbol("test"))).to.be.false;
        });
        it("should return false for class instances", () => {
          class MyClass {
            value = 1;
          }
          expect(isPOJO(new MyClass())).to.be.false;
        });
        it("should return false for built-in objects", () => {
          expect(isPOJO(/* @__PURE__ */ new Date())).to.be.false;
          expect(isPOJO(/* @__PURE__ */ new Map())).to.be.false;
          expect(isPOJO(/* @__PURE__ */ new Set())).to.be.false;
          expect(isPOJO(/regex/)).to.be.false;
        });
        it("should return false for functions", () => {
          expect(isPOJO(() => {
          })).to.be.false;
          expect(isPOJO(function() {
          })).to.be.false;
        });
        it("should return true for Object.create(null)", () => {
          const nullProto = /* @__PURE__ */ Object.create(null);
          nullProto.a = 1;
          expect(isPOJO(nullProto)).to.be.true;
        });
      });
    });
  }

  // tests/debug.test.ts
  var import_mocha2 = __toESM(require_mocha());
  async function frame2() {
    return new Promise((resolve) => {
      requestAnimationFrame((t) => resolve(t));
    });
  }
  async function renderHTMLFrame2(html2) {
    const main = document.querySelector("main");
    if (!main) throw new Error("No <main> found!");
    main.innerHTML = html2;
    return new Promise((resolve) => {
      requestAnimationFrame(() => {
        resolve(main);
      });
    });
  }
  function captureConsole() {
    const logs = [];
    const errors2 = [];
    const infos = [];
    const warns = [];
    const originalLog = console.log;
    const originalError = console.error;
    const originalInfo = console.info;
    const originalWarn = console.warn;
    console.log = (...args) => {
      logs.push(args);
    };
    console.error = (...args) => {
      errors2.push(args);
    };
    console.info = (...args) => {
      infos.push(args);
    };
    console.warn = (...args) => {
      warns.push(args);
    };
    return {
      logs,
      errors: errors2,
      infos,
      warns,
      restore: () => {
        console.log = originalLog;
        console.error = originalError;
        console.info = originalInfo;
        console.warn = originalWarn;
      }
    };
  }
  function clearWindowGlobals() {
    const w = window;
    delete w.$state;
    delete w.$refs;
    delete w.$slots;
    delete w.$self;
    delete w.$error;
    delete w.$component;
    delete w.$rerender;
  }
  function debug_test_default() {
    describe("Error-Driven Development", () => {
      beforeEach(function() {
        const main = document.querySelector("main");
        if (!main) return;
        main.innerHTML = "";
        setDebugConfig(true);
        clearWindowGlobals();
        clearGlobals();
        const errorKeys2 = [...boreDOM.errors.keys()];
        for (const tagName of errorKeys2) {
          boreDOM.clearError(tagName);
        }
        boreDOM.clearError();
      });
      afterEach(function() {
        clearWindowGlobals();
      });
      describe("Error Boundary", () => {
        it("should catch render errors and prevent component crash", async () => {
          const container = await renderHTMLFrame2(`
          <error-boundary-test1></error-boundary-test1>

          <template data-component="error-boundary-test1">
            <p>Error boundary test</p>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ shouldError: true }, {
            "error-boundary-test1": webComponent(() => {
              return ({ state }) => {
                if (state?.shouldError) {
                  throw new Error("Intentional render error");
                }
              };
            })
          });
          capture.restore();
          const errorLogs = capture.errors.filter(
            (e) => e[0]?.message?.includes?.("Intentional render error") || typeof e[0] === "object" && e[0]?.message === "Intentional render error"
          );
          expect(errorLogs.length).to.be.greaterThan(0);
          const elem = container.querySelector("error-boundary-test1");
          expect(elem).to.not.be.null;
          clearWindowGlobals();
        });
        it("should catch init errors and use no-op renderer", async () => {
          const container = await renderHTMLFrame2(`
          <error-init-test1></error-init-test1>

          <template data-component="error-init-test1">
            <p>Init error test</p>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM(void 0, {
            "error-init-test1": webComponent(() => {
              throw new Error("Intentional init error");
            })
          });
          capture.restore();
          const elem = container.querySelector("error-init-test1");
          expect(elem).to.not.be.null;
          expect(elem?.textContent).to.include("Init error test");
        });
        it("should prevent one component error from breaking others", async () => {
          const container = await renderHTMLFrame2(`
          <error-cascade-good></error-cascade-good>
          <error-cascade-bad></error-cascade-bad>
          <error-cascade-good2></error-cascade-good2>

          <template data-component="error-cascade-good">
            <p>Good component</p>
          </template>

          <template data-component="error-cascade-bad">
            <p>Bad component</p>
          </template>

          <template data-component="error-cascade-good2">
            <p>Good component 2</p>
          </template>
        `);
          const capture = captureConsole();
          let goodRendered = false;
          let good2Rendered = false;
          await inflictBoreDOM(void 0, {
            "error-cascade-good": webComponent(() => {
              return ({ self: self2 }) => {
                goodRendered = true;
                self2.setAttribute("data-rendered", "true");
              };
            }),
            "error-cascade-bad": webComponent(() => {
              return () => {
                throw new Error("Bad component error");
              };
            }),
            "error-cascade-good2": webComponent(() => {
              return ({ self: self2 }) => {
                good2Rendered = true;
                self2.setAttribute("data-rendered", "true");
              };
            })
          });
          capture.restore();
          expect(goodRendered).to.be.true;
          expect(good2Rendered).to.be.true;
          const good = container.querySelector("error-cascade-good");
          const good2 = container.querySelector("error-cascade-good2");
          expect(good?.getAttribute("data-rendered")).to.equal("true");
          expect(good2?.getAttribute("data-rendered")).to.equal("true");
          clearWindowGlobals();
        });
      });
      describe("Debug Globals", () => {
        it("should expose $state, $refs, $slots, $self, $error, $component, $rerender when error occurs", async () => {
          const container = await renderHTMLFrame2(`
          <globals-test1></globals-test1>

          <template data-component="globals-test1">
            <span data-ref="myRef">Ref element</span>
            <slot name="mySlot">Slot content</slot>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ value: "test-state" }, {
            "globals-test1": webComponent(() => {
              return ({ state }) => {
                if (state?.value) {
                  throw new Error("Trigger error for globals");
                }
              };
            })
          });
          capture.restore();
          const w = window;
          expect(w.$state).to.not.be.undefined;
          expect(w.$state.value).to.equal("test-state");
          expect(w.$refs).to.not.be.undefined;
          expect(w.$self).to.not.be.undefined;
          expect(w.$error).to.be.an.instanceof(Error);
          expect(w.$component).to.equal("globals-test1");
          expect(w.$rerender).to.be.a("function");
          clearWindowGlobals();
        });
        it("should NOT expose globals when debug: false", async () => {
          const container = await renderHTMLFrame2(`
          <globals-test2></globals-test2>

          <template data-component="globals-test2">
            <p>No globals test</p>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ value: "test" }, {
            "globals-test2": webComponent(() => {
              return ({ state }) => {
                if (state?.value) {
                  throw new Error("Error without globals");
                }
              };
            })
          }, { debug: false });
          capture.restore();
          const w = window;
          expect(w.$state).to.be.undefined;
          expect(w.$refs).to.be.undefined;
          expect(w.$self).to.be.undefined;
          expect(w.$error).to.be.undefined;
          expect(w.$component).to.be.undefined;
          expect(w.$rerender).to.be.undefined;
        });
        it("should NOT expose globals with granular { globals: false }", async () => {
          const container = await renderHTMLFrame2(`
          <globals-test3></globals-test3>

          <template data-component="globals-test3">
            <p>Granular globals test</p>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ value: "test" }, {
            "globals-test3": webComponent(() => {
              return ({ state }) => {
                if (state?.value) {
                  throw new Error("Error with granular config");
                }
              };
            })
          }, { debug: { globals: false, console: true, errorBoundary: true } });
          capture.restore();
          const w = window;
          expect(w.$state).to.be.undefined;
          expect(w.$refs).to.be.undefined;
          expect(w.$error).to.be.undefined;
        });
      });
      describe("Console Output", () => {
        it("should log full debug context when console enabled", async () => {
          const container = await renderHTMLFrame2(`
          <console-test1></console-test1>

          <template data-component="console-test1">
            <p>Console test</p>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ value: "test" }, {
            "console-test1": webComponent(() => {
              return ({ state }) => {
                if (state?.value) {
                  throw new Error("Console test error");
                }
              };
            })
          });
          capture.restore();
          const headerLogs = capture.logs.filter(
            (l) => l[0]?.includes?.("boreDOM") || l[0]?.includes?.("Debug context")
          );
          expect(headerLogs.length).to.be.greaterThan(0);
          clearWindowGlobals();
        });
        it("should log minimal output when debug: false", async () => {
          const container = await renderHTMLFrame2(`
          <console-test2></console-test2>

          <template data-component="console-test2">
            <p>Minimal console test</p>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ value: "test" }, {
            "console-test2": webComponent(() => {
              return ({ state }) => {
                if (state?.value) {
                  throw new Error("Minimal console error");
                }
              };
            })
          }, { debug: false });
          capture.restore();
          const minimalLogs = capture.errors.filter(
            (e) => typeof e[0] === "string" && e[0].includes("[boreDOM]")
          );
          expect(minimalLogs.length).to.be.greaterThan(0);
          const debugLogs = capture.logs.filter(
            (l) => l[0]?.includes?.("Debug context")
          );
          expect(debugLogs.length).to.equal(0);
        });
      });
      describe("Visual Error Indicators", () => {
        it("should add data-boredom-error attribute on error", async () => {
          const container = await renderHTMLFrame2(`
          <visual-test1></visual-test1>

          <template data-component="visual-test1">
            <p>Visual indicator test</p>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ shouldError: true }, {
            "visual-test1": webComponent(() => {
              return ({ state }) => {
                if (state?.shouldError) {
                  throw new Error("Visual indicator error");
                }
              };
            })
          });
          capture.restore();
          const elem = container.querySelector("visual-test1");
          expect(elem?.getAttribute("data-boredom-error")).to.equal("true");
          clearWindowGlobals();
        });
        it("should clear data-boredom-error on successful render", async () => {
          const container = await renderHTMLFrame2(`
          <visual-test2></visual-test2>

          <template data-component="visual-test2">
            <p>Visual clear test</p>
          </template>
        `);
          const capture = captureConsole();
          const state = await inflictBoreDOM({ shouldError: true }, {
            "visual-test2": webComponent(() => {
              return ({ state: state2, self: self2 }) => {
                if (state2?.shouldError) {
                  throw new Error("First render error");
                }
                self2.setAttribute("data-success", "true");
              };
            })
          });
          const elem = container.querySelector("visual-test2");
          expect(elem?.getAttribute("data-boredom-error")).to.equal("true");
          state.shouldError = false;
          boreDOM.rerender("visual-test2");
          await frame2();
          capture.restore();
          expect(elem?.getAttribute("data-boredom-error")).to.be.null;
          expect(elem?.getAttribute("data-success")).to.equal("true");
          clearWindowGlobals();
        });
        it("should NOT add visual indicator when visualIndicators: false", async () => {
          const container = await renderHTMLFrame2(`
          <visual-test3></visual-test3>

          <template data-component="visual-test3">
            <p>No visual indicator test</p>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ shouldError: true }, {
            "visual-test3": webComponent(() => {
              return ({ state }) => {
                if (state?.shouldError) {
                  throw new Error("No visual indicator error");
                }
              };
            })
          }, { debug: { visualIndicators: false } });
          capture.restore();
          const elem = container.querySelector("visual-test3");
          expect(elem?.getAttribute("data-boredom-error")).to.be.null;
          clearWindowGlobals();
        });
      });
      describe("Error History (boreDOM.errors)", () => {
        it("should store errors in boreDOM.errors map", async () => {
          const container = await renderHTMLFrame2(`
          <history-test1></history-test1>

          <template data-component="history-test1">
            <p>Error history test</p>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ shouldError: true }, {
            "history-test1": webComponent(() => {
              return ({ state }) => {
                if (state?.shouldError) {
                  throw new Error("History test error");
                }
              };
            })
          });
          capture.restore();
          expect(boreDOM.errors.size).to.equal(1);
          expect(boreDOM.errors.has("history-test1")).to.be.true;
          const ctx = boreDOM.errors.get("history-test1");
          expect(ctx?.error.message).to.equal("History test error");
          expect(ctx?.component).to.equal("history-test1");
          clearWindowGlobals();
        });
        it("should update lastError with most recent error", async () => {
          expect(isDebugEnabled("errorHistory")).to.be.true;
          const container = await renderHTMLFrame2(`
          <history-test2a></history-test2a>
          <history-test2b></history-test2b>

          <template data-component="history-test2a">
            <p>First error</p>
          </template>

          <template data-component="history-test2b">
            <p>Second error</p>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ shouldError: true }, {
            "history-test2a": webComponent(() => {
              return ({ state }) => {
                if (state?.shouldError) {
                  throw new Error("First error");
                }
              };
            }),
            "history-test2b": webComponent(() => {
              return ({ state }) => {
                if (state?.shouldError) {
                  throw new Error("Second error");
                }
              };
            })
          });
          capture.restore();
          expect(isDebugEnabled("errorHistory")).to.be.true;
          expect(boreDOM.errors.size).to.equal(2);
          expect(boreDOM.lastError).to.not.be.null;
          clearWindowGlobals();
        });
        it("should NOT store errors when errorHistory: false", async () => {
          const container = await renderHTMLFrame2(`
          <history-test3></history-test3>

          <template data-component="history-test3">
            <p>No history test</p>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ shouldError: true }, {
            "history-test3": webComponent(() => {
              return ({ state }) => {
                if (state?.shouldError) {
                  throw new Error("No history error");
                }
              };
            })
          }, { debug: { errorHistory: false } });
          capture.restore();
          expect(boreDOM.errors.size).to.equal(0);
          clearWindowGlobals();
        });
        it("should clear error from history on successful render", async () => {
          const container = await renderHTMLFrame2(`
          <history-test4></history-test4>

          <template data-component="history-test4">
            <p>Clear history test</p>
          </template>
        `);
          const capture = captureConsole();
          const state = await inflictBoreDOM({ shouldError: true }, {
            "history-test4": webComponent(() => {
              return ({ state: state2 }) => {
                if (state2?.shouldError) {
                  throw new Error("Clear history error");
                }
              };
            })
          });
          expect(boreDOM.errors.has("history-test4")).to.be.true;
          state.shouldError = false;
          boreDOM.rerender("history-test4");
          await frame2();
          capture.restore();
          expect(boreDOM.errors.has("history-test4")).to.be.false;
          clearWindowGlobals();
        });
      });
      describe("boreDOM API", () => {
        it("boreDOM.rerender() should re-render the last errored component", async () => {
          const container = await renderHTMLFrame2(`
          <api-rerender-test></api-rerender-test>

          <template data-component="api-rerender-test">
            <p>Rerender API test</p>
          </template>
        `);
          const capture = captureConsole();
          let renderCount = 0;
          await inflictBoreDOM({ shouldError: true }, {
            "api-rerender-test": webComponent(() => {
              return ({ state, self: self2 }) => {
                renderCount++;
                self2.setAttribute("data-render-count", String(renderCount));
                if (state?.shouldError) {
                  throw new Error("Rerender test error");
                }
              };
            })
          });
          expect(renderCount).to.equal(1);
          boreDOM.rerender();
          await frame2();
          capture.restore();
          expect(renderCount).to.equal(2);
          const elem = container.querySelector("api-rerender-test");
          expect(elem?.getAttribute("data-render-count")).to.equal("2");
          clearWindowGlobals();
        });
        it("boreDOM.rerender(tagName) should re-render specific component", async () => {
          const container = await renderHTMLFrame2(`
          <api-rerender-specific></api-rerender-specific>

          <template data-component="api-rerender-specific">
            <p>Specific rerender test</p>
          </template>
        `);
          const capture = captureConsole();
          let renderCount = 0;
          await inflictBoreDOM({ shouldError: true }, {
            "api-rerender-specific": webComponent(() => {
              return ({ state, self: self2 }) => {
                renderCount++;
                self2.setAttribute("data-render-count", String(renderCount));
                if (state?.shouldError) {
                  throw new Error("Specific rerender error");
                }
              };
            })
          });
          expect(renderCount).to.equal(1);
          boreDOM.rerender("api-rerender-specific");
          await frame2();
          capture.restore();
          expect(renderCount).to.equal(2);
          clearWindowGlobals();
        });
        it("boreDOM.clearError() should clear error state", async () => {
          const container = await renderHTMLFrame2(`
          <api-clear-test></api-clear-test>

          <template data-component="api-clear-test">
            <p>Clear error test</p>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ shouldError: true }, {
            "api-clear-test": webComponent(() => {
              return ({ state }) => {
                if (state?.shouldError) {
                  throw new Error("Clear error test");
                }
              };
            })
          });
          const elem = container.querySelector("api-clear-test");
          expect(elem?.getAttribute("data-boredom-error")).to.equal("true");
          expect(boreDOM.errors.has("api-clear-test")).to.be.true;
          boreDOM.clearError("api-clear-test");
          capture.restore();
          expect(elem?.getAttribute("data-boredom-error")).to.be.null;
          expect(boreDOM.errors.has("api-clear-test")).to.be.false;
        });
        it("boreDOM.export() should return state snapshot", async () => {
          const container = await renderHTMLFrame2(`
          <api-export-test></api-export-test>

          <template data-component="api-export-test">
            <p>Export test</p>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ value: "export-test-value", nested: { data: 42 } }, {
            "api-export-test": webComponent(() => {
              return ({ state }) => {
                if (state?.value) {
                  throw new Error("Export test error");
                }
              };
            })
          });
          capture.restore();
          const exported = boreDOM.export("api-export-test");
          expect(exported).to.not.be.null;
          expect(exported.component).to.equal("api-export-test");
          expect(exported.state.value).to.equal("export-test-value");
          expect(exported.state.nested.data).to.equal(42);
          expect(exported.error).to.equal("Export test error");
          expect(exported.timestamp).to.be.a("string");
          clearWindowGlobals();
        });
        it("boreDOM.config should return current debug configuration", () => {
          const configBefore = boreDOM.config;
          expect(configBefore.globals).to.be.true;
          expect(isDebugEnabled("globals")).to.be.true;
          setDebugConfig({
            console: true,
            globals: false,
            errorBoundary: true,
            visualIndicators: true,
            errorHistory: false,
            versionLog: false
          });
          const configAfter = boreDOM.config;
          expect(configAfter.globals).to.be.false;
          expect(configAfter.console).to.be.true;
          expect(configAfter.errorBoundary).to.be.true;
          expect(configAfter.errorHistory).to.be.false;
          expect(isDebugEnabled("globals")).to.be.false;
          expect(isDebugEnabled("console")).to.be.true;
        });
        it("boreDOM.version should return the version string", () => {
          expect(boreDOM.version).to.be.a("string");
          expect(boreDOM.version).to.match(/^\d+\.\d+\.\d+$/);
        });
      });
      describe("$rerender() Global Function", () => {
        it("$rerender() should allow fixing state and re-rendering", async () => {
          const container = await renderHTMLFrame2(`
          <rerender-global-test></rerender-global-test>

          <template data-component="rerender-global-test">
            <p data-ref="output">Initial</p>
          </template>
        `);
          const capture = captureConsole();
          let renderCount = 0;
          await inflictBoreDOM({ shouldError: true, message: "before fix" }, {
            "rerender-global-test": webComponent(() => {
              return ({ state, refs, self: self2 }) => {
                renderCount++;
                self2.setAttribute("data-render-count", String(renderCount));
                if (state?.shouldError) {
                  throw new Error("Rerender global test");
                }
                refs.output.textContent = state?.message || "none";
              };
            })
          });
          const w = window;
          expect(w.$state).to.not.be.undefined;
          expect(w.$rerender).to.be.a("function");
          w.$state.shouldError = false;
          w.$state.message = "after fix";
          w.$rerender();
          await frame2();
          await frame2();
          capture.restore();
          const elem = container.querySelector("rerender-global-test");
          const finalRenderCount = parseInt(elem?.getAttribute("data-render-count") || "0");
          expect(finalRenderCount).to.be.at.least(2);
          expect(elem?.getAttribute("data-boredom-error")).to.be.null;
          const output = container.querySelector("[data-ref='output']");
          expect(output?.textContent).to.equal("after fix");
          clearWindowGlobals();
        });
      });
      describe("Granular Debug Configuration", () => {
        it("should respect individual debug options", async () => {
          setDebugConfig({
            console: false,
            globals: true,
            errorBoundary: true,
            visualIndicators: false,
            errorHistory: true,
            versionLog: false
          });
          expect(isDebugEnabled("console")).to.be.false;
          expect(isDebugEnabled("globals")).to.be.true;
          expect(isDebugEnabled("errorBoundary")).to.be.true;
          expect(isDebugEnabled("visualIndicators")).to.be.false;
          expect(isDebugEnabled("errorHistory")).to.be.true;
          expect(isDebugEnabled("versionLog")).to.be.false;
        });
        it("setDebugConfig(false) should disable all except errorBoundary", () => {
          setDebugConfig(false);
          expect(isDebugEnabled("console")).to.be.false;
          expect(isDebugEnabled("globals")).to.be.false;
          expect(isDebugEnabled("visualIndicators")).to.be.false;
          expect(isDebugEnabled("errorHistory")).to.be.false;
          expect(isDebugEnabled("versionLog")).to.be.false;
          expect(isDebugEnabled("errorBoundary")).to.be.true;
        });
        it("setDebugConfig(true) should enable all options", () => {
          setDebugConfig(true);
          expect(isDebugEnabled("console")).to.be.true;
          expect(isDebugEnabled("globals")).to.be.true;
          expect(isDebugEnabled("errorBoundary")).to.be.true;
          expect(isDebugEnabled("visualIndicators")).to.be.true;
          expect(isDebugEnabled("errorHistory")).to.be.true;
          expect(isDebugEnabled("versionLog")).to.be.true;
        });
      });
      describe("Version Logging", () => {
        it("should log version when versionLog enabled", async () => {
          setDebugConfig(true);
          const capture = captureConsole();
          const container = await renderHTMLFrame2(`
          <version-log-test></version-log-test>

          <template data-component="version-log-test">
            <p>Version log test</p>
          </template>
        `);
          await inflictBoreDOM(void 0, {
            "version-log-test": webComponent(() => {
              return () => {
              };
            })
          });
          capture.restore();
          expect(boreDOM.version).to.be.a("string");
        });
      });
      describe("Error Context", () => {
        it("should provide complete ErrorContext with all fields", async () => {
          const container = await renderHTMLFrame2(`
          <context-test></context-test>

          <template data-component="context-test">
            <span data-ref="myRef">Reference</span>
            <slot name="mySlot">Slot</slot>
          </template>
        `);
          const capture = captureConsole();
          await inflictBoreDOM({ testValue: 123 }, {
            "context-test": webComponent(() => {
              return ({ state }) => {
                if (state?.testValue) {
                  throw new Error("Context test error");
                }
              };
            })
          });
          capture.restore();
          const ctx = boreDOM.errors.get("context-test");
          expect(ctx).to.not.be.undefined;
          expect(ctx?.component).to.equal("context-test");
          expect(ctx?.element).to.be.an.instanceof(HTMLElement);
          expect(ctx?.error).to.be.an.instanceof(Error);
          expect(ctx?.error.message).to.equal("Context test error");
          expect(ctx?.state).to.not.be.undefined;
          expect((ctx?.state).testValue).to.equal(123);
          expect(ctx?.refs).to.not.be.undefined;
          expect(ctx?.slots).to.not.be.undefined;
          expect(ctx?.timestamp).to.be.a("number");
          expect(ctx?.rerender).to.be.a("function");
          expect(ctx?.stack).to.be.a("string");
          clearWindowGlobals();
        });
      });
      describe("No Error Boundary Mode", () => {
        it("should not catch errors when errorBoundary: false", async () => {
          const container = await renderHTMLFrame2(`
          <no-boundary-test></no-boundary-test>

          <template data-component="no-boundary-test">
            <p>No boundary test</p>
          </template>
        `);
          const capture = captureConsole();
          let errorThrown = false;
          try {
            await inflictBoreDOM({ shouldError: true }, {
              "no-boundary-test": webComponent(() => {
                return ({ state }) => {
                  if (state?.shouldError) {
                    throw new Error("No boundary error");
                  }
                };
              })
            }, { debug: { errorBoundary: false } });
          } catch (e) {
            errorThrown = true;
            expect(e.message).to.equal("No boundary error");
          }
          capture.restore();
          expect(errorThrown).to.be.true;
        });
      });
      describe("Serialization Error Logging (code review fixes)", () => {
        it("boreDOM.export() should warn when serialization fails", async () => {
          const container = await renderHTMLFrame2(`
          <export-serialize-warn-test></export-serialize-warn-test>

          <template data-component="export-serialize-warn-test">
            <p>Serialize test</p>
          </template>
        `);
          const circularState = { name: "circular" };
          circularState.self = circularState;
          const capture = captureConsole();
          await inflictBoreDOM(circularState, {
            "export-serialize-warn-test": webComponent(() => {
              return ({ state }) => {
                throw new Error("Serialization test error");
              };
            })
          });
          const exported = boreDOM.export("export-serialize-warn-test");
          capture.restore();
          expect(exported).to.not.be.null;
          expect(exported.state).to.be.a("string");
          expect(exported.state).to.include("circular");
          const warnLogs = capture.warns.filter(
            (w) => w[0]?.includes?.("serialize") || w[0]?.includes?.("Unable")
          );
          expect(warnLogs.length).to.be.greaterThan(0);
          clearWindowGlobals();
        });
      });
    });
  }

  // tests/console-api.test.ts
  var import_mocha3 = __toESM(require_mocha());
  async function frame3() {
    return new Promise((resolve) => {
      requestAnimationFrame((t) => resolve(t));
    });
  }
  async function renderHTMLFrame3(html2) {
    const main = document.querySelector("main");
    if (!main) throw new Error("No <main> found!");
    main.innerHTML = html2;
    return new Promise((resolve) => {
      requestAnimationFrame(() => {
        resolve(main);
      });
    });
  }
  function captureConsole2() {
    const logs = [];
    const errors2 = [];
    const infos = [];
    const warns = [];
    const originalLog = console.log;
    const originalError = console.error;
    const originalInfo = console.info;
    const originalWarn = console.warn;
    console.log = (...args) => {
      logs.push(args);
    };
    console.error = (...args) => {
      errors2.push(args);
    };
    console.info = (...args) => {
      infos.push(args);
    };
    console.warn = (...args) => {
      warns.push(args);
    };
    return {
      logs,
      errors: errors2,
      infos,
      warns,
      restore: () => {
        console.log = originalLog;
        console.error = originalError;
        console.info = originalInfo;
        console.warn = originalWarn;
      }
    };
  }
  function clearWindowGlobals2() {
    const w = window;
    delete w.$state;
    delete w.$refs;
    delete w.$slots;
    delete w.$self;
    delete w.$error;
    delete w.$component;
    delete w.$rerender;
  }
  function console_api_test_default() {
    describe("Console API (Phase 2)", () => {
      beforeEach(function() {
        const main = document.querySelector("main");
        if (!main) return;
        main.innerHTML = "";
        setDebugConfig(true);
        clearWindowGlobals2();
        clearGlobals();
        const errorKeys2 = [...boreDOM.errors.keys()];
        for (const tagName of errorKeys2) {
          boreDOM.clearError(tagName);
        }
        boreDOM.clearError();
      });
      afterEach(function() {
        clearWindowGlobals2();
      });
      describe("boreDOM.operate()", () => {
        it("should return component context for a valid component", async () => {
          const container = await renderHTMLFrame3(`
          <operate-test1></operate-test1>

          <template data-component="operate-test1">
            <p data-ref="output">Output</p>
            <slot name="content">Content</slot>
          </template>
        `);
          await inflictBoreDOM({ value: "test-value" }, {
            "operate-test1": webComponent(() => {
              return ({ state, refs }) => {
                if (refs.output instanceof HTMLElement && state) {
                  refs.output.textContent = state.value;
                }
              };
            })
          });
          const ctx = boreDOM.operate("operate-test1");
          expect(ctx).to.not.be.undefined;
          expect(ctx?.state).to.not.be.undefined;
          expect((ctx?.state).value).to.equal("test-value");
          expect(ctx?.refs).to.not.be.undefined;
          expect(ctx?.slots).to.not.be.undefined;
          expect(ctx?.self).to.be.an.instanceof(HTMLElement);
          expect(ctx?.rerender).to.be.a("function");
        });
        it("should allow live state mutation via operate()", async () => {
          const container = await renderHTMLFrame3(`
          <operate-mutate-test></operate-mutate-test>

          <template data-component="operate-mutate-test">
            <p data-ref="output">Initial</p>
          </template>
        `);
          await inflictBoreDOM({ count: 0 }, {
            "operate-mutate-test": webComponent(() => {
              return ({ state, refs }) => {
                if (refs.output instanceof HTMLElement && state) {
                  refs.output.textContent = `Count: ${state.count}`;
                }
              };
            })
          });
          const output = container.querySelector("[data-ref='output']");
          expect(output?.textContent).to.equal("Count: 0");
          const ctx = boreDOM.operate("operate-mutate-test");
          expect(ctx).to.not.be.undefined;
          (ctx?.state).count = 42;
          await frame3();
          expect(output?.textContent).to.equal("Count: 42");
        });
        it("should support index parameter for multiple instances", async () => {
          const container = await renderHTMLFrame3(`
          <operate-multi-test></operate-multi-test>
          <operate-multi-test></operate-multi-test>
          <operate-multi-test></operate-multi-test>

          <template data-component="operate-multi-test">
            <p data-ref="output">Item</p>
          </template>
        `);
          await inflictBoreDOM({ items: ["first", "second", "third"] }, {
            "operate-multi-test": webComponent(() => {
              return ({ state, refs, detail }) => {
                if (refs.output instanceof HTMLElement && state) {
                  refs.output.textContent = state.items[detail?.index ?? 0] || "none";
                }
              };
            })
          });
          const ctx0 = boreDOM.operate("operate-multi-test", 0);
          const ctx1 = boreDOM.operate("operate-multi-test", 1);
          const ctx2 = boreDOM.operate("operate-multi-test", 2);
          expect(ctx0).to.not.be.undefined;
          expect(ctx1).to.not.be.undefined;
          expect(ctx2).to.not.be.undefined;
          expect(ctx0?.self).to.not.equal(ctx1?.self);
          expect(ctx1?.self).to.not.equal(ctx2?.self);
        });
        it("should accept element reference directly", async () => {
          const container = await renderHTMLFrame3(`
          <operate-element-test></operate-element-test>

          <template data-component="operate-element-test">
            <p>Element test</p>
          </template>
        `);
          await inflictBoreDOM({ value: "direct-element" }, {
            "operate-element-test": webComponent(() => {
              return () => {
              };
            })
          });
          const elem = container.querySelector("operate-element-test");
          expect(elem).to.not.be.null;
          const ctx = boreDOM.operate(elem);
          expect(ctx).to.not.be.undefined;
          expect(ctx?.self).to.equal(elem);
          expect((ctx?.state).value).to.equal("direct-element");
        });
        it("should return undefined for non-existent element", async () => {
          await renderHTMLFrame3(`<p>No component here</p>`);
          await inflictBoreDOM();
          const capture = captureConsole2();
          const ctx = boreDOM.operate("non-existent-component");
          capture.restore();
          expect(ctx).to.be.undefined;
          const warnLogs = capture.warns.filter(
            (w) => w[0]?.includes?.("No element found")
          );
          expect(warnLogs.length).to.be.greaterThan(0);
        });
        it("should return undefined when api disabled", async () => {
          const container = await renderHTMLFrame3(`
          <operate-disabled-test></operate-disabled-test>

          <template data-component="operate-disabled-test">
            <p>Disabled test</p>
          </template>
        `);
          await inflictBoreDOM({ value: "test" }, {
            "operate-disabled-test": webComponent(() => {
              return () => {
              };
            })
          }, { debug: { api: false } });
          const ctx = boreDOM.operate("operate-disabled-test");
          expect(ctx).to.be.undefined;
        });
        it("rerender() from context should re-render the component", async () => {
          const container = await renderHTMLFrame3(`
          <operate-rerender-test></operate-rerender-test>

          <template data-component="operate-rerender-test">
            <p data-ref="output">Initial</p>
          </template>
        `);
          let renderCount = 0;
          await inflictBoreDOM({ value: "start" }, {
            "operate-rerender-test": webComponent(() => {
              return ({ state, refs, self: self2 }) => {
                renderCount++;
                self2.setAttribute("data-render-count", String(renderCount));
                if (refs.output instanceof HTMLElement && state) {
                  refs.output.textContent = state.value;
                }
              };
            })
          });
          expect(renderCount).to.equal(1);
          const ctx = boreDOM.operate("operate-rerender-test");
          (ctx?.state).value = "updated";
          ctx?.rerender();
          await frame3();
          expect(renderCount).to.be.at.least(2);
          const output = container.querySelector("[data-ref='output']");
          expect(output?.textContent).to.equal("updated");
        });
      });
      describe("boreDOM.exportComponent()", () => {
        it("should export component state and template", async () => {
          const container = await renderHTMLFrame3(`
          <export-test1></export-test1>

          <template data-component="export-test1">
            <p>Export template content</p>
          </template>
        `);
          await inflictBoreDOM({ count: 42, name: "test" }, {
            "export-test1": webComponent(() => {
              return () => {
              };
            })
          });
          const exported = boreDOM.exportComponent("export-test1");
          expect(exported).to.not.be.null;
          expect(exported?.component).to.equal("export-test1");
          expect(exported?.state).to.deep.include({ count: 42, name: "test" });
          expect(exported?.template).to.include("Export template content");
          expect(exported?.timestamp).to.be.a("string");
        });
        it("should return null for non-existent component", async () => {
          await renderHTMLFrame3(`<p>No component</p>`);
          await inflictBoreDOM();
          const exported = boreDOM.exportComponent("non-existent");
          expect(exported).to.be.null;
        });
        it("should handle circular references gracefully", async () => {
          const container = await renderHTMLFrame3(`
          <export-circular-test></export-circular-test>

          <template data-component="export-circular-test">
            <p>Circular test</p>
          </template>
        `);
          const circularState = { name: "circular" };
          circularState.self = circularState;
          await inflictBoreDOM(circularState, {
            "export-circular-test": webComponent(() => {
              return () => {
              };
            })
          });
          const exported = boreDOM.exportComponent("export-circular-test");
          expect(exported).to.not.be.null;
          expect(exported?.component).to.equal("export-circular-test");
          expect(typeof exported?.state).to.equal("string");
          expect(exported?.state).to.include("circular");
        });
        it("should return null when api disabled", async () => {
          const container = await renderHTMLFrame3(`
          <export-disabled-test></export-disabled-test>

          <template data-component="export-disabled-test">
            <p>Disabled test</p>
          </template>
        `);
          await inflictBoreDOM({ value: "test" }, {
            "export-disabled-test": webComponent(() => {
              return () => {
              };
            })
          }, { debug: { api: false } });
          const exported = boreDOM.exportComponent("export-disabled-test");
          expect(exported).to.be.null;
        });
      });
      describe("boreDOM.define()", () => {
        it("should create a new component at runtime", async () => {
          const container = await renderHTMLFrame3(`
          <main id="define-container"></main>
        `);
          await inflictBoreDOM({ greeting: "Hello Runtime!" });
          const capture = captureConsole2();
          boreDOM.define(
            "runtime-defined-comp",
            `<p data-ref="msg">Loading...</p>`,
            ({ on }) => {
              return ({ state, refs }) => {
                if (refs.msg instanceof HTMLElement && state) {
                  refs.msg.textContent = state.greeting;
                }
              };
            }
          );
          capture.restore();
          const template = document.querySelector('template[data-component="runtime-defined-comp"]');
          expect(template).to.not.be.null;
          const successLogs = capture.logs.filter(
            (l) => l.some((arg) => typeof arg === "string" && arg.includes("runtime-defined-comp"))
          );
          expect(successLogs.length).to.be.greaterThan(0);
        });
        it("should throw for invalid tag name (no hyphen)", async () => {
          await renderHTMLFrame3(`<p>Test</p>`);
          await inflictBoreDOM();
          expect(() => {
            boreDOM.define("invalidtag", "<p>Bad</p>", () => () => {
            });
          }).to.throw(/must contain a hyphen/);
        });
        it("should throw for duplicate tag name", async () => {
          const container = await renderHTMLFrame3(`
          <duplicate-tag-test></duplicate-tag-test>

          <template data-component="duplicate-tag-test">
            <p>Original</p>
          </template>
        `);
          await inflictBoreDOM(void 0, {
            "duplicate-tag-test": webComponent(() => () => {
            })
          });
          expect(() => {
            boreDOM.define("duplicate-tag-test", "<p>Duplicate</p>", () => () => {
            });
          }).to.throw(/already defined/);
        });
        it("should throw before inflictBoreDOM is called", () => {
          expect(() => {
            boreDOM.define("", "<p>Empty tag</p>", () => () => {
            });
          }).to.throw();
        });
        it("should warn when api disabled", async () => {
          await renderHTMLFrame3(`<p>Test</p>`);
          await inflictBoreDOM(void 0, void 0, { debug: { api: false } });
          const capture = captureConsole2();
          boreDOM.define("disabled-api-comp", "<p>Test</p>", () => () => {
          });
          capture.restore();
          const warnLogs = capture.warns.filter(
            (w) => w[0]?.includes?.("disabled") || w[0]?.includes?.("api")
          );
          expect(warnLogs.length).to.be.greaterThan(0);
        });
      });
      describe("Console API integration", () => {
        it("should work together: define, operate, export", async () => {
          const container = await renderHTMLFrame3(`
          <integration-container></integration-container>

          <template data-component="integration-container">
            <div id="inner"></div>
          </template>
        `);
          await inflictBoreDOM({ counter: 100 }, {
            "integration-container": webComponent(() => {
              return () => {
              };
            })
          });
          boreDOM.define(
            "integration-child",
            `<span data-ref="val">0</span>`,
            () => {
              return ({ state, refs }) => {
                if (refs.val instanceof HTMLElement && state) {
                  refs.val.textContent = String(state.counter);
                }
              };
            }
          );
          const parentCtx = boreDOM.operate("integration-container");
          expect(parentCtx).to.not.be.undefined;
          const exported = boreDOM.exportComponent("integration-container");
          expect(exported).to.not.be.null;
          expect(exported?.state).to.deep.include({ counter: 100 });
        });
        it("api option should control all console API features", async () => {
          const container = await renderHTMLFrame3(`
          <api-control-test></api-control-test>

          <template data-component="api-control-test">
            <p>API control test</p>
          </template>
        `);
          setDebugConfig({ api: true });
          expect(isDebugEnabled("api")).to.be.true;
          await inflictBoreDOM({ value: "enabled" }, {
            "api-control-test": webComponent(() => () => {
            })
          });
          let ctx = boreDOM.operate("api-control-test");
          expect(ctx).to.not.be.undefined;
          setDebugConfig({ api: false });
          expect(isDebugEnabled("api")).to.be.false;
          ctx = boreDOM.operate("api-control-test");
          expect(ctx).to.be.undefined;
        });
      });
      describe("Debug configuration for api", () => {
        it("setDebugConfig(true) should enable api", () => {
          setDebugConfig(true);
          expect(isDebugEnabled("api")).to.be.true;
        });
        it("setDebugConfig(false) should disable api", () => {
          setDebugConfig(false);
          expect(isDebugEnabled("api")).to.be.false;
        });
        it("setDebugConfig({ api: true }) should enable api specifically", () => {
          setDebugConfig({ api: true, console: false });
          expect(isDebugEnabled("api")).to.be.true;
          expect(isDebugEnabled("console")).to.be.false;
        });
        it("setDebugConfig({ api: false }) should disable api specifically", () => {
          setDebugConfig({ api: false, console: true });
          expect(isDebugEnabled("api")).to.be.false;
          expect(isDebugEnabled("console")).to.be.true;
        });
      });
      describe("Error handling improvements (code review fixes)", () => {
        it("define() should return true on success", async () => {
          await renderHTMLFrame3(`<p>Test</p>`);
          await inflictBoreDOM({ value: "test" });
          const result = boreDOM.define(
            "define-return-test",
            "<p>Test</p>",
            () => () => {
            }
          );
          expect(result).to.equal(true);
        });
        it("define() should return false when api disabled", async () => {
          await renderHTMLFrame3(`<p>Test</p>`);
          await inflictBoreDOM(void 0, void 0, { debug: { api: false } });
          const capture = captureConsole2();
          const result = boreDOM.define(
            "define-disabled-return",
            "<p>Test</p>",
            () => () => {
            }
          );
          capture.restore();
          expect(result).to.equal(false);
          const warnLogs = capture.warns.filter(
            (w) => w[0]?.includes?.("disabled") || w[0]?.includes?.("api")
          );
          expect(warnLogs.length).to.be.greaterThan(0);
        });
        it("operate() should warn when api disabled", async () => {
          const container = await renderHTMLFrame3(`
          <operate-warn-test></operate-warn-test>

          <template data-component="operate-warn-test">
            <p>Warn test</p>
          </template>
        `);
          await inflictBoreDOM({ value: "test" }, {
            "operate-warn-test": webComponent(() => () => {
            })
          }, { debug: { api: false } });
          const capture = captureConsole2();
          const ctx = boreDOM.operate("operate-warn-test");
          capture.restore();
          expect(ctx).to.be.undefined;
          const warnLogs = capture.warns.filter(
            (w) => w[0]?.includes?.("disabled") || w[0]?.includes?.("api")
          );
          expect(warnLogs.length).to.be.greaterThan(0);
        });
        it("exportComponent() should warn when api disabled", async () => {
          const container = await renderHTMLFrame3(`
          <export-warn-test></export-warn-test>

          <template data-component="export-warn-test">
            <p>Export warn test</p>
          </template>
        `);
          await inflictBoreDOM({ value: "test" }, {
            "export-warn-test": webComponent(() => () => {
            })
          }, { debug: { api: false } });
          const capture = captureConsole2();
          const exported = boreDOM.exportComponent("export-warn-test");
          capture.restore();
          expect(exported).to.be.null;
          const warnLogs = capture.warns.filter(
            (w) => w[0]?.includes?.("disabled") || w[0]?.includes?.("api")
          );
          expect(warnLogs.length).to.be.greaterThan(0);
        });
        it("exportComponent() should warn when serialization fails", async () => {
          const container = await renderHTMLFrame3(`
          <export-serialize-warn></export-serialize-warn>

          <template data-component="export-serialize-warn">
            <p>Serialize warn test</p>
          </template>
        `);
          const circularState = { name: "circular" };
          circularState.self = circularState;
          await inflictBoreDOM(circularState, {
            "export-serialize-warn": webComponent(() => () => {
            })
          });
          const capture = captureConsole2();
          const exported = boreDOM.exportComponent("export-serialize-warn");
          capture.restore();
          expect(exported).to.not.be.null;
          const warnLogs = capture.warns.filter(
            (w) => w[0]?.includes?.("serialize") || w[0]?.includes?.("Unable")
          );
          expect(warnLogs.length).to.be.greaterThan(0);
        });
        it("clearError() should warn when component not found", async () => {
          await renderHTMLFrame3(`<p>Test</p>`);
          await inflictBoreDOM();
          const capture = captureConsole2();
          boreDOM.clearError("non-existent-component");
          capture.restore();
          const warnLogs = capture.warns.filter(
            (w) => w[0]?.includes?.("No error found") || w[0]?.includes?.("clearError")
          );
          expect(warnLogs.length).to.be.greaterThan(0);
        });
        it("clearError() should warn when no error to clear", async () => {
          await renderHTMLFrame3(`<p>Test</p>`);
          await inflictBoreDOM();
          const errorKeys2 = [...boreDOM.errors.keys()];
          for (const tagName of errorKeys2) {
            boreDOM.errors.delete(tagName);
          }
          const capture = captureConsole2();
          boreDOM.clearError();
          capture.restore();
          const warnLogs = capture.warns.filter(
            (w) => w[0]?.includes?.("No error") || w[0]?.includes?.("clearError")
          );
          expect(warnLogs.length).to.be.greaterThan(0);
        });
      });
    });
  }

  // tests/inside-out.test.ts
  var import_mocha4 = __toESM(require_mocha());
  async function renderHTMLFrame4(html2) {
    const main = document.querySelector("main");
    if (!main) throw new Error("No <main> found!");
    main.innerHTML = html2;
    return new Promise((resolve) => {
      requestAnimationFrame(() => {
        resolve(main);
      });
    });
  }
  function captureConsole3() {
    const logs = [];
    const errors2 = [];
    const infos = [];
    const warns = [];
    const originalLog = console.log;
    const originalError = console.error;
    const originalInfo = console.info;
    const originalWarn = console.warn;
    console.log = (...args) => {
      logs.push(args);
    };
    console.error = (...args) => {
      errors2.push(args);
    };
    console.info = (...args) => {
      infos.push(args);
    };
    console.warn = (...args) => {
      warns.push(args);
    };
    return {
      logs,
      errors: errors2,
      infos,
      warns,
      restore: () => {
        console.log = originalLog;
        console.error = originalError;
        console.info = originalInfo;
        console.warn = originalWarn;
      }
    };
  }
  function clearWindowGlobals3() {
    const w = window;
    delete w.$state;
    delete w.$refs;
    delete w.$slots;
    delete w.$self;
    delete w.$error;
    delete w.$component;
    delete w.$rerender;
    delete w.$missingName;
    delete w.$missingArgs;
    delete w.$missingComponent;
    delete w.$defineMissing;
  }
  function inside_out_test_default() {
    describe("Inside-Out Primitives (Phase 3)", () => {
      beforeEach(function() {
        const main = document.querySelector("main");
        if (!main) return;
        main.innerHTML = "";
        setDebugConfig(true);
        clearWindowGlobals3();
        clearGlobals();
        clearMissingGlobals();
        for (const name of boreDOM.helpers.keys()) {
          clearHelper(name);
        }
      });
      afterEach(function() {
        clearWindowGlobals3();
        clearMissingGlobals();
        stopObservingUndefinedElements();
      });
      describe("createRenderHelpers()", () => {
        it("should return empty object when methodMissing is disabled", () => {
          setDebugConfig({ methodMissing: false });
          const helpers = createRenderHelpers(
            "test-component",
            document.createElement("div"),
            () => {
            }
          );
          expect(Object.keys(helpers)).to.have.length(0);
        });
        it("should return a proxy when methodMissing is enabled", () => {
          const helpers = createRenderHelpers(
            "test-component",
            document.createElement("div"),
            () => {
            }
          );
          expect(typeof helpers).to.equal("object");
        });
        it("should intercept undefined function calls", () => {
          const capture = captureConsole3();
          const helpers = createRenderHelpers(
            "test-component",
            document.createElement("div"),
            () => {
            }
          );
          const result = helpers.undefinedFunction("arg1", 42);
          capture.restore();
          expect(result).to.be.undefined;
          const missingLog = capture.logs.find(
            (log) => log.some((arg) => typeof arg === "string" && arg.includes("Missing function"))
          );
          expect(missingLog).to.not.be.undefined;
        });
        it("should expose $missingName global when undefined function called", () => {
          const helpers = createRenderHelpers(
            "test-component",
            document.createElement("div"),
            () => {
            }
          );
          helpers.myMissingFunc("test");
          expect(window.$missingName).to.equal("myMissingFunc");
        });
        it("should expose $missingArgs global with function arguments", () => {
          const helpers = createRenderHelpers(
            "test-component",
            document.createElement("div"),
            () => {
            }
          );
          helpers.anotherMissing({ user: "test" }, 123);
          expect(window.$missingArgs).to.deep.equal([{ user: "test" }, 123]);
        });
        it("should expose $missingComponent global", () => {
          const helpers = createRenderHelpers(
            "my-cool-component",
            document.createElement("div"),
            () => {
            }
          );
          helpers.someFn();
          expect(window.$missingComponent).to.equal("my-cool-component");
        });
        it("should expose $defineMissing function for live definition", () => {
          let rerenderCalled = false;
          const helpers = createRenderHelpers(
            "test-component",
            document.createElement("div"),
            () => {
              rerenderCalled = true;
            }
          );
          helpers.toDefine();
          expect(typeof window.$defineMissing).to.equal("function");
          window.$defineMissing((x) => x * 2);
          expect(rerenderCalled).to.be.true;
        });
      });
      describe("defineHelper()", () => {
        it("should make helper available to all render functions", () => {
          defineHelper("formatCurrency", (n) => `$${n.toFixed(2)}`);
          const helpers = createRenderHelpers(
            "test-component",
            document.createElement("div"),
            () => {
            }
          );
          const result = helpers.formatCurrency(19.99);
          expect(result).to.equal("$19.99");
        });
        it("should be accessible via boreDOM.helpers", () => {
          defineHelper("testHelper", () => "test");
          expect(boreDOM.helpers.has("testHelper")).to.be.true;
          expect(boreDOM.helpers.get("testHelper")?.()).to.equal("test");
        });
        it("should log success message", () => {
          const capture = captureConsole3();
          defineHelper("loggedHelper", () => {
          });
          capture.restore();
          const successLog = capture.logs.find(
            (log) => log.some((arg) => typeof arg === "string" && arg.includes("Defined helper"))
          );
          expect(successLog).to.not.be.undefined;
        });
      });
      describe("clearHelper()", () => {
        it("should remove a defined helper", () => {
          defineHelper("toRemove", () => "original");
          expect(boreDOM.helpers.has("toRemove")).to.be.true;
          clearHelper("toRemove");
          expect(boreDOM.helpers.has("toRemove")).to.be.false;
        });
        it("should make helper unavailable after clearing", () => {
          defineHelper("tempHelper", () => "temp");
          clearHelper("tempHelper");
          const capture = captureConsole3();
          const helpers = createRenderHelpers(
            "test-component",
            document.createElement("div"),
            () => {
            }
          );
          helpers.tempHelper();
          capture.restore();
          expect(window.$missingName).to.equal("tempHelper");
        });
      });
      describe("boreDOM.missingFunctions", () => {
        it("should track missing function calls", () => {
          const helpers = createRenderHelpers(
            "tracking-component",
            document.createElement("div"),
            () => {
            }
          );
          helpers.trackedMissing("test");
          expect(boreDOM.missingFunctions.has("trackedMissing")).to.be.true;
          const calls = boreDOM.missingFunctions.get("trackedMissing");
          expect(calls).to.have.length.greaterThan(0);
          expect(calls?.[0].args).to.deep.equal(["test"]);
        });
        it("should track boreDOM.lastMissing", () => {
          const helpers = createRenderHelpers(
            "last-missing-component",
            document.createElement("div"),
            () => {
            }
          );
          helpers.lastMissingTest({ data: "value" });
          expect(boreDOM.lastMissing).to.not.be.null;
          expect(boreDOM.lastMissing?.name).to.equal("lastMissingTest");
          expect(boreDOM.lastMissing?.component).to.equal("last-missing-component");
        });
      });
      describe("inferTemplate()", () => {
        it("should return null when templateInference is disabled", () => {
          setDebugConfig({ templateInference: false });
          const result = inferTemplate("test-component");
          expect(result).to.be.null;
        });
        it("should return null when strict mode is enabled", () => {
          setDebugConfig({ strict: true });
          const result = inferTemplate("test-component");
          expect(result).to.be.null;
        });
        it("should infer props from element attributes", () => {
          const element = document.createElement("div");
          element.setAttribute("user-id", "123");
          element.setAttribute("show-avatar", "true");
          const result = inferTemplate("test-component", element);
          expect(result).to.not.be.null;
          expect(result?.props).to.have.property("userId", 123);
          expect(result?.props).to.have.property("showAvatar", true);
        });
        it("should convert kebab-case attributes to camelCase props", () => {
          const element = document.createElement("div");
          element.setAttribute("first-name", "John");
          element.setAttribute("last-name", "Doe");
          element.setAttribute("is-active", "true");
          const result = inferTemplate("test-component", element);
          expect(result?.props).to.have.property("firstName", "John");
          expect(result?.props).to.have.property("lastName", "Doe");
          expect(result?.props).to.have.property("isActive", true);
        });
        it("should parse numeric attributes as numbers", () => {
          const element = document.createElement("div");
          element.setAttribute("count", "42");
          element.setAttribute("price", "19.99");
          const result = inferTemplate("test-component", element);
          expect(result?.props).to.have.property("count", 42);
          expect(result?.props).to.have.property("price", 19.99);
        });
        it("should parse boolean attributes correctly", () => {
          const element = document.createElement("div");
          element.setAttribute("enabled", "true");
          element.setAttribute("disabled", "false");
          const result = inferTemplate("test-component", element);
          expect(result?.props).to.have.property("enabled", true);
          expect(result?.props).to.have.property("disabled", false);
        });
        it("should skip data-* attributes", () => {
          const element = document.createElement("div");
          element.setAttribute("data-id", "should-skip");
          element.setAttribute("real-attr", "should-include");
          const result = inferTemplate("test-component", element);
          expect(result?.props).to.not.have.property("dataId");
          expect(result?.props).to.not.have.property("id");
          expect(result?.props).to.have.property("realAttr", "should-include");
        });
        it("should skip class, id, and style attributes", () => {
          const element = document.createElement("div");
          element.setAttribute("class", "my-class");
          element.setAttribute("id", "my-id");
          element.setAttribute("style", "color: red");
          element.setAttribute("valid-attr", "value");
          const result = inferTemplate("test-component", element);
          expect(result?.props).to.not.have.property("class");
          expect(result?.props).to.not.have.property("id");
          expect(result?.props).to.not.have.property("style");
          expect(result?.props).to.have.property("validAttr", "value");
        });
        it("should generate a template string", () => {
          const element = document.createElement("div");
          element.setAttribute("name", "Test");
          const result = inferTemplate("my-component", element);
          expect(result?.template).to.be.a("string");
          expect(result?.template).to.include("my-component-skeleton");
          expect(result?.template).to.include("data-inferred");
        });
        it("should infer slots from children with slot attribute", () => {
          const element = document.createElement("div");
          const child1 = document.createElement("span");
          child1.setAttribute("slot", "header");
          const child2 = document.createElement("div");
          child2.setAttribute("slot", "content");
          element.appendChild(child1);
          element.appendChild(child2);
          const result = inferTemplate("test-component", element);
          expect(result?.slots).to.include("header");
          expect(result?.slots).to.include("content");
        });
      });
      describe("boreDOM.inferredTemplates", () => {
        it("should be accessible via boreDOM API", () => {
          expect(boreDOM.inferredTemplates).to.be.an.instanceof(Map);
        });
      });
      describe("helpers in webComponent render", () => {
        it("should provide helpers to render function", async () => {
          await renderHTMLFrame4(`
          <helpers-test1></helpers-test1>

          <template data-component="helpers-test1">
            <p data-ref="output">Output</p>
          </template>
        `);
          let helpersReceived = false;
          await inflictBoreDOM({ value: "test" }, {
            "helpers-test1": webComponent(({ state }) => {
              return ({ refs, helpers }) => {
                helpersReceived = helpers !== void 0 && typeof helpers === "object";
                if (refs.output instanceof HTMLElement && state) {
                  refs.output.textContent = state.value;
                }
              };
            })
          });
          expect(helpersReceived).to.be.true;
        });
        it("should allow using defined helpers in render", async () => {
          defineHelper("greet", (name) => `Hello, ${name}!`);
          const container = await renderHTMLFrame4(`
          <helpers-test2></helpers-test2>

          <template data-component="helpers-test2">
            <p data-ref="output">Output</p>
          </template>
        `);
          await inflictBoreDOM({ name: "World" }, {
            "helpers-test2": webComponent(({ state }) => {
              return ({ refs, helpers }) => {
                if (refs.output instanceof HTMLElement && state) {
                  refs.output.textContent = helpers.greet(state.name);
                }
              };
            })
          });
          const output = container.querySelector('[data-ref="output"]');
          expect(output?.textContent).to.equal("Hello, World!");
        });
        it("should log missing function when undefined helper called in render", async () => {
          const capture = captureConsole3();
          await renderHTMLFrame4(`
          <helpers-test3></helpers-test3>

          <template data-component="helpers-test3">
            <p data-ref="output">Output</p>
          </template>
        `);
          await inflictBoreDOM({ value: "test" }, {
            "helpers-test3": webComponent(({ state }) => {
              return ({ refs, helpers }) => {
                const result = helpers.undefinedHelper(state?.value);
                if (refs.output instanceof HTMLElement) {
                  refs.output.textContent = result ?? "No result";
                }
              };
            })
          });
          capture.restore();
          const missingLog = capture.logs.find(
            (log) => log.some((arg) => typeof arg === "string" && arg.includes("Missing function"))
          );
          expect(missingLog).to.not.be.undefined;
          expect(window.$missingName).to.equal("undefinedHelper");
        });
      });
      describe("Configuration", () => {
        it("should respect methodMissing: false config", () => {
          setDebugConfig({ methodMissing: false });
          expect(isDebugEnabled("methodMissing")).to.be.false;
          const helpers = createRenderHelpers(
            "test-component",
            document.createElement("div"),
            () => {
            }
          );
          expect(Object.keys(helpers)).to.have.length(0);
        });
        it("should respect templateInference: false config", () => {
          setDebugConfig({ templateInference: false });
          expect(isDebugEnabled("templateInference")).to.be.false;
          const result = inferTemplate("test-component");
          expect(result).to.be.null;
        });
        it("should respect strict: true config", () => {
          setDebugConfig({ strict: true });
          expect(isDebugEnabled("strict")).to.be.true;
          const result = inferTemplate("test-component");
          expect(result).to.be.null;
        });
        it("should have methodMissing, templateInference, strict in config", () => {
          const config3 = boreDOM.config;
          expect(config3).to.have.property("methodMissing");
          expect(config3).to.have.property("templateInference");
          expect(config3).to.have.property("strict");
        });
      });
    });
  }

  // tests/llm.test.ts
  var import_mocha5 = __toESM(require_mocha());
  async function frame4() {
    return new Promise((resolve) => {
      requestAnimationFrame((t) => resolve(t));
    });
  }
  async function renderHTMLFrame5(html2) {
    const main = document.querySelector("main");
    if (!main) throw new Error("No <main> found!");
    main.innerHTML = html2;
    return new Promise((resolve) => {
      requestAnimationFrame(() => {
        resolve(main);
      });
    });
  }
  function llm_test_default() {
    describe("LLM Integration API (Micro-Symbiotic)", () => {
      beforeEach(function() {
        const main = document.querySelector("main");
        if (!main) return;
        main.innerHTML = "";
        setDebugConfig(true);
        clearGlobals();
      });
      describe("boreDOM.llm.vision()", () => {
        it("should capture semantic structure", async () => {
          await renderHTMLFrame5(`
          <div id="test-root">
            <h1 class="title">Hello</h1>
            <input type="text" value="World" id="inp">
            <div hidden>Secret</div>
            <span style="display: none">Hidden</span>
            <button data-action="submit">Send</button>
          </div>
        `);
          const root = document.getElementById("test-root");
          expect(root).to.not.be.null;
          const semantic = boreDOM.llm.vision(root);
          expect(semantic).to.not.be.null;
          expect(semantic?.tagName).to.equal("div");
          expect(semantic?.attributes?.id).to.equal("test-root");
          const children = semantic?.children || [];
          expect(children).to.have.length(3);
          const h1 = children[0];
          expect(h1.tagName).to.equal("h1");
          expect(h1.attributes?.class).to.equal("title");
          expect(h1.text).to.equal("Hello");
          const inp = children[1];
          expect(inp.tagName).to.equal("input");
          expect(inp.attributes?.value).to.equal("World");
          const btn = children[2];
          expect(btn.tagName).to.equal("button");
          expect(btn.attributes["data-action"]).to.equal("submit");
          expect(btn.text).to.equal("Send");
        });
      });
      describe("boreDOM.llm.transact()", () => {
        it("should replace state values and trigger reactivity", async () => {
          await renderHTMLFrame5(`
          <transact-test></transact-test>
          <template data-component="transact-test">
            <p data-ref="out"></p>
          </template>
        `);
          const appState = await inflictBoreDOM({ count: 10 }, {
            "transact-test": webComponent(() => ({ state, refs }) => {
              if (refs.out) refs.out.textContent = String(state?.count);
            })
          });
          const el = document.querySelector("transact-test p");
          expect(el?.textContent).to.equal("10");
          const result = boreDOM.llm.transact([
            { op: "replace", path: "/count", value: 42 }
          ]);
          expect(result.success).to.be.true;
          expect(appState?.count).to.equal(42);
          await frame4();
          await frame4();
          expect(el?.textContent).to.equal("42");
        });
        it("should handle array operations", async () => {
          await inflictBoreDOM({ items: ["a", "b"] });
          boreDOM.llm.transact([
            { op: "add", path: "/items/-", value: "c" }
          ]);
          const state = boreDOM.exportComponent("transact-test")?.state || window.boreDOM.lastError?.state || boreDOM._setDebugConfig ? boreDOM._testState : null;
        });
        it("should return error on invalid path", async () => {
          await inflictBoreDOM({ foo: 1 });
          const result = boreDOM.llm.transact([
            { op: "replace", path: "/invalid/path", value: 2 }
          ]);
          expect(result.success).to.be.false;
          expect(result.error).to.include("not found");
        });
      });
      describe("boreDOM.llm.compact()", () => {
        it("should return a compact summary of state and components", async () => {
          await renderHTMLFrame5(`
          <compact-test></compact-test>
          <template data-component="compact-test">
            <p data-ref="out"></p>
          </template>
        `);
          await inflictBoreDOM(
            { count: 1, items: ["a", "b"] },
            {
              "compact-test": webComponent(() => () => {
              })
            }
          );
          const compact = boreDOM.llm.compact();
          expect(compact).to.not.be.null;
          expect(compact?.framework?.name).to.equal("boreDOM");
          expect(compact?.state?.paths).to.include("count");
          expect(compact?.components?.some((c) => c.tag === "compact-test")).to.equal(true);
        });
      });
    });
  }

  // tests/patch-concurrency.test.ts
  init_patch();
  function patch_concurrency_test_default() {
    describe("Patch Concurrency & Atomicity", () => {
      it("should pass 'test' operation when values match", () => {
        const state = { count: 1, ver: 10 };
        const patch = [
          { op: "test", path: "/ver", value: 10 },
          { op: "replace", path: "/count", value: 2 }
        ];
        const result = applyPatch(state, patch);
        expect(result.success).to.be.true;
        expect(state.count).to.equal(2);
      });
      it("should fail transaction when 'test' fails", () => {
        const state = { count: 1, ver: 10 };
        const patch = [
          { op: "test", path: "/ver", value: 99 },
          // Mismatch
          { op: "replace", path: "/count", value: 2 }
        ];
        const result = applyPatch(state, patch);
        expect(result.success).to.be.false;
        expect(result.error).to.include("Test failed");
        expect(state.count).to.equal(1);
      });
      it("should rollback previous changes if a later 'test' fails (Atomicity)", () => {
        const state = { count: 1, ver: 10, list: [1, 2] };
        const patch = [
          { op: "replace", path: "/count", value: 50 },
          // Applied first
          { op: "add", path: "/list/-", value: 3 },
          // Applied second
          { op: "test", path: "/ver", value: 999 }
          // Fails
        ];
        const result = applyPatch(state, patch);
        expect(result.success).to.be.false;
        expect(state.count).to.equal(1);
        expect(state.list).to.deep.equal([1, 2]);
      });
      it("should handle nested object equality in test", () => {
        const state = { config: { theme: "dark", admin: true } };
        const patch = [
          { op: "test", path: "/config", value: { theme: "dark", admin: true } },
          { op: "replace", path: "/config/theme", value: "light" }
        ];
        const result = applyPatch(state, patch);
        expect(result.success).to.be.true;
        expect(state.config.theme).to.equal("light");
      });
      it("should fail test on deep object mismatch", () => {
        const state = { config: { theme: "dark", admin: true } };
        const patch = [
          { op: "test", path: "/config", value: { theme: "dark", admin: false } },
          { op: "replace", path: "/config/theme", value: "light" }
        ];
        const result = applyPatch(state, patch);
        expect(result.success).to.be.false;
        expect(state.config.theme).to.equal("dark");
      });
      it("should rollback array splice operations correctly", () => {
        const state = { items: ["a", "b", "c"] };
        const patch = [
          { op: "remove", path: "/items/1" },
          { op: "test", path: "/items/0", value: "z" }
          // Fail
        ];
        const result = applyPatch(state, patch);
        expect(result.success).to.be.false;
        expect(state.items).to.deep.equal(["a", "b", "c"]);
      });
      it("should rollback array insert operations correctly", () => {
        const state = { items: ["a", "c"] };
        const patch = [
          { op: "add", path: "/items/1", value: "b" },
          { op: "test", path: "/items/0", value: "z" }
          // Fail
        ];
        const result = applyPatch(state, patch);
        expect(result.success).to.be.false;
        expect(state.items).to.deep.equal(["a", "c"]);
      });
      it("should rollback object property addition", () => {
        const state = { a: 1 };
        const patch = [
          { op: "add", path: "/b", value: 2 },
          { op: "test", path: "/a", value: 99 }
        ];
        const result = applyPatch(state, patch);
        expect(result.success).to.be.false;
        expect(state.b).to.be.undefined;
        expect("b" in state).to.be.false;
      });
    });
  }

  // tests/inline-logic.test.ts
  function inlineLogicTests() {
    describe("Inline Logic Components", () => {
      let container;
      beforeEach(() => {
        container = document.createElement("div");
        document.body.appendChild(container);
      });
      afterEach(() => {
        document.body.removeChild(container);
      });
      it("should load component logic from <script> inside <template>", async () => {
        const tagName = "inline-counter";
        const template = document.createElement("template");
        template.setAttribute("data-component", tagName);
        template.innerHTML = `
        <div class="count">Count: <slot name="value">0</slot></div>
        <button onclick="dispatch('inc')">+</button>
        
        <script type="module">
          // Standard boreDOM component definition
          export default ({ on }) => {
            on("inc", ({ state }) => {
              state.count++;
            });
            
            return ({ state, slots }) => {
              slots.value = String(state.count);
            };
          };
        <\/script>
      `;
        document.body.appendChild(template);
        const instance = document.createElement(tagName);
        container.appendChild(instance);
        const state = await inflictBoreDOM(
          { count: 10 },
          // No explicit componentsLogic passed - it should find it in the template!
          void 0,
          { debug: false }
        );
        await new Promise((r) => setTimeout(r, 50));
        const countDisplay = instance.querySelector(".count");
        expect(countDisplay).to.not.be.null;
        expect(countDisplay?.textContent).to.contain("Count: 10");
        const btn = instance.querySelector("button");
        btn?.click();
        await new Promise((r) => setTimeout(r, 50));
        expect(countDisplay?.textContent).to.contain("Count: 11");
        expect(state?.count).to.equal(11);
      });
      it("should handle multiple inline components", async () => {
        const tag1 = "inline-one";
        const tag2 = "inline-two";
        const t1 = document.createElement("template");
        t1.setAttribute("data-component", tag1);
        t1.innerHTML = `
        <span>One</span>
        <script type="module">
          export default () => ({ slots }) => { slots.default = "One rendered"; };
        <\/script>
      `;
        document.body.appendChild(t1);
        const t2 = document.createElement("template");
        t2.setAttribute("data-component", tag2);
        t2.innerHTML = `
        <span>Two</span>
        <script type="module">
          export default () => ({ slots }) => { slots.default = "Two rendered"; };
        <\/script>
      `;
        document.body.appendChild(t2);
        const el1 = document.createElement(tag1);
        const el2 = document.createElement(tag2);
        container.appendChild(el1);
        container.appendChild(el2);
        await inflictBoreDOM({}, void 0, { debug: false });
        await new Promise((r) => setTimeout(r, 50));
        expect(el1.textContent).to.contain("One");
        expect(el2.textContent).to.contain("Two");
      });
      it("should auto-wrap raw init functions", async () => {
        const tagName = "auto-wrap-test";
        const template = document.createElement("template");
        template.setAttribute("data-component", tagName);
        template.innerHTML = `
         <span>Result: <slot name="val"></slot></span>
         <script type="module">
           // This is NOT wrapped in webComponent(), but just the init function
           export default ({ state }) => {
              return ({ slots }) => {
                slots.val = state.val;
              }
           }
         <\/script>
       `;
        document.body.appendChild(template);
        const el = document.createElement(tagName);
        container.appendChild(el);
        await inflictBoreDOM({ val: "worked" });
        await new Promise((r) => setTimeout(r, 50));
        expect(el.textContent).to.contain("Result: worked");
      });
    });
  }

  // tests/dispatch-index.test.ts
  async function frame5() {
    return new Promise((resolve) => {
      requestAnimationFrame((t) => resolve(t));
    });
  }
  function renderHTML2(html2) {
    const main = document.querySelector("main");
    if (!main) throw new Error("No <main> found!");
    main.innerHTML = html2;
    return main;
  }
  function dispatchIndexTests() {
    describe("Dispatch & Indexing", () => {
      beforeEach(() => {
        const main = document.querySelector("main");
        if (main) main.innerHTML = "";
      });
      it("should update state via direct ref onclick (Singular Approach)", async () => {
        renderHTML2(`
        <ref-comp></ref-comp>
        <template data-component="ref-comp">
          <button data-ref="btn">Click</button>
          <span data-ref="out"></span>
          <script type="module">
            export default ({ refs, state }) => {
              refs.btn.onclick = () => state.val = 'ok';
              return ({ state, refs }) => {
                refs.out.textContent = state.val;
              };
            }
          <\/script>
        </template>
      `);
        const state = await inflictBoreDOM({ val: "init" });
        const btn = document.querySelector("button");
        if (!btn) throw new Error("Button not found");
        fireEvent.click(btn);
        await frame5();
        const out = document.querySelector('[data-ref="out"]');
        expect(out?.textContent).to.equal("ok");
      });
      it("should provide the correct index in dispatch handlers (List Approach)", async () => {
        renderHTML2(`
        <list-comp></list-comp>
        <template data-component="list-comp">
          <div data-ref="container"></div>
          <script type="module">
            export default ({ on, state, makeComponent, refs }) => {
              on('hit', ({ e }) => {
                state.lastIndex = e.index;
              });
              return ({ state, refs }) => {
                refs.container.innerHTML = '';
                [0, 1, 2].forEach(() => {
                  refs.container.appendChild(makeComponent('item-btn'));
                });
              };
            }
          <\/script>
        </template>
        <template data-component="item-btn">
          <button onclick="dispatch('hit')">Hit</button>
        </template>
      `);
        const state = await inflictBoreDOM({ lastIndex: -1 });
        await frame5();
        const buttons = document.querySelectorAll("button");
        expect(buttons.length).to.equal(3);
        fireEvent.click(buttons[1]);
        await frame5();
        expect(state.lastIndex).to.equal(1);
      });
    });
  }

  // tests/bindings.test.ts
  var import_mocha6 = __toESM(require_mocha());
  async function frame6() {
    return new Promise((resolve) => {
      requestAnimationFrame((t) => resolve(t));
    });
  }
  async function renderHTMLFrame6(html2) {
    const main = document.querySelector("main");
    if (!main) throw new Error("No <main> found!");
    main.innerHTML = html2;
    return new Promise((resolve) => {
      requestAnimationFrame(() => resolve(main));
    });
  }
  function bindings_test_default() {
    describe("Bindings", () => {
      beforeEach(() => {
        const main = document.querySelector("main");
        if (main) main.innerHTML = "";
        setDebugConfig(true);
      });
      it("applies data-text, data-show, data-class, data-value, data-checked", async () => {
        await renderHTMLFrame6(`
        <binding-test></binding-test>
        <template data-component="binding-test">
          <p data-ref="text" data-text="state.message"></p>
          <div data-ref="visible" data-show="state.visible"></div>
          <span class="base" data-ref="toggle" data-class="active:state.active"></span>
          <input data-ref="input" data-value="state.input">
          <input type="checkbox" data-ref="check" data-checked="state.checked">
        </template>
      `);
        const state = await inflictBoreDOM(
          {
            message: "Hello",
            visible: true,
            active: true,
            input: "test",
            checked: true
          },
          {
            "binding-test": webComponent(() => () => {
            })
          }
        );
        const text = document.querySelector("[data-ref='text']");
        const visible = document.querySelector("[data-ref='visible']");
        const toggle = document.querySelector("[data-ref='toggle']");
        const input = document.querySelector("[data-ref='input']");
        const check = document.querySelector("[data-ref='check']");
        expect(text.textContent).to.equal("Hello");
        expect(visible.hidden).to.equal(false);
        expect(toggle.classList.contains("active")).to.equal(true);
        expect(input.value).to.equal("test");
        expect(check.checked).to.equal(true);
        state.message = "World";
        state.visible = false;
        state.active = false;
        state.input = "next";
        state.checked = false;
        await frame6();
        await frame6();
        expect(text.textContent).to.equal("World");
        expect(visible.hidden).to.equal(true);
        expect(toggle.classList.contains("active")).to.equal(false);
        expect(input.value).to.equal("next");
        expect(check.checked).to.equal(false);
      });
      it("renders lists with data-list and data-item templates", async () => {
        await renderHTMLFrame6(`
        <list-test></list-test>
        <template data-component="list-test">
          <ul data-list="state.items">
            <template data-item>
              <li>
                <span data-text="item.label"></span>
                <span data-text="index"></span>
              </li>
            </template>
          </ul>
        </template>
      `);
        const state = await inflictBoreDOM(
          { items: [{ label: "A" }, { label: "B" }] },
          { "list-test": webComponent(() => () => {
          }) }
        );
        await frame6();
        await frame6();
        const items = document.querySelectorAll("list-test li");
        expect(items.length).to.equal(2);
        expect(items[0].textContent).to.include("A");
        expect(items[1].textContent).to.include("B");
        state.items.push({ label: "C" });
        await frame6();
        await frame6();
        const updated = document.querySelectorAll("list-test li");
        expect(updated.length).to.equal(3);
        expect(updated[2].textContent).to.include("C");
      });
      it("updates data-prop bindings and rerenders child components", async () => {
        await renderHTMLFrame6(`
        <parent-comp></parent-comp>
        <template data-component="parent-comp">
          <child-comp data-prop-user-id="state.selectedId"></child-comp>
        </template>
        <template data-component="child-comp">
          <span data-ref="out"></span>
        </template>
      `);
        const state = await inflictBoreDOM(
          { selectedId: 1 },
          {
            "parent-comp": webComponent(() => () => {
            }),
            "child-comp": webComponent(() => ({ refs, detail }) => {
              refs.out.textContent = String(detail?.data?.userId ?? "");
            })
          }
        );
        const output = document.querySelector("child-comp span");
        expect(output.textContent).to.equal("1");
        state.selectedId = 2;
        await frame6();
        await frame6();
        expect(output.textContent).to.equal("2");
      });
      it("supports data-dispatch and on- attributes for events", async () => {
        await renderHTMLFrame6(`
        <event-test></event-test>
        <template data-component="event-test">
          <button data-dispatch="hit" data-ref="hit"></button>
          <button on-click="tap" data-ref="tap"></button>
        </template>
      `);
        const state = await inflictBoreDOM(
          { hits: 0, taps: 0 },
          {
            "event-test": webComponent(({ on }) => {
              on("hit", ({ state: state2 }) => {
                state2.hits += 1;
              });
              on("tap", ({ state: state2 }) => {
                state2.taps += 1;
              });
              return () => {
              };
            })
          }
        );
        const hit = document.querySelector("[data-ref='hit']");
        const tap = document.querySelector("[data-ref='tap']");
        fireEvent.click(hit);
        fireEvent.click(tap);
        await frame6();
        await frame6();
        expect(state.hits).to.equal(1);
        expect(state.taps).to.equal(1);
      });
      it("creates templates via component() helper", async () => {
        const Helper = component2(
          "component-helper",
          `<p data-text="state.message"></p>`,
          () => () => {
          }
        );
        await renderHTMLFrame6(`<component-helper></component-helper>`);
        await inflictBoreDOM(
          { message: "Inline" },
          { "component-helper": Helper },
          { singleFile: true }
        );
        await frame6();
        await frame6();
        const output = document.querySelector("component-helper p");
        expect(output.textContent).to.equal("Inline");
      });
    });
  }

  // tests/runner.ts
  mocha.setup("bdd");
  mocha.globals([
    "$missingName",
    "$missingArgs",
    "$missingComponent",
    "$defineMissing"
  ]);
  dom_test_default();
  debug_test_default();
  console_api_test_default();
  inside_out_test_default();
  llm_test_default();
  patch_concurrency_test_default();
  inlineLogicTests();
  dispatchIndexTests();
  bindings_test_default();
  mocha.checkLeaks();
  var results = {
    stats: {},
    passes: [],
    failures: [],
    pending: [],
    startedAt: Date.now(),
    endedAt: 0
  };
  var runner = mocha.run();
  runner.on("pass", (test2) => {
    results.passes.push({
      title: test2.title,
      fullTitle: test2.fullTitle(),
      duration: test2.duration
    });
  });
  runner.on("fail", (test2, err) => {
    results.failures.push({
      title: test2.title,
      fullTitle: test2.fullTitle(),
      err: {
        message: err?.message,
        stack: err?.stack
      }
    });
  });
  runner.on("pending", (test2) => {
    results.pending.push({
      title: test2.title,
      fullTitle: test2.fullTitle()
    });
  });
  runner.on("end", () => {
    results.stats = runner.stats || {};
    results.endedAt = Date.now();
    window.__boreDOMTestResults = results;
  });
})();
/*! Bundled license information:

mocha/mocha.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
  (*! https://mths.be/he v1.2.0 by @mathias | MIT license *)
  (*!
   * mocha
   * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
   * MIT Licensed
   *)

react-is/cjs/react-is.development.js:
  (** @license React v17.0.2
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

chai/index.js:
  (*!
   * Chai - flag utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - test utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - expectTypes utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - getActual utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - message composition utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - transferFlags utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * chai
   * http://chaijs.com
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - isProxyEnabled helper
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - addProperty utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - addLengthGuard utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - getProperties utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - proxify utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - addMethod utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - overwriteProperty utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - overwriteMethod utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - addChainingMethod utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - overwriteChainableMethod utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - compareByInspect utility
   * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - getOwnEnumerablePropertySymbols utility
   * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - getOwnEnumerableProperties utility
   * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - isNaN utility
   * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
   * MIT Licensed
   *)
  (*!
   * chai
   * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * chai
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*! Bundled license information:
  
  deep-eql/index.js:
    (*!
     * deep-eql
     * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     *)
    (*!
     * Check to see if the MemoizeMap has recorded a result of the two operands
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {MemoizeMap} memoizeMap
     * @returns {Boolean|null} result
    *)
    (*!
     * Set the result of the equality into the MemoizeMap
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {MemoizeMap} memoizeMap
     * @param {Boolean} result
    *)
    (*!
     * Primary Export
     *)
    (*!
     * The main logic of the `deepEqual` function.
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {Object} [options] (optional) Additional options
     * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
     * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
        complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
        references to blow the stack.
     * @return {Boolean} equal match
    *)
    (*!
     * Compare two Regular Expressions for equality.
     *
     * @param {RegExp} leftHandOperand
     * @param {RegExp} rightHandOperand
     * @return {Boolean} result
     *)
    (*!
     * Compare two Sets/Maps for equality. Faster than other equality functions.
     *
     * @param {Set} leftHandOperand
     * @param {Set} rightHandOperand
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     *)
    (*!
     * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
     *
     * @param {Iterable} leftHandOperand
     * @param {Iterable} rightHandOperand
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     *)
    (*!
     * Simple equality for generator objects such as those returned by generator functions.
     *
     * @param {Iterable} leftHandOperand
     * @param {Iterable} rightHandOperand
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     *)
    (*!
     * Determine if the given object has an @@iterator function.
     *
     * @param {Object} target
     * @return {Boolean} `true` if the object has an @@iterator function.
     *)
    (*!
     * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
     * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
     *
     * @param {Object} target
     * @returns {Array} an array of entries from the @@iterator function
     *)
    (*!
     * Gets all entries from a Generator. This will consume the generator - which could have side effects.
     *
     * @param {Generator} target
     * @returns {Array} an array of entries from the Generator.
     *)
    (*!
     * Gets all own and inherited enumerable keys from a target.
     *
     * @param {Object} target
     * @returns {Array} an array of own and inherited enumerable keys from the target.
     *)
    (*!
     * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
     * each key. If any value of the given key is not equal, the function will return false (early).
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     *)
    (*!
     * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
     * for each enumerable key in the object.
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     *)
    (*!
     * Returns true if the argument is a primitive.
     *
     * This intentionally returns true for all objects that can be compared by reference,
     * including functions and symbols.
     *
     * @param {Mixed} value
     * @return {Boolean} result
     *)
  *)
*/
